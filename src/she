#!/usr/bin/env bash

#:lib/prelude.sh

#:lib/kernel.sh

#:lib/_.sh

#:lib/flag.sh

#:lib/ui.sh

#:lib/must.sh

#:lib/self.sh

#:lib/string.sh

#:lib/array.sh

#:lib/path.sh

#:lib/trap.sh

#:lib/temp.sh

#:lib/os.sh

#:lib/url.sh

#:lib/http.sh

#:lib/file.sh

#:lib/bin.sh

#:lib/git.sh

#:lib/src.sh

#:lib/deb.sh

#:lib/text.sh

#:lib/filetype.sh

#:lib/zip.sh

#/_help/

#/_command/

.usage() {
	local cmd

	# shellcheck disable=2128
	say "$PROGNAME COMMAND [SUBCOMMAND...] [-FLAG=VALUE...] [ARGS]"
	say "Commands:"

	# shellcheck disable=2154
	for cmd in "${!_help[@]}"; do
		printf "\\t%-24s  %s\n" "$cmd" "${_help[$cmd]}"
	done | sort >&2
}

.execute() {
	if [[ $# -eq 0 ]]; then
		.usage
		die 'Command required'
	fi

	local help=

	if [[ $1 = help ]]; then
		help=true

		shift

		if [[ $# -eq 0 ]]; then
			.usage
			die 'Help topic required.'
		fi
	fi

	local -a args=("$@")

	local fun
	local try cmd

	while [[ $# -gt 0 ]]; do
		try+=("$1")
		shift

		if [[ -n ${_command["${try[*]}"]:-} ]]; then
			cmd="${try[*]}"; fun=${_command[$cmd]}
			break
		fi
	done

	if [[ -z ${fun:-} ]]; then
		die "No command found: ${args[*]}"
	fi

	if [[ -n ${help:-} ]]; then
		say "${_help[$cmd]}" ""

		"$fun" -help
	else
		PROGNAME+=("$cmd"); readonly PROGNAME

		"$fun" "$@"
	fi
}

.source() {
	echo "UNDERSCORE=$(self.path)"
	echo
	cat <<'EOF'
.() {
	#:lib/prelude.sh

	declare -grx UNDERSCORE=$UNDERSCORE

	case ${1:-} in
	-root)
		[[ ${EUID:-} -eq 0 ]] || { echo >&2 'Root privileges required.'; exit 1; }
		shift
		;;
	esac

	_.die() {
		"$UNDERSCORE" die "$@"; exit $?
	}

	_.cry() {
		"$UNDERSCORE" cry "$@"; exit $?
	}

	_.bye() {
		"$UNDERSCORE" bye "$@"; exit $?
	}

	_.bug() {
		"$UNDERSCORE" bug "$@"; exit $?
	}

	_.enter() {
		local dir

		if dir=$("$UNDERSCORE" enter "$@") && [[ -n $dir ]]; then
			pushd "$dir" &>/dev/null || exit
		fi
	}

	_.leave() {
		popd &>/dev/null || exit
	}

	unset -f "${FUNCNAME[0]}"
}

_() {
	local cmd=$1

	case $cmd in
	die|cry|bye|bug|enter|leave) shift; _."$cmd" "$@" ;;
	*)                       "$UNDERSCORE" "$@"   ;;
	esac
}

. "$@"
EOF
}

.sourced() {
	if [[ $# -gt 0 ]]; then
		[[ $1 = . ]] && return 0 # source explicitly specified
	else
		[[ -t 1   ]] || return 0 # backticked or piped without args
	fi

	return 1
}

.init() {
	trap.setup
}

main() {
	if .sourced "$@"; then
		.source "$@"
	else
		.init
		.execute "$@"
	fi
}

[[ "${BASH_SOURCE[0]}" != "$0" ]] || main "$@"
