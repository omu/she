#:lib/shebang.sh

#:lib/_.sh

#:lib/flag.sh

#:lib/must.sh

#:lib/color.sh

#:lib/ui.sh

#:lib/tap.sh

#:lib/self.sh

if [[ ${OVERSCORE_SOURCE:-} = true ]] || [[ "${BASH_SOURCE[0]}" = "$0" ]]; then
	#/help/

	declare -Ag _command=(
		['isnt']='test.isnt'
		['is']='test.is'
		['notok']='test.notok'
		['ok']='test.ok'
		['success']='tap.success'
		['failure']='tap.failure'
		['err']='tap.err'
	)

	.usage() {
		local cmd

		# shellcheck disable=2128
		.say "$PROGNAME COMMAND... [-FLAG=VALUE...] [ARGS]"
		.say "Commands:"

		# shellcheck disable=2154
		for cmd in "${!_command[@]}"; do
			local fun=${_command[$cmd]}

			printf "\\t%-24s  %s\n" "$cmd" "${_help[$fun]}"
		done | sort >&2
	}

	.execute() {
		if [[ $# -eq 0 ]]; then
			.usage
			.die 'Command required'
		fi

		local help=

		if [[ $1 = help ]]; then
			help=true

			shift

			if [[ $# -eq 0 ]]; then
				.usage
				.die 'Help topic required'
			fi
		fi

		local -a args=("$@") found=() try

		while [[ $# -gt 0 ]]; do
			try+=("$1")

			[[ -n ${_command[${try[*]}]:-} ]] || break

			found+=("${try[*]}")

			shift
		done

		[[ ${#found[@]} -gt 0 ]] || .die "No command found: ${args[*]}"

		local cmd=${found[-1]}
		local fun=${_command["$cmd"]}

		readonly PROGNAME+=("$cmd")

		if [[ -n ${help:-} ]]; then
			.say "${_help[$fun]}" ""
			"$fun" -help
		else
			"$fun" "$@"
		fi
	}

	.source() {
		sed 's/^\t//' <<'EOF'
		#:lib/_.sh: .prelude+ .say .cry .die .bug .contains .available .callable

		#:lib/test.sh
EOF
		echo
		echo "OVERSCORE=$(self.path)"
		echo
		sed 's/^\t//' <<'EOF'
		#:src/t.sh
EOF
	}

	.main() {
		if ! .interactive && [[ $# -eq 0 ]]; then
			.source
		else
			.execute "$@"
		fi
	}

	.main "$@"
fi
