#!/usr/bin/env bash

[ -n "${BASH_VERSION:-}"        ] || { echo >&2 'Bash required.';                     exit 1; }
[[ ${BASH_VERSINFO[0]:-} -ge 4 ]] || { echo >&2 'Bash version 4 or higher required.'; exit 1; }

# Protected functions

.available() {
	command -v "${1?${FUNCNAME[0]}: missing argument}" &>/dev/null
}

.bug() {
	if [[ $# -gt 0 ]]; then
		echo -e >&2 "BUG: $*"
	else
		echo >&2 ""
	fi

	exit 127
}

.bye() {
	if [[ $# -gt 0 ]]; then
		echo -e >&2 "$*"
	else
		echo >&2 ""
	fi

	exit 0
}

.callable() {
	[[ $(type -t "${1?${FUNCNAME[0]}: missing argument}" || true) == function ]]
}

.contains() {
	: "${1?${FUNCNAME[0]}: missing argument}"

	local element

	for element in "${@:2}"; do
		if [[ $element = "$1" ]]; then
			return 0
		fi
	done

	return 1
}

.cry() {
	if [[ $# -gt 0 ]]; then
		echo -e >&2 "W: $*"
	else
		echo >&2 ""
	fi
}

.die() {
	if [[ $# -gt 0 ]]; then
		echo -e >&2 "E: $*"
	else
		echo >&2 ""
	fi

	exit 1
}

.err() {
	.out "$@" >&2
}

.expired() {
	local -i expiry=${1?${FUNCNAME[0]}: missing argument}; shift

	case $expiry in
	-1) return 1 ;;
	0)  return 0 ;;
	esac

	local file
	for file; do
		if [[ -e $file ]] && [[ -z $(find "$file" -mmin +"$expiry" 2>/dev/null) ]]; then
			return 1
		fi
	done

	return 0
}

.interactive() {
	[[   -t 1 ]]
}

.out() {
	local arg

	for arg; do
		echo -e "$arg"
	done

	if .piped; then
		cat
	fi
}

.piped() {
	[[ ! -t 0 ]]
}

.load() {
	# shellcheck disable=2128
	local _load_old_=$PWD

	[[ -v _load_dirs_ ]] || declare -ag _load_dirs_=(
		"$(dirname "$(readlink -f "$0")")"
	)

	local _load_src_

	for _load_src_; do
		builtin cd "${_load_dirs_[-1]}" || .die "Chdir error: ${_load_dirs_[-1]}"

		local _load_src_found_

		for _load_src_found_ in "$_load_src_" "$_load_src_".sh; do
			if [[ -f $_load_src_found_ ]]; then
				_load_src_found_=$(readlink -f "$_load_src_found_")

				_load_dirs_+=("$(dirname "$_load_src_found_")")

				builtin source "$_load_src_found_"
			fi
		done

		unset _load_src_found_
	done

	unset _load_src_

	builtin cd "$_load_old_" || .die "Chdir error: $_load_old_"
	unset _load_old_
}

.merge() {
	local -n lhs=${1?${FUNCNAME[0]}: missing argument}; shift
	local -n rhs=${1?${FUNCNAME[0]}: missing argument}; shift

	local key
	for key in "${!rhs[@]}"; do
		# shellcheck disable=2034
		lhs[$key]=${rhs[$key]}
	done
}

.must() {
	if [[ ${1:-} = -- ]]; then
		shift

		eval -- "${@?${FUNCNAME[0]}: missing argument}" || .die "Command failed: $*"
	else
		eval -- "${@:2}" || .die "${1?${FUNCNAME[0]}: missing argument}"
	fi
}

.say() {
	echo -e "${@-""}"
}

.should() {
	if [[ ${1:-} = -- ]]; then
		shift

		eval -- "${@?${FUNCNAME[0]}: missing argument}" || .cry "Exit code $? is suppressed: $*"
	else
		eval -- "${@:2}" || .cry "${1?${FUNCNAME[0]}: missing argument}"
	fi
}

# Init

# shellcheck disable=2034,2128
.prelude() {
	set -Eeuo pipefail; shopt -s nullglob; [[ -z ${TRACE:-} ]] || set -x; unset CDPATH; IFS=$' \t\n'

	export LC_ALL=C.UTF-8 LANG=C.UTF-8

	declare -ag PROGNAME=("${0##*/}") # Program name

	declare -Ag PWD; PWD[.]=$PWD      # Manage PWD
}

.prelude

.runtime() {
	# Default variable as a hash
	declare -gA _=()

	# shellcheck disable=2034

	# Core environment
	if [[ ${EUID:-} -eq 0 ]]; then
		readonly _RUN=${UNDERSCORE_VOLATILE_PREFIX:-/run/_}
		readonly _USR=${UNDERSCORE_PERSISTENT_PREFIX:-/usr/local}
		readonly _ETC=${UNDERSCORE_CONFIG_PATH:-/etc/_:"$_USR"/etc/_:"$_RUN"/etc}
	else
		XDG_RUNTIME_DIR=${XDG_RUNTIME_DIR:-/run/user/"$EUID"}
		XDG_CONFIG_HOME=${XDG_CONFIG_HOME:-"$HOME"/.config}
		XDG_CACHE_HOME=${XDG_CACHE_HOME:-"$HOME"/.cache}

		readonly _RUN=${UNDERSCORE_VOLATILE_PREFIX:-"$XDG_RUNTIME_DIR"/_}
		readonly _USR=${UNDERSCORE_PERSISTENT_PREFIX:-"$HOME"/.local}
		readonly _ETC=${UNDERSCORE_CONFIG_PATH:-/etc/_:/usr/local/etc/_:"$XDG_CONFIG_HOME"/_:"$_RUN"/etc}
	fi

	export PATH="$_RUN"/bin:"$PATH" SRCTMP="$_RUN"
}

# Libraries

# array.sh - Array functions

# Return if array contains the given element
array.contains() {
	local -n array_contains_=${1?${FUNCNAME[0]}: missing argument}; shift
	local    element=${1?${FUNCNAME[0]}: missing argument};         shift

	.contains "$element" "${array_contains_[@]}"
}

# Duplicate array
array.dup() {
	local -n array_dup_lhs_=${1?${FUNCNAME[0]}: missing argument}; shift
	local -n array_dup_rhs_=${1?${FUNCNAME[0]}: missing argument}; shift

	local key
	for key in "${!array_dup_rhs_[@]}"; do
		# shellcheck disable=2034
		array_dup_lhs_[$key]=${array_dup_rhs_[$key]}
	done
}

# Join array with the given separator
array.join() {
	local IFS=${1?${FUNCNAME[0]}: missing argument}; shift

	echo "$*"
}

# color.sh - Colors

color.code() {
	local name="${1?${FUNCNAME[0]}: missing argument}"; shift
	local code="${_color[$name]:-}"

	[[ -n $code ]] || .bug "No such color: $name"

	echo -en "$code"
}

color.echo() {
	local color="${1?${FUNCNAME[0]}: missing argument}"; shift

	local code reset
	code=$(color.code "$color")
	reset=$(color.code reset)

	echo -e "${code}${*}${reset}"
}

color.expand() {
	while [[ $# -gt 0 ]]; do
		local -n color_expand_=${1?missing argument}
		shift

		local key value
		for key in "${!color_expand_[@]}"; do
			value=${color_expand_[$key]}

			color_expand_[$key]=${_color[$value]}
		done
	done
}

color.out() {
	local color="${1?${FUNCNAME[0]}: missing argument}"; shift

	local code reset

	code=$(color.code "$color")
	reset=$(color.code reset)

	echo -en "$code"
	.out
	echo -en "$reset"
}

color.setup() {
	while [[ $# -gt 0 ]]; do
		local key=${1%%=*}; value=${1#*=}

		if [[ -n ${_color[$value]:-} ]]; then
			_color[$key]=${_color[$value]}
		else
			_color[$key]=$value
		fi

		shift
	done
}

# color - Init

# shellcheck disable=2034
color.init_() {
	declare -Ag _color=(
		# Basic colors with variants - prefix +: bold, prefix -: dim, suffix -: reverse

		[black]='\e[38;5;8m'          [+black]='\e[1m\e[38;5;8m'     [-black]='\e[38;5;0m'
		[black-]='\e[48;5;8m'         [+black-]='\e[1m\e[48;5;8m'    [-black-]='\e[48;5;0m'

		[blue]='\e[38;5;12m'          [+blue]='\e[1m\e[38;5;12m'     [-blue]='\e[38;5;4m'
		[blue-]='\e[48;5;12m'         [+blue-]='\e[1m\e[48;5;12m'    [-blue-]='\e[48;5;4m'

		[cyan]='\e[38;5;14m'          [+cyan]='\e[1m\e[38;5;14m'     [-cyan]='\e[38;5;6m'
		[cyan-]='\e[48;5;14m'         [+cyan-]='\e[1m\e[48;5;14m'    [-cyan-]='\e[48;5;6m'

		[green]='\e[38;5;10m'         [+green]='\e[1m\e[38;5;10m'    [-green]='\e[38;5;2m'
		[green-]='\e[48;5;10m'        [+green-]='\e[1m\e[48;5;10m'   [-green-]='\e[48;5;2m'

		[magenta]='\e[38;5;13m'       [+magenta]='\e[1m\e[38;5;13m'  [-magenta]='\e[38;5;5m'
		[magenta-]='\e[48;5;13m'      [+magenta-]='\e[1m\e[48;5;13m' [-magenta-]='\e[48;5;5m'

		[red]='\e[38;5;9m'            [+red]='\e[1m\e[38;5;9m'       [-red]='\e[38;5;1m'
		[red-]='\e[48;5;9m'           [+red-]='\e[1m\e[48;5;9m'      [-red-]='\e[48;5;1m'

		[white]='\e[38;5;15m'         [+white]='\e[1m\e[38;5;15m'    [-white]='\e[38;5;7m'
		[white-]='\e[48;5;15m'        [+white-]='\e[1m\e[48;5;15m'   [-white-]='\e[48;5;7m'

		[yellow]='\e[38;5;11m'        [+yellow]='\e[1m\e[38;5;11m'   [-yellow]='\e[38;5;3m'
		[yellow-]='\e[48;5;11m'       [+yellow-]='\e[1m\e[48;5;11m'  [-yellow-]='\e[48;5;3m'

		# Attributes

		[bold]='\e[1m'                [dark]='\e[2m'                 [underlined]='\e[4m'
		[blink]='\e[5m'               [reverse]='\e[7m'              [reset]='\e[0m'

		# Priority aliases
		[high]='\e[1m'                [medium]=''                    [low]='\e[2m'
	)
}

color.init_

deb.add_key() {
	local artifact=

	if [[ ! -d $HOME/.gnupg ]]; then
		artifact=$HOME/.gnupg

		mkdir "$artifact" && chmod 700 "$artifact"
	fi

	local err
	deb.add_key_ "$@"  || err=$? && err=$?

	[[ -z ${artifact:-} ]] || rm -rf "$artifact"

	return "$err"
}

deb.update() {
	if .expired 60 /var/cache/apt/pkgcache.bin; then
		.must 'Root permissions required; use sudo.' [[ ${EUID:-} -eq 0 ]]

		.getting 'Updating package index' apt-get update -y
	fi
}

deb.install() {
	[[ $# -gt 0 ]] || return 0

	deb.update

	.getting 'Installing packages' apt-get install --yes --no-install-recommends "$@"
}

deb.installed() {
	local package="${1?${FUNCNAME[0]}: missing argument}"; shift

	[[ -n "$(dpkg-query -W -f='${Installed-Size}' "$package" 2>/dev/null ||:)" ]]
}

deb.install_manual() {
	[[ $# -gt 0 ]] || return 0

	deb.update

	local url

	for url; do
		local deb

		file.download "$url" deb

		dpkg-deb --info "$deb" &>/dev/null || .die "Not a valid Debian package: $url"
		dpkg -i -- "$deb" 2>/dev/null || true
		apt-get -y install --no-install-recommends --fix-broken

		rm -f -- "$deb"
	done
}

deb.dist_added() {
	local dist=${1?${FUNCNAME[0]}: missing argument}; shift

	grep -qE "^deb.*\bdebian.org\b.*\b$dist\b" /etc/apt/*.list /etc/apt/sources.list.d/*.list
}

deb.dist_valid() {
	local dist=${1?${FUNCNAME[0]}: missing argument}; shift

	http.is http://ftp.debian.org/debian/dists/"$dist"/ OK
}

deb.missings() {
	local -n deb_missings_=${1?${FUNCNAME[0]}: missing argument}; shift

	local package
	for package; do
		# shellcheck disable=2016
		deb.installed "$package" || deb_missings_+=("$package")
	done
}

deb.uninstall() {
	[[ $# -gt 0 ]] || return 0

	local -a packages=()

	deb.missings packages "$@"
	[[ ${#packages[@]} -gt 0 ]] || return 0

	.must 'Root permissions required; use sudo.' [[ ${EUID:-} -eq 0 ]]

	apt-get purge -y "${packages[@]}"

	.should -- apt-get autoremove -y
	.should -- apt-get autoclean -y
}

# deb - Private functions

deb.add_key_() {
	local url=${1?${FUNCNAME[0]}: missing argument}; shift

	local temp_file
	temp.file temp_file

	http.get "$url" >"$temp_file" || .die "Couldn't get key file: $url"

	local -a questioned_fingerprints installed_fingerprints

	mapfile -t questioned_fingerprints < <(
		gpg -nq --import --import-options import-show --with-colons "$temp_file" |
		awk -F: '$1 == "fpr" { print $10 }' 2>/dev/null
	)

	# shellcheck disable=2034
	mapfile -t installed_fingerprints < <(
		apt-key adv --list-public-keys --with-fingerprint --with-colon |
		awk -F: '$1 == "fpr" { print $10 }' 2>/dev/null
	)

	local fingerprint unfound
	for fingerprint in "${questioned_fingerprints[@]}"; do
		if ! .contains "$fingerprint" "${installed_fingerprints[@]}"; then
			unfound=$fingerprint
			break
		fi
	done

	if [[ -n ${unfound:-} ]]; then
		.running 'Adding APT key'
		apt-key add "$temp_file"
	fi

	temp.clean temp_file
}

# debug - Debug functions

.dbg() {
	[[ $# -gt 0 ]] || return 0

	# shellcheck disable=2178,2155
	local -n dbg_=$1

	echo "${!dbg_}"

	local key
	for key in "${!dbg_[@]}"; do
		printf '  %-16s  %s\n' "${key}" "${dbg_[$key]}"
	done | sort

	echo
}

.stacktrace() {
	local -i i=1

	while [[ -n ${BASH_SOURCE[$i]:-} ]]; do
		echo "${BASH_SOURCE[$i]}":"${BASH_LINENO[$((i-1))]}":"${FUNCNAME[$i]}"\(\)
		i=$((i + 1))
	done | grep -v "^${BASH_SOURCE[0]}"
}

# callback.sh - Handle callback functions

.callback() {
	local group=${1?${FUNCNAME[0]}: missing argument}; shift

	local -a _callback_funcs_

	mapfile -t _callback_funcs_ < <(
		shopt -s extdebug

		declare -F | awk '/^declare -f '"$group"'[.]/ { print $3 }' |
		while read -r func; do declare -F "$func"; done |
		sort -t' ' -k2 -n | cut -f1 -d' '
	)

	local func

	local -a _callback_early_ _callback_now_ _callback_late_

	for func in "${_callback_funcs_[@]}"; do
		case $func in
		*_early|*.early_|*.early) _callback_early_+=("$func") ;;
		*_late|*.late_|*.late)    _callback_late_+=("$func")  ;;
		*)                        _callback_now_+=("$func")   ;;
		esac
	done

	local failer=$group.fail
	.callable "$failer" || failer=.callback_fail_default_

	local -i err=0

	for func in "${_callback_early_[@]}"; do
		"$func" "$@" || { "$failer" "$func" "$@"; err+=1; }
	done

	for func in "${_callback_now_[@]}"; do
		"$func" "$@" || { "$failer" "$@"; err+=1; }
	done

	for func in "${_callback_late_[@]}"; do
		"$func" "$@" ||  { "$failer" "$@"; err+=1; }
	done

	return $err
}

# Private functions

.callback_fail_default_() {
	local func=${1?${FUNCNAME[0]}: missing argument}; shift

	case ${SIGNAL:-} in
	INT|QUIT) return 0 ;;
	esac

	.cry "Callback failed: $func"
}

# defer.sh - Deferred functions

# Register files/directories to clean up at exit
.clean() {
	[[ -v _defer_initialized_ ]] || .defer

	_defer_clean_+=("$@")
}

# Trap defer setup
# shellcheck disable=2120
.defer() {
	if [[ -v _defer_initialized_ ]]; then
		return
	else
		_defer_initialized_=true

		declare -ag _defer_clean_=()

		if [[ -n $(builtin trap -p 2>/dev/null) ]]; then
			.cry 'Trap already taken.'

			return
		fi
	fi

	local -a signals=("$@")
	[[ $# -gt 0 ]] || signals=(EXIT HUP INT KILL QUIT TERM)

	local signal
	for signal in "${signals[@]}"; do
		# shellcheck disable=2064
		builtin trap "_defer_ $signal" "$signal"
	done

	# Prevent using trap
	trap() {
		.bug 'Using trap is forbidden; please use defer.* functions.'
	}

	# shellcheck disable=2139
	alias .untrap="trap - ${signals[*]}"

	_defer_() {
		local -r SIGNAL=$1 ERR=$?

		.callback defer

		if [[ -v _defer_clean_ ]] && [[ "${#_defer_clean_[@]}" -gt 0 ]]; then
			rm -rf -- "${_defer_clean_[@]}"
		fi

		builtin trap - EXIT

		if [[ $SIGNAL = INT ]] || [[ $SIGNAL = QUIT ]]; then
			builtin trap - "$SIGNAL"; kill -s "$SIGNAL" "$$"
		fi

		return "$ERR"
	}

	readonly -f _defer_
}

# file.sh - File related operations

file.chmog() {
	local mog=${1?${FUNCNAME[0]}: missing argument}; shift
	local dst=${1?${FUNCNAME[0]}: missing argument}; shift

	local mode owner group
	IFS=: read -r mode owner group <<<"$mog"

	[[ -z ${mode:-}  ]] || .must -- chmod "$mode"
	[[ -z ${owner:-} ]] || .must -- chown "$owner"
	[[ -z ${group:-} ]] || .must -- chgrp "$group"
}

file.cp() {
	local src=${1?${FUNCNAME[0]}: missing argument}; shift
	local dst=${1?${FUNCNAME[0]}: missing argument}; shift
	local mog=${1:-}

	local dir=${dst%/*}
	[[ -d $dir ]] || .must -- mkdir -p "$dir"

	cp -a "$src" "$dst"

	[[ -z ${mog:-} ]] || file.chmog "$mog" "$dst"
}

file.download() {
	local    url=${1?${FUNCNAME[0]}: missing argument};                shift
	local -n file_download_dst_=${1?${FUNCNAME[0]}: missing argument}; shift

	local download
	temp.file download

	http.download "$url" "$download"
	.must -- chmod 644 "$download"

	# shellcheck disable=2034
	file_download_dst_=$download
}

file.enter() {
	local dir=${1:-}

	[[ -n $dir ]] || return 0

	if [[ -d $dir ]]; then
		.must -- cd "$dir"
	else
		dir=${dir%/*}
		[[ -d $dir ]] || .die "No path found to enter: $dir"
		.must -- cd "$dir"
	fi

	# shellcheck disable=2128
	echo "$PWD"
}

file.ln() {
	local src=${1?${FUNCNAME[0]}: missing argument}; shift
	local dst=${1?${FUNCNAME[0]}: missing argument}; shift
	local mog=${1:-}

	local dir=${dst%/*}
	[[ -d $dir ]] || .must -- mkdir -p "$dir"

	src=$(realpath -m --relative-base "${dst%/*}" "$src")
	.must -- ln -sf "$src" "$dst"

	[[ -z ${mog:-} ]] || file.chmog "$mog" "$dst"
}

file.match() {
	local name=${1?${FUNCNAME[0]}: missing argument}; shift

	local fmt

	for fmt; do
		local pattern

		# shellcheck disable=2059
		printf -v pattern "$fmt" "$name"

		local -a matches=()

		mapfile -t matches < <(find . -type f -path "$pattern" -true 2>/dev/null)

		if [[ ${#matches[@]} -eq 1 ]]; then
			echo "${matches[0]}"
			return 0
		fi
	done

	return 1
}

file.cp() {
	local src=${1?${FUNCNAME[0]}: missing argument}; shift
	local dst=${1?${FUNCNAME[0]}: missing argument}; shift
	local mog=${1:-}

	local dir=${dst%/*}
	[[ -d $dir ]] || .must -- mkdir -p "$dir"

	mv -f "$src" "$dst"

	[[ -z ${mog:-} ]] || file.chmog "$mog" "$dst"
}

file.run() {
	# shellcheck disable=2034
	local -A file_run_env_=()

	file.run- file_run_env_ "$@"
}

file.rune() {
	file.run- "$@"
}

file.upcd() {
	local cwd=${1?${FUNCNAME[0]}: missing argument}; shift

	.must -- cd "$cwd"

	while :; do
		local try

		for try; do
			if [[ -e $try ]]; then
				return 0
			fi
		done

		# shellcheck disable=2128
		if [[ $PWD == "/" ]]; then
			break
		fi

		.must -- cd ..
	done
}

# file - Private functions

file.run-() {
	local -n file_env_=${1?${FUNCNAME[0]}: missing argument}; shift
	local file=${1?${FUNCNAME[0]}: missing argument};         shift

	[[ -f $file ]] || [[ $file =~ [.][^./]+$ ]] || file=$file.sh

	filetype.runnable "$file" || .die "File is not runnable: $file"

	local -a argv=()

	[[ ${#file_env_[@]} -eq 0 ]] || argv+=(env "${file_env_[@]}")

	if [[ ! -x "$file" ]]; then
		if filetype.interpretable "$file"; then
			local -a shebang
			filetype.shebang "$file" shebang

			case ${shebang[0]} in
			*/env)
				[[ ${#file_env_[@]} -eq 0 ]] || argv+=("${shebang[@]:1}")
				;;
			*)
				# shellcheck disable=2206
				argv+=("${shebang[@]}")
				;;
			esac
		fi
	fi

	argv+=("$file" "$@")

	"${argv[@]}"
}

# filetype.sh - Filetype detection

filetype.compressed() {
	local file=${1?${FUNCNAME[0]}: missing argument}; shift

	local mime; mime=$(file --mime-type --brief "$file")

	case $mime in
	application/gzip|application/zip|application/x-xz|application/x-bzip2|application/x-zstd)
		local zip=$mime; zip=${zip##*/}; zip=${zip##*-}

		return 0 ;;
	*)
		return 1 ;;
	esac
}

filetype.executable() {
	local file=${1?${FUNCNAME[0]}: missing argument}; shift

	local mime encoding

	IFS='; ' read -r mime encoding < <(file --mime --brief "$file")

	if [[ $encoding =~ binary$ ]]; then
		if [[ $mime  =~ -executable$ ]]; then
			return 0
		fi
	fi

	return 1
}

filetype.interpretable() {
	local file=${1?${FUNCNAME[0]}: missing argument}; shift

	local mime encoding

	IFS='; ' read -r mime encoding < <(file --mime --brief "$file")

	if [[ ! $encoding =~ binary$ ]]; then
		if head -n 1 "$file" | grep -q '^#!' 2>/dev/null; then
			return 0
		fi
	fi

	return 1
}

filetype.mime() {
	local file=${1?${FUNCNAME[0]}: missing argument}; shift

	file --mime-type --brief "$file"
}

filetype.mimez() {
	local file=${1?${FUNCNAME[0]}: missing argument}; shift

	file --mime-type --brief --uncompress-noreport "$file"
}

filetype.runnable() {
	local file=${1?${FUNCNAME[0]}: missing argument}; shift

	local mime encoding

	IFS='; ' read -r mime encoding < <(file --mime --brief "$file")

	if [[ $encoding =~ binary$ ]]; then
		if [[ $mime  =~ -executable$ ]]; then
			return 0
		fi
	else
		if head -n 1 "$file" | grep -q '^#!' 2>/dev/null; then
			return 0
		fi
	fi

	return 1
}

filetype.runnables() {
	local    file=${1?${FUNCNAME[0]}: missing argument};                shift
	local -n filetype_runnables_=${1?${FUNCNAME[0]}: missing argument}; shift

	if [[ -d $file ]]; then
		local f
		for f in "$file"/*; do
			filetype.runnable "$f" || continue
			filetype_runnables_+=("$f")
		done
	elif filetype.runnable "$file"; then
		filetype_runnables_+=("$file")
	fi
}

filetype.shebang() {
	local    file=${1?${FUNCNAME[0]}: missing argument}; shift
	local -n lib_filetype_shebang_=${1?${FUNCNAME[0]}: missing argument}; shift

	# shellcheck disable=2034
	local lib_filetype_shebang_string

	lib_filetype_shebang_string_=$(head -n 1 "$file" 2>/dev/null || true)
	lib_filetype_shebang_string_=${lib_filetype_shebang_string_#\#!}
	lib_filetype_shebang_string_=${lib_filetype_shebang_string_# }

	# shellcheck disable=2034,2206
	lib_filetype_shebang_=($lib_filetype_shebang_string_)
}

# flag.sh - Flag handling

flag.args_() {
	local -a keys

	mapfile -t keys < <(
		for key in "${!_[@]}"; do
			[[ $key =~ ^[1-9][0-9]*$ ]] || continue

			echo "$key"
		done | sort -u
	)

	local key

	if [[ $# -gt 0 ]]; then
		local -n _values_=$1

		for key in "${keys[@]}"; do
			_values_+=("${_[$key]}")
		done

		_values_=("${_values_[@]}")
	else
		for key in "${keys[@]}"; do
			echo "${_[$key]}"
		done
	fi
}

flag.env_() {
	local -a keys

	mapfile -t keys < <(
		for key in "${!_[@]}"; do
			[[ $key =~ ^[[:alpha:]_][[:alnum:]_]*$ ]] || continue

			echo "$key"
		done | sort -u
	)

	local key

	if [[ $# -gt 0 ]]; then
		# shellcheck disable=2178
		local -n _values_=$1

		for key in "${keys[@]}"; do
			_values_+=("$key='${_[$key]}'")
		done
	else
		for key in "${keys[@]}"; do
			echo "$key='${_[$key]}'"
		done
	fi
}

flag.false() {
	! flag.true "$@"
}

flag.load() {
	local -n _load_src_=${1?${FUNCNAME[0]}: missing argument}; shift

	local key
	for key in "${!_load_src_[@]}"; do
		# shellcheck disable=2034
		_[$key]=${_load_src_[$key]}
	done
}

flag.nil() {
	[[ ${_[$1]:-} = "$NIL" ]]
}

flag.parse_() {
	if .contains -help "$@"; then
		flag.usage_and_bye_
	fi

	local -A flag_result_

	local -i argc=0
	while [[ $# -gt 0 ]]; do
		local key value

		if [[ $1 =~ ^-*[[:alpha:]_][[:alnum:]_]*= ]]; then
			key=${1%%=*}; value=${1#*=}
			if [[ $key =~ ^-.+$ ]] && [[ ! -v _[$key] ]]; then
				.die "Unrecognized flag: $key"
			fi
		elif [[ $1 == '--' ]] && [[ -z ${_[.dash]:-} ]]; then
			shift
			break
		else
			key=$((++argc)); value=$1
		fi

		# shellcheck disable=2034
		flag_result_["$key"]=${value:-${_["$key"]:-}}

		shift
	done

	flag.load flag_result_

	flag._validate_ $argc
}

flag.peek_() {
	if .contains -help "$@"; then
		flag.usage_and_bye_
	fi

	local -A flag_result_

	local -i argc=0
	while [[ $# -gt 0 ]]; do
		local key value

		if [[ $1 =~ ^-*[[:alpha:]_][[:alnum:]_]*= ]]; then
			key=${1%%=*}; value=${1#*=}
		elif [[ $1 == '--' ]] && [[ -z ${_[.dash]:-} ]]; then
			shift
			break
		else
			key=$((++argc)); value=$1
		fi

		# shellcheck disable=2034
		flag_result_["$key"]=${value:-${_["$key"]:-}}

		shift
	done

	flag.load flag_result_

	flag._validate_ $argc
}

flag.true() {
	.bool "${_[$1]:-}"
}

flag.usage_() {
	if [[ -n ${_[.help]:-} ]]; then
		# shellcheck disable=2128
		.say "Usage: ${PROGNAME[*]} ${_[.help]}"
	else
		# shellcheck disable=2128
		.say "Usage: ${PROGNAME[*]}"
	fi
}

flag.usage_and_die_() {
	flag.usage_

	.die "$@"
}

# shellcheck disable=2120
flag.usage_and_bye_() {
	flag.usage_

	.bye "$@"
}

# flag - Private functions

flag._args_() {
	local n=${1?${FUNCNAME[0]}: missing argument}; shift

	local argc=${_[.argc]:-0}

	[[ $argc != '-' ]] || return 0

	local lo hi

	if [[ $argc =~ ^[0-9]+$ ]]; then
		lo=$argc; hi=$argc
	elif [[ $argc =~ ^[0-9]*-[0-9]*$ ]]; then
		IFS=- read -r lo hi <<<"$argc"
	else
		.bug "Incorrect range: $argc"
	fi

	local message
	if   [[ -n ${lo:-} ]] && [[ $n -lt $lo ]]; then
		message='Too few arguments'
	elif [[ -n ${hi:-} ]] && [[ $n -gt $hi ]]; then
		message='Too many arguments'
	else
		return 0
	fi

	flag.usage_and_die_ "$message"
}

flag._nils_() {
	local -a required=()

	local key
	for key in "${!_[@]}"; do
		if flag.nil "$key"; then
			required+=("$key")
		fi
	done

	[[ ${#required[@]} -eq 0 ]] || .die "Value missing for: ${required[*]}"
}

flag._validate_() {
	flag._args_ "$@"
	flag._nils_
}

# flag - Protected functions

.bool() {
	local value=${1:-}

	value=${value,,}

	case $value in
	true|t|1|on|yes|y)
		return 0
		;;
	false|f|0|off|no|n|"")
		return 1
		;;
	*)
		.bug "Invalid boolean: $value"
	esac
}

# flag - Init

flag._init() {
	shopt -s expand_aliases

	# shellcheck disable=2142
	alias flag.parse='flag.parse_ "$@"; local -a __argv__ ARGV=("$@"); flag.args_ __argv__; set -- "${__argv__[@]}"; unset -v __argv__'

	# shellcheck disable=2142
	alias flag.peek='flag.peek_ "$@"; local -a __argv__=() ARGV=("$@"); flag.args_ __argv__; set -- "${__argv__[@]}"; unset -v __argv__'

	# shellcheck disable=2034
	declare -gr NIL="\0"
}

flag._init

# git.sh - Git functions

git.clone() {
	local src=${1?${FUNCNAME[0]}: missing argument}; shift
	local dst=${1?${FUNCNAME[0]}: missing argument}; shift
	local ref=${1:-}

	.must "Destination already exists: $dst" [[ ! -e "$dst" ]]

	local -a options=(
		'--single-branch'
		'--quiet'
	)

	[[ -z ${ref:-} ]] || options+=(
		'--branch'
		"$ref"
	)

	.getting "Cloning $src"
	.must -- git clone "${options[@]}" "$src" "$dst"

	if [[ -n ${ref:-} ]] && git.ref.is "$ref" tag; then
		git.set.immutable true
	fi
}

git.default-branch() {
	local repo=${1:-.}

	git.must "$repo" sane

	git -C "$repo" symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@'
}

git.is() {
	local repo=${1?${FUNCNAME[0]}: missing argument};    shift
	local feature=${1?${FUNCNAME[0]}: missing argument}; shift

	local func=git.is."$feature"-

	.callable "$func" || .bug "No such predicate: $feature"

	"$func" "$repo"
}

git.must() {
	local repo=${1?${FUNCNAME[0]}: missing argument};    shift
	local feature=${1?${FUNCNAME[0]}: missing argument}; shift

	git.is "$repo" "$feature" || .die "Repository is not ${feature//-/ }: $repo"
}

git.ref.is() {
	local repo=${1?${FUNCNAME[0]}: missing argument}; shift
	local ref=${1?${FUNCNAME[0]}: missing argument};  shift
	local type=${1?${FUNCNAME[0]}: missing argument}; shift

	case $type in
	branch)
		git -C "$repo" show-ref -q --verify "refs/heads/$ref" &>/dev/null
		;;
	tag)
		git -C "$repo" show-ref -q --verify "refs/tags/$ref" &>/dev/null
		;;
	remote)
		git -C "$repo" show-ref -q --verify "refs/remote/$ref" &>/dev/null
		;;
	hash|commit)
		git -C "$repo" rev-parse --verify "$ref^{commit}" &>/dev/null
		;;
	*)
		.bug "Unrecognized ref type: $type"

		return 1
	esac
}

git.reset() {
	local repo=${1:-.}

	.must -- git -C "$repo" reset --hard
}

git.set.immutable() {
	local repo=${1:-.}

	.must -- git -C "$repo" config --type bool core.x-immutable true
}

git.set.mutable() {
	local repo=${1:-.}

	.must -- git -C "$repo" config --type bool core.x-immutable false
}

git.switch() {
	local repo=${1?${FUNCNAME[0]}: missing argument}; shift
	local branch=${1:-}

	[[ -n $branch ]] || branch=$(git.default-branch "$repo")

	.must -- git -C "$repo" checkout --quiet "$branch"
}

git.top() {
	local path=${1:-}

	git.must.sane "$path" && .must -- cd "$(git.topdir "$path")"
}

git.topdir() {
	local path=${1:-}

	if [[ -n $path ]]; then
		[[ -e $path ]] || .die "No such path found: $path"

		local d
		[[ -d $path ]] || d=${path%/*}

		.must -- pushd "$d" &>/dev/null
	fi

	local dir
	dir=$(git rev-parse --git-dir) && dir=$(cd "$dir" && pwd)/ && echo "${dir%%/.git/*}"

	if [[ -n $path ]]; then
		.must -- popd &>/dev/null
	fi
}

git.update() {
	local repo=${1:-.}

	if ! git.is "$repo" immutable; then
		.getting "Updating repo"
		.must -- git pull -q
	fi
}

# Private functions

git.is.clean-() {
	local repo=${1:-.}

	git -C "$repo" rev-parse --verify HEAD >/dev/null &&
	git -C "$repo" update-index -q --ignore-submodules --refresh &&
	git -C "$repo" diff-files --quiet --ignore-submodules &&
	git -C "$repo" diff-index --cached --quiet --ignore-submodules HEAD --
}

git.is.git-() {
	local repo=${1:-.}

	[[ -d $repo/.git ]] && git rev-parse --resolve-git-dir "$repo/.git" &>/dev/null
}

git.is.immutable-() {
	local repo=${1:-.}

	[[ $(git -C "$repo" config --type bool core.x-immutable 2>/dev/null || true) = true ]]
}

git.is.sane-() {
	local repo=${1:-.}

	git -C "$repo" rev-parse --is-inside-work-tree &>/dev/null || return 1
	git -C "$repo" rev-parse --verify HEAD >/dev/null          || return 1
}

git.is.sane-and-clean-() {
	git.is.sane- "$@" && git.is.clean- "$@"
}

# http.sh - HTTP functions

http.download() {
	local url=${1?${FUNCNAME[0]}: missing argument}; shift
	local dst=${1?${FUNCNAME[0]}: missing argument}; shift

	.getting 'Downloading file'
	.must -- http.get "$url" >"$dst"
}

http.get() {
	local url=${1?${FUNCNAME[0]}: missing argument}; shift

	[[ $url =~ ^[^:]+:// ]] || url=https://$url

	curl -fsSL "$url"
}

http.is() {
	local url=${1?${FUNCNAME[0]}: missing argument};  shift
	local code=${1?${FUNCNAME[0]}: missing argument}; shift

	local response
	response=$(curl -fsL -w '%{http_code}\n' -o /dev/null "$url" || true)

	if [[ ${code,,} = ok ]]; then
		code=200
	fi

	[[ $response = "$code" ]]
}

# os.sh - OS related functions

os.any() {
	local feature

	for feature; do
		if os.is "$feature"; then
			return 0
		fi
	done

	return 1
}

os.codename() {
	lsb_release -sc
}

os.dist() {
	# shellcheck disable=1091
	(unset ID && . /etc/os-release 2>/dev/null && echo "$ID")
}

os.is() {
	local feature=${1?${FUNCNAME[0]}: missing argument}; shift

	local func=os.is."${feature//\//+}"

	if .callable "$func"; then
		"$func"
	else
		local dist
		dist=$(os.dist)

		if [[ $dist = "$feature" ]]; then
			return 0
		fi

		local codename
		codename=$(os.codename)

		if [[ $codename = "$feature" ]]; then
			return 0
		fi

		return 1
	fi
}

os.is.proxmox() {
	.available pveversion && uname -a | grep -q -i pve
}

os.is.sid() {
	grep -qwE '(sid|unstable)' /etc/debian_version 2>/dev/null
}

os.is.debian+sid() {
	os.is.sid
}

os.is.debian+stable() {
	! os.is.debian+unstable
}

os.is.debian+unstable() {
	grep -qwE '(sid|unstable)' /etc/debian_version 2>/dev/null
}

os.is.debian+testing() {
	os.is.debian+unstable
}

# path.sh - Path management

path.base() {
	local -n path_base_=${1?${FUNCNAME[0]}: missing argument}; shift
	local    ext=${1:-}

	path_base_=${path_base_##*/}
}

path.dir() {
	local -n path_dir_=${1?${FUNCNAME[0]}: missing argument}; shift

	path.normalize path_dir_

	case $path_dir_ in
	*/*)
		path_dir_=${path_dir_%/*}
		[[ -n $path_dir_ ]] || path_dir_=/
		;;
	*)
		path_dir_=.
		;;
	esac
}

path.ext() {
	local -n path_ext_=${1?${FUNCNAME[0]}: missing argument}; shift

	path_ext_=${path_ext_##*/}

	case $path_ext_ in
	*.*)
		path_ext_=${path_ext_##*.}
		;;
	*)
		path_ext_=
		;;
	esac
}

path.is.equal() {
	local actual=${1?${FUNCNAME[0]}: missing argument};   shift
	local expected=${1?${FUNCNAME[0]}: missing argument}; shift

	[[ $(realpath -m "$actual") = $(realpath -m "$expected") ]]
}

path.is.inside() {
	local path=${1?${FUNCNAME[0]}: missing argument};      shift
	local periphery=${1?${FUNCNAME[0]}: missing argument}; shift

	local relative
	relative=$(realpath --relative-to "$path" "$periphery" 2>/dev/null) || return

	[[ ! $relative =~ ^[.] ]]
}

path.is.volatile() {
	local path=${1?${FUNCNAME[0]}: missing argument}; shift

	df -t tmpfs "$path" &>/dev/null
}

path.name() {
	local -n path_name_=${1?${FUNCNAME[0]}: missing argument}; shift
	local    ext=${1:-}

	path_name_=${path_name_##*/}
	path_name_=${path_name_%.*}
}


path.normalize() {
	local -n path_normalize_=${1?${FUNCNAME[0]}: missing argument}; shift

	while [[ $path_normalize_ =~ //+ ]]; do
		path_normalize_=${path_normalize_/\/\//\/}
	done
}

# shellcheck disable=2034
path.parse_() {
	local -n path_parse_=_

	if [[ ${1:-} = -A ]]; then
		shift
		path_parse_=${1?${FUNCNAME[0]}: missing argument}; shift
	fi

	local path=${1?${FUNCNAME[0]}: missing argument}; shift

	local dir=$path base=$path name=$path ext=$path

	path.dir dir
	path.base base
	path.name name
	path.ext ext

	path_parse_[.dir]=$dir
	path_parse_[.base]=$base
	path_parse_[.name]=$name
	path_parse_[.ext]=$ext

	if [[ -n $ext ]]; then
		path_parse_[.dotext]=.$ext
	else
		path_parse_[.dotext]=$ext
	fi
}

path.subext() {
	local -n path_subext_=${1?${FUNCNAME[0]}: missing argument}; shift
	local    ext=${1?${FUNCNAME[0]}: missing argument};          shift

	case $path_subext_ in
	*.*)
		path_subext_=${path_subext_%.*}
		path_subext_=${path_subext_}.${ext}
		;;
	*)
		;;
	esac
}

path.suffixize() {
	local -n path_suffixize_=${1?${FUNCNAME[0]}: missing argument}; shift
	local    suffix=${1?${FUNCNAME[0]}: missing argument};          shift

	local -A _
	path.parse_ "$path_suffixize_"

	printf -v path_suffixize_ "%s/%s${suffix}%s" "${_[.dir]:-.}" "${_[.name]}" "${_[.dotext]}"
}

# self.sh - Functions related to program itself

self.name() {
	# shellcheck disable=2128
	echo "$PROGNAME"
}

self.path() {
	local self

	self=${BASH_SOURCE[0]}
	case $self in
	./*) readlink -f "$self" ;;
	/*)  echo "$self" ;;
	*)   readlink -f "$(command -v "$self")" ;;
	esac
}

self.src() {
	local path

	path=$(self.path)
	if .interactive; then
		echo "$path"
	else
		echo "builtin source '$path'"
	fi
}

self.version() {
	echo "${VERSION:-}"
}

# string.sh - String manipulation

string.delete_prefix() {
	string.has_prefix_deleted "$@" || :
}

string.delete_suffix() {
	string.has_suffix_deleted "$@" || :
}

string.has_prefix_deleted() {
	local -n string_has_prefix_deleted_=${1?${FUNCNAME[0]}: missing argument}; shift
	local    prefix=${1?${FUNCNAME[0]}: missing argument};                     shift

	if [[ $string_has_prefix_deleted_ =~ ^$prefix ]]; then
		string_has_prefix_deleted_=${string_has_prefix_deleted_#$prefix}

		return 0
	fi

	return 1
}

string.has_suffix_deleted() {
	local -n string_has_suffix_deleted_=${1?${FUNCNAME[0]}: missing argument}; shift
	local    suffix=${1?${FUNCNAME[0]}: missing argument};                     shift

	if [[ $string_has_suffix_deleted_ =~ $suffix$ ]]; then
		string_has_suffix_deleted_=${string_has_suffix_deleted_%$suffix}

		return 0
	fi

	return 1
}

# temp.sh - Functions involving temporary directories or files

# Remove temp files or directories
temp.clean() {
	while [[ $# -gt 0 ]]; do
		local -n temp_clean_=$1; shift

		rm -rf -- "$temp_clean_"
	done
}

# Create a temp dir
temp.dir() {
	# shellcheck disable=2155
	local -n temp_dir_=${1?${FUNCNAME[0]}: missing argument}; shift

	local dir

	# shellcheck disable=2128
	dir=$(mktemp -p "${TMPDIR:-/tmp}" -d "$PROGNAME".XXXXXXXX) || .die 'Fatal error: mktemp'
	.clean "$dir"

	# shellcheck disable=2034
	temp_dir_=$dir
}

# Create a temp file
temp.file() {
	# shellcheck disable=2155
	local -n temp_file_=${1?${FUNCNAME[0]}: missing argument}; shift

	local file

	# shellcheck disable=2128
	file=$(mktemp -p "${TMPDIR:-/tmp}" "$PROGNAME".XXXXXXXX) || .die 'Fatal error: mktemp'
	.clean "$file"

	# shellcheck disable=2034
	temp_file_=$file
}

# Execute command in temp dir
temp.inside() {
	# shellcheck disable=2128
	local temp_inside_ orig_dir_=$PWD
	temp.dir temp_inside_

	.must -- cd "$temp_inside_"
	"$@"
	.must -- cd "$orig_dir_"

	rm -rf -- "$temp_inside_"
}

# text.sh - Text blob manipulations

text.fix() {
	local file=${1?${FUNCNAME[0]}: missing argument}; shift
	local mark=${1:-_}

	.must 'Input from stdin required' .piped
	.must "No such file: $file" [[ -f "$file" ]]

	text.unfix "$file" "$mark"

	{
		echo "# begin $mark"
		cat
		echo "# END $mark"
	} >>"$file"
}

text.unfix() {
	local file=${1?${FUNCNAME[0]}: missing argument}; shift
	local mark=${1:-_}

	.must "No such file: $file" [[ -f "$file" ]]

	grep -qE "#\s+(begin|end)\s+$mark" "$file" || return 0
	.must "No such file or file is not writable: $file" [[ -w "$file" ]]
	sed -i "/begin $mark/,/end $mark/d" "$file"
}

# ui.sh - UI functions

ui.out() {
	local name=${1:-default}
	shift || true

	local sign=${_sign[$name]}

	# shellcheck disable=2154
	local sign_color=${_sign_color[$name]} text_color=${_text_color[$name]} reset=${_color[reset]}

	echo -en "${sign_color}${sign}${reset} "
	.out "$@"
	echo -en "$reset "
}

# shellcheck disable=2154
ui.echo() {
	[[ $# -gt 0 ]] || return 0

	local message=$1

	local name=${FUNCNAME[1]#*.}

	local sign=${_sign[$name]}

	local sign_color=${_sign_color[$name]} text_color=${_text_color[$name]} reset=${_color[reset]}

	if [[ -n ${sign:-} ]]; then
		echo -e "${sign_color}${sign}${reset} ${text_color}${message}${reset}"
	else
		echo -e "${text_color}${message}${reset}"
	fi
}

# ui - Init

# shellcheck disable=2034,2154
ui.init_() {
	declare -Ag _sign _sign_color _text_color

	# Style

	_sign[ask]='?';     _sign_color[ask]=+yellow;    _text_color[ask]=high
	_sign[bug]='✖';     _sign_color[bug]=red;        _text_color[bug]=high
	_sign[cry]='!';     _sign_color[cry]=+yellow;    _text_color[cry]=medium
	_sign[die]='✗';     _sign_color[die]=+red;       _text_color[die]=high
	_sign[hmm]='ℹ';     _sign_color[hmm]=-yellow;    _text_color[hmm]=low
	_sign[say]='' ;     _sign_color[say]=+white;     _text_color[say]=medium

	_sign[notok]='✗';   _sign_color[notok]=+red;     _text_color[notok]=high
	_sign[ok]='✓';      _sign_color[ok]=+green;      _text_color[ok]=high

	_sign[calling]='>'; _sign_color[calling]=+cyan;  _text_color[calling]=high
	_sign[getting]='↓'; _sign_color[getting]=+cyan;  _text_color[getting]=low
	_sign[running]='∙'; _sign_color[running]=+cyan;  _text_color[running]=low
	_sign[default]='∙'; _sign_color[default]=+white; _text_color[default]=medium

	color.expand _sign_color _text_color

	.bug()     { ui.echo "$@" >&2; exit 127; }
	.bye()     { ui.echo "$@" >&2; exit 0;   }
	.calling() { ui.echo "$1" >&2; "${@:2}"; }
	.cry()     { ui.echo "$@" >&2;           }
	.die()     { ui.echo "$@" >&2; exit 1;   }
	.getting() { ui.echo "$1" >&2; "${@:2}"; }
	.hmm()     { ui.echo "$@" >&2;           }
	.notok()   { ui.echo "$@" >&2;           }
	.ok()      { ui.echo "$@" >&2;           }
	.running() { ui.echo "$1" >&2; "${@:2}"; }
	.say()     { ui.echo "$@" >&2;           }
}

ui.init_

# url.sh - URL processing

url.any() {
	local url=${1?${FUNCNAME[0]}: missing argument}; shift

	local class scheme
	url.parse "$url" class scheme

	local expected
	for expected; do
		case $expected in
		local)
			[[ 'file' != "${scheme:-}" ]] || return 0
			;;
		remote)
			[[ 'file' = "${scheme:-}" ]] || return 0
			;;
		dir)
			[[ -z ${class:-} ]] || return 0
			;;
		*)
			[[ $scheme != "${class:-}" ]] || return 0
			;;
		esac
	done

	return 1
}

url.is() {
	local url=${1?${FUNCNAME[0]}: missing argument};      shift
	local expected=${1?${FUNCNAME[0]}: missing argument}; shift

	url.any "$url" "$expected"
}

url.usl() {
	usl "${_url_usl_args[@]}" "$@"
}

url.parse() {
	local exp

	exp=$(url.usl "$@") || return 1

	eval -- "$exp"
}

url.template() {
	local name=${1?${FUNCNAME[0]}: missing argument};     shift
	local template=${1?${FUNCNAME[0]}: missing argument}; shift

	_url_usl_args+=(
		'-var' "$name = $template"
	)
}

# url - Init

url.init-() {
	declare -ag _url_usl_args=()
}

url.init-

# virt.sh - Virtualization functions

virt.any() {
	local virt

	for virt; do
		local func=virt.is."${virt}"

		if .callable "$func"; then
			"$func"
		else
			[[ $(virt.which) = "$virt" ]]
		fi || continue

		return 0
	done

	return 1
}

virt.is() {
	local virt=${1?${FUNCNAME[0]}: missing argument}; shift

	local func=virt.is."${virt}"

	if .callable "$func"; then
		"$func"
	else
		[[ $(virt.which) = "$virt" ]]
	fi
}

virt.which() {
	systemd-detect-virt || true
}

virt.is.any() {
	[[ -z ${CI:-} ]] || return 0
	[[ -z ${PACKER_BUILDER_TYPE:-} ]] || return 0

	systemd-detect-virt -q
}

virt.is.vagrant() {
	virt.is.any || return 1

	[[ -d /vagrant ]] || id -u vagrant 2>/dev/null
}

virt.is.physical() {
	! systemd-detect-virt -q
}

virt.is.physical() {
	! systemd-detect-virt -q
}

zip.unpack() {
	local in=${1?${FUNCNAME[0]}: missing argument}; shift
	local out=${1:-}

	local ext=${in##*.}
	.must "Extension required: $in" [[ -n "$ext" ]]

	local type
	case $in in
	*.tar.*) type=tar.$ext ;;
	*)       type=$ext     ;;
	esac

	[[ -n $out ]] || out=${in%.*}
	.must "Destination already exists: $out" [[ ! -e "$out" ]]

	local func=zip.unpack."$type"

	.must "Unsupported compressed file: $in" .callable "$func"

	"$func" "$in" "$out"
}

zip.unpack.bz2() {
	.must 'No program found: bzcat' .available bzcat && zip.prep_unzip_ "$@"

	local in=${1?${FUNCNAME[0]}: missing argument}; out=${2:-}

	local temp_file
	temp.file temp_file

	bzcat "$in" >"$temp_file" && mv "$temp_file" "$out"
}

zip.unpack.gz() {
	.must 'No program found: zcat' .available zcat && zip.prep_unzip_ "$@"

	local in=${1?${FUNCNAME[0]}: missing argument}; out=${2:-}

	zip.prep_unzip_ zcat

	local temp_file
	temp.file temp_file

	zcat "$in" >"$temp_file" && mv "$temp_file" "$out"
}

zip.unpack.tar.bz2() {
	.must 'No program found: bzip2' .available bzip2 && zip.prep_untar_ "$@"

	local in=${1?${FUNCNAME[0]}: missing argument}; out=${2:-}

	tar --strip-components=1 -jxf "$in" -C "$out"
}

zip.unpack.tar.gz() {
	zip.prep_untar_ "$@"

	local in=${1?${FUNCNAME[0]}: missing argument}; out=${2:-}

	tar --strip-components=1 -zxf "$in" -C "$out"
}

zip.unpack.tar.xz() {
	.must 'No program found: xz' .available xz && zip.prep_untar_ "$@"

	local in=${1?${FUNCNAME[0]}: missing argument}; out=${2:-}

	tar --strip-components=1 -Jxf "$in" -C "$out"
}

zip.unpack.tar.zst() {
	.must 'No program found: zstd' .available zstd && zip.prep_untar_ "$@"

	local in=${1?${FUNCNAME[0]}: missing argument}; out=${2:-}

	tar --strip-components=1 --zstd -xf "$in" -C "$out"
}

zip.unpack.xz() {
	.must 'No program found: unxz' .available unxz && zip.prep_unzip_ "$@"

	local in=${1?${FUNCNAME[0]}: missing argument}; out=${2:-}

	local temp_file
	temp.file temp_file

	unxz "$in" >"$temp_file" && mv "$temp_file" "$out"
}

zip.unpack.zip() {
	.must 'No program found: unzip' .available unzip && zip.prep_unzip_ "$@"

	local in=${1?${FUNCNAME[0]}: missing argument}; out=${2:-}

	unzip -q -d "$out" "$in"
}

zip.unpack.zst() {
	.must 'No program found: zstdcat' .available zstdcat && zip.prep_unzip_ "$@"

	local in=${1?${FUNCNAME[0]}: missing argument}; out=${2:-}

	local temp_file
	temp.file temp_file

	zstdcat -f "$in" >"$temp_file" && mv "$temp_file" "$out"
}

# Private functions

zip.prep_untar_() {
	local in=${1?${FUNCNAME[0]}: missing argument}; out=${2:-}

	[[ -n $out ]] || out=${in%.tar.*}

	if [[ -e $out ]]; then
		.die "Directory already exist: $out"
	fi

	.must -- mkdir -p "$out"
}

zip.prep_unzip_() {
	local in=${1?${FUNCNAME[0]}: missing argument}; out=${2:-}

	[[ -n $out ]] || out=${in%.*}

	if [[ -e $out ]]; then
		.die "File already exist: $out"
	fi
}

# src.sh - Source cache management

src.del() {
	local url=${1?${FUNCNAME[0]}: missing argument}; shift

	if [[ $# -gt 0 ]]; then
		# shellcheck disable=2178
		local -n _src_=$1
		shift
	else
		local -A _src_=()
	fi

	src.plan "$url" _src_ && src.rm-
}

src.enter() {
	local url=${1?${FUNCNAME[0]}: missing argument}; shift

	if [[ $# -gt 0 ]]; then
		# shellcheck disable=2178
		local -n _src_=$1
		shift
	else
		local -A _src_=()
	fi

	src.plan "$url" _src_ && src.apply-
	src.enter-
}

src.get() {
	local url=${1?${FUNCNAME[0]}: missing argument}; shift

	if [[ $# -gt 0 ]]; then
		# shellcheck disable=2178
		local -n _src_=$1
		shift
	else
		local -A _src_=()
	fi

	src.plan "$url" _src_ && src.apply-
}

# shellcheck disable=2034
src.plan() {
	local url=${1?${FUNCNAME[0]}: missing argument};           shift
	local -n _src_plan_=${1?${FUNCNAME[0]}: missing argument}; shift

	src.calculate- "$url" _src_plan_
}

src.purge() {
	if [[ $# -gt 0 ]]; then
		# shellcheck disable=2178
		local -n _src_=$1
		shift

		local caches=${_src_[cache]%/*} interims=${_src_[interim]%/*}
		rm -rf -- "$caches" "$interims"
	else
		[[ -z ${SRCTMP:-} ]] || rm -rf -- "$SRCTMP"/{src,tmp}
	fi
}

# Private functions

src.apply-() {
	src.prep-

	if [[ -e ${_src_[cache]} ]]; then
		src.ok- || src.renew-
	else
		src.new-
	fi
}

# shellcheck disable=2034,2154
src.calculate-() {
	local url=${1?${FUNCNAME[0]}: missing argument};       shift
	local -n _hash_=${1?${FUNCNAME[0]}: missing argument}; shift

	local prefix=${_hash_[-prefix]:-}
	if [[ -z $prefix ]]; then
		[[ -n ${SRCTMP:-} ]] || .die 'SRCTMP undefined'

		prefix=$SRCTMP
	fi

	local -A _result_
	url.parse -bash=_result_ "$url" || .die "Error parsing URL: $url"

	_result_[cache]=$prefix/src/${_result_[id]}
	_result_[interim]=$prefix/tmp/${_result_[id]}

	.merge _hash_ _result_
}

src.enter-() {
	[[ -d ${_src_[cache]} ]] || return 0
	.must -- cd "${_src_[cache]}"

	[[ -d ${_src_[inpath]} ]] || return 0
	.must -- cd "${_src_[inpath]}"
}

src.handler-() {
	local handler

	case ${_src_[class]:-} in
	"")                handler=none ;;
	git)               handler=git ;;
	zip|tar.gz|tar.xz) handler=zip ;;
	*)                 .die "Unsupported class: ${_src_[class]}"
	esac

	echo "$handler"
}

src.prep-() {
	local caches=${_src_[cache]%/*} interims=${_src_[interim]%/*}

	[[ -d $caches   ]] || .must -- mkdir -p "$caches"
	[[ -d $interims ]] || .must -- mkdir -p "$interims"
}

src.ln-() {
	local dst=${1?${FUNCNAME[0]}: missing argument}; shift

	src.rm- && cp -al "$dst" "${_src_[cache]}"
}

src.mv-() {
	[[ -e ${_src_[interim]} ]] || return 0

	src.rm- && mv "${_src_[interim]}" "${_src_[cache]}"
}

src.new-() {
	if [[ ${_src_[scheme]} = file ]]; then
		src.ln- "${_src_[source]}"
	else
		.clean "${_src_[interim]}"

		src.rm-

		local handler
		handler=$(src.handler-) || exit $?

		src."$handler".new-

		src.mv-
	fi

	touch "${_src_[cache]}"
}

src.ok-() {
	[[ -e ${_src_[cache]} ]] || return 1

	local ttl=${_src_[-ttl]:-}
	[[ -n $ttl ]] || ttl=${SRCTTL:-30}

	! .expired "$ttl" "${_src_[cache]}"
}

src.planned-() {
	[[ -n ${_src_[source]:-}  ]] || .bug "Unplanned cache"

	[[ -n ${_src_[cache]:-}   ]] || .bug "Unplanned cache: ${_src_[source]}"
	[[ -n ${_src_[interim]:-} ]] || .bug "Unplanned interim: ${_src_[source]}"
}

src.renew-() {
	if [[ ${_src_[scheme]} = file ]]; then
		src.ln- "${_src_[source]}"
	else
		.clean "${_src_[interim]}"

		local handler
		handler=$(src.handler-) || exit $?

		src."$handler".renew-
		src.mv-
	fi

	touch "${_src_[cache]}"
}

src.rm-() {
	rm -rf "${_src_[cache]}"
}

# Git

src.git.new-() {
	git.clone "${_src_[source]}" "${_src_[interim]}" "${_src_[ref]}"
}

src.git.renew-() {
	git.reset "${_src_[cache]}" && git.update "${_src_[cache]}"
}

# Zip

src.zip.new-() {
	src.none.new-

	local dst="${_src_[interim]}".unpack

	rm -rf -- "$dst" && zip.unpack "${_src_[interim]}" "$dst"
	rm -rf -- "${_src_[interim]}" && mv "$dst" "${_src_[interim]}"
}

src.zip.renew-() {
	src.zip.new-
}

# None

src.none.new-() {
	[[ ${_src_[scheme]} =~ ^http ]] || .bug "Unimplemented scheme: ${_src_[scheme]}"

	http.download "${_src_[source]}" "${_src_[interim]}"
}

src.none.renew-() {
	src.none.new-
}

# Commands

# cmd/bin - Commands to manage programs/scripts

# Install program to path
bin:install() {
	# shellcheck disable=2192
	local -A _=(
		[-prefix]="$_USR"/bin
		[-name]=

		[.help]='[-name=NAME] [-prefix=DIR] URL|FILE'
		[.argc]=1
	)

	flag.parse

	# shellcheck disable=2128
	local url=$1
	shift

	bin.install- "$url" "${_[-prefix]}" "${_[-name]:-}"
}

# Use program by installing to a volatile path
bin:use() {
	# shellcheck disable=2192
	local -A _=(
		[-prefix]="$_RUN"/bin
		[-name]=

		[.help]='[-name=NAME] [-prefix=DIR] URL|FILE'
		[.argc]=1
	)

	flag.parse

	# shellcheck disable=2128
	local url=$1
	shift

	bin.install- "$url" "${_[-prefix]}" "${_[-name]:-}"
}

# bin - Private functions

bin.install-() {
	local url="${1?${FUNCNAME[0]}: missing argument}";    shift
	local prefix="${1?${FUNCNAME[0]}: missing argument}"; shift
	local name=${1:-}

	local -A bin=([url]="$url" [root]="$_RUN" [expiry]=-1)

	src.get bin

	local -a bins=()
	filetype.runnables "${bin[cache]}" bins

	[[ ${#bins[@]} -gt 0 ]] || .die "No program found: $url"

	if [[ -n $name ]] && [[ ${#bins[@]} -gt 1 ]]; then
		.die "Ambiguous usage of name option: $name"
	fi

	local src
	for src in "${bins[@]}"; do
		[[ -z $name ]] || name=${src##*/}

		file.cp "$src" "$prefix"/"$name" 0755
	done

	src.del bin
}

# cmd/deb - Debian package management

# Add Debian repository
deb:add() {
	.must 'Root permissions required; use sudo.' [[ ${EUID:-} -eq 0 ]]

	# shellcheck disable=2192
	local -A _=(
		[repository]=$NIL
		[key]=
		[deb]=$NIL
		[src]=

		[.help]='repository=NAME deb=LINE [src=LINE] [key=URL]'
		[.argc]=0
	)

	flag.parse

	deb:add-
}

# Install Debian packages
deb:install() {
	.must 'Root permissions required; use sudo.' [[ ${EUID:-} -eq 0 ]]

	# shellcheck disable=2192
	local -A _=(
		[repository]=
		[key]=
		[deb]=
		[src]=

		[-missings]=false
		[-shiny]=false

		[.help]='[-missings=BOOL] [-shiny=BOOL] [repository=NAME deb=LINE [src=LINE] [key=URL]] PACKAGE...'
		[.argc]=1-
	)

	flag.parse

	deb:install- "$@"
}

# Print missing packages among given packages
deb:missings() {
	# shellcheck disable=2192
	local -A _=(
		[.help]='PACKAGE...'
	)

	flag.parse

	local -a missings
	deb.missings missings "$@"

	for package in "${missings[@]}"; do
		echo "$package"
	done
}

# Uninstall Debian packages
deb:uninstall() {
	# shellcheck disable=2192
	local -A _=(
		[.help]='PACKAGE...'
		[.argc]=1-
	)

	flag.parse

	deb.uninstall "$@"
}

# Update Debian package index
deb:update() {
	# shellcheck disable=2192
	local -A _=(
		[.help]=
		[.argc]=0
	)

	flag.parse

	deb.update
}

# Use given official Debian distributions
deb:using() {
	# shellcheck disable=2192
	local -A _=(
		[.help]='DIST...'
		[.argc]=1-
	)

	flag.parse

	deb:using- "$@"
}

# deb - Protected functions

deb:add-() {
	local repository=${_[repository]:-}

	[[ -n $repository ]] || .bug "Undefined repository."

	.must 'Root permissions required; use sudo.' [[ ${EUID:-} -eq 0 ]]

	[[ -z ${_[key]:-} ]] || deb.add_key "${_[key]}" || return 0

	echo "deb ${_[deb]}"  >/etc/apt/sources.list.d/"$repository".list
	[[ -z ${_[src]:-} ]] || echo "deb-src ${_[src]}" >>/etc/apt/sources.list.d/"$repository".list

	.getting 'Updating package index' apt-get update -y
}

deb:install-() {
	[[ $# -gt 0 ]] || return 0

	if [[ -n ${_[repository]:-} ]]; then
		deb.add_ repository="${_[repository]}" key="${_[key]:-}" deb="${_[deb]:-}" src="${_[src]:-}"
	else
		local arg

		for arg in key deb src; do
			[[ -z ${_[$arg]:-} ]] || .die "Repository required."
		done
	fi

	local -a packages=() urls=() non_urls=() opts=()

	local arg
	for arg; do
		local url=$arg

		if url.is "$url" web; then
			urls+=("$url")
		elif url.is "$url" non; then
			non_urls+=("$url")
		else
			.die "Unsupported URL: $url"
		fi
	done

	if flag.true -missings; then
		deb.missings packages "${non_urls[@]}"
	else
		packages=("${non_urls[@]}")
	fi

	if flag.true -shiny; then
		local target

		if os.is debian/stable; then
			target=$(os.codename)-backports
		elif os.is debian/unstable; then
			target=experimental
		fi

		if [[ -n ${target:-} ]]; then
			.hmm "Using $target"
			deb:using- "$target"

			opts+=(
				--target-release
				"$target"
			)
		fi
	fi

	deb.install "${opts[@]}" "${packages[@]}"
	deb.install_manual "${urls[@]}"
}

deb:using-() {
	local dist
	for dist; do
		case $dist in
		stable|testing|unstable|sid|experimental)
			;;
		*)
			deb.dist_valid "$dist" || .cry "Skipping invalid distribution: $dist"
			;;
		esac

		deb.dist_added "$dist" || deb:add- repository="$dist" deb="http://ftp.debian.org/debian $dist main contrib non-free"
	done
}

# cmd/deb - Init

deb:init_() {
	.available apt-get || .die 'Only Debian and derivatives supported.'

	export DEBIAN_FRONTEND=noninteractive APT_KEY_DONT_WARN_ON_DANGEROUS_USAGE=DontWarn
}

deb:init_

# cmd/file - File operations

# Change owner, group and mode
file:chmog() {
	# shellcheck disable=2192
	local -A _=(
		[.help]='[MODE]:[OWNER]:[GROUP] FILE|DIR'
		[.argc]=2
	)

	flag.parse

	local mog=$1 dst=$2

	file.chmog "$mog" "$dst"
}

# Run program
file:run() {
	# shellcheck disable=2192
	local -A _=(
		[.help]='FILE|DIR'
		[.argc]=1
	)

	flag.parse

	file:run_ "$@"
	# TODO
}

# cmd/filetype - Filetype detection

# Assert any file type
filetype:any() {
	local -A _=(
		[-zip]=false

		[.help]='FILE [TYPE...]'
		[.argc]=2-
	)

	flag.parse

	local file=$1; shift

	.must "No such file: $file" [[ -f "$file" ]]

	local type
	for type; do
		if filetype:is- "$type"; then
			return 0
		fi
	done

	return 1
}

# Assert file type
filetype:is() {
	local -A _=(
		[-zip]=false

		[.help]='FILE TYPE'
		[.argc]=2
	)

	flag.parse

	local file=$1; .must "No such file: $file" [[ -f "$file" ]]

	filetype:is- "$@"
}

# Print mime type
filetype:mime() {
	local -A _=(
		[-zip]=false

		[.help]='FILE'
		[.argc]=1
	)

	flag.parse

	local file=$1; .must "No such file: $file" [[ -f "$file" ]]

	if flag.true -zip; then
		file --mime-type --brief --uncompress-noreport "$file"
	else
		file --mime-type --brief "$file"
	fi
}

# filetype - Protected functions

filetype:is-() {
	local file=${1?${FUNCNAME[0]}: missing argument}; shift
	local type=${1?${FUNCNAME[0]}: missing argument}; shift

	local func=filetype:is:"${type}"_

	.must "Unable to know type: $type" .callable "$func"

	"$func" "$file" "$@"
}

filetype:shebang-() {
	local    file=${1?${FUNCNAME[0]}: missing argument}; shift
	local -n filetype_shebang_=${1?${FUNCNAME[0]}: missing argument}; shift

	filetype:is:interpretable- "$file" || return 1

	# shellcheck disable=2034
	local filetype_shebang_string

	filetype_shebang_string_=$(head -n 1 "$file" 2>/dev/null || true)
	filetype_shebang_string_=${filetype_shebang_string_#\#!}
	filetype_shebang_string_=${filetype_shebang_string_# }

	# shellcheck disable=2034,2206
	filetype_shebang_=($filetype_shebang_string_)
}

# cmd/filetype - Protected functions

filetype:is:compressed-() {
	local file=${1?${FUNCNAME[0]}: missing argument}; shift

	local mime; mime=$(file --mime-type --brief "$file")

	case $mime in
	application/gzip|application/zip|application/x-xz|application/x-bzip2|application/x-zstd)
		local zip=$mime; zip=${zip##*/}; zip=${zip##*-}

		if [[ $(file --mime-type --brief --uncompress-noreport "$file") = application/x-tar ]]; then
			_[.file.zip]=tar.$zip
		else
			_[.file.zip]=$zip
		fi

		return 0 ;;
	*)
		return 1 ;;
	esac
}

filetype:is:executable-() {
	local file=${1?${FUNCNAME[0]}: missing argument}; shift

	filetype:is:runnable- "$file" || return 1

	[[ ${_[.file.runnable]:-} = binary ]]
}

filetype:is:interpretable-() {
	local file=${1?${FUNCNAME[0]}: missing argument}; shift

	filetype:is:runnable- "$file" || return 1

	[[ ${_[.file.runnable]:-} = script ]]
}

filetype:is:mime-() {
	local file=${1?${FUNCNAME[0]}: missing argument};     shift
	local expected=${1?${FUNCNAME[0]}: missing argument}; shift

	local mime
	if flag.true -zip; then
		mime=$(file --mime-type --brief --uncompress-noreport "$file")
	else
		mime=$(file --mime-type --brief "$file")
	fi

	_[.file.mime]=$mime

	[[ $mime = "$expected" ]]
}

filetype:is:runnable-() {
	local file=${1?${FUNCNAME[0]}: missing argument}; shift

	local mime encoding

	IFS='; ' read -r mime encoding < <(file --mime --brief "$file")

	if [[ $encoding =~ binary$ ]]; then
		if [[ $mime  =~ -executable$ ]]; then
			_[.file.runnable]=binary
			return 0
		fi
	else
		if head -n 1 "$file" | grep -q '^#!' 2>/dev/null; then
			_[.file.runnable]=script
			return 0
		fi
	fi

	return 1
}

# cmd/git - Git commands

# Git pull if repository expired
git:update() {
	local -A _=(
		[-ttl]=3

		[.help]='[-ttl=MINUTES]'
		[.argc]=0
	)

	flag.parse

	if .expired "${_[-ttl]}" .git/FETCH_HEAD; then
		git.must.clean
		.getting 'Updating repository' git pull --quiet origin
	fi
}

# cmd/http - HTTP commands

# Assert HTTP response against any of the given codes
http:any() {
	local -A _=(
		[.help]='URL CODE...'
		[.argc]=2-
	)

	flag.parse

	local url=$1
	shift

	local response
	response=$(curl -fsL -w '%{http_code}\n' -o /dev/null "$url" || true)

	local code

	for code; do
		http:is- "$response" "$code"
	done
}

# Get URL
http:get() {
	local -A _=(
		[.help]='URL'
		[.argc]=1
	)

	flag.parse

	http.get "$1"
}

# Assert HTTP response against the given code
http:is() {
	local -A _=(
		[.help]='URL CODE'
		[.argc]=2
	)

	flag.parse

	local url=$1 code=$2

	local response
	response=$(curl -fsL -w '%{http_code}\n' -o /dev/null "$url" || true)

	http:is- "$response" "$code"
}

# cmd/http - Protected functions

http:is-() {
	local response=${1?${FUNCNAME[0]}: missing argument}; shift
	local code=${1?${FUNCNAME[0]}: missing argument};     shift

	if [[ ${code,,} = ok ]]; then
		code=200
	fi

	[[ $response = "$code" ]]
}

# cmd/os - OS related commands

# Assert any OS feature
os:any() {
	local -A _=(
		[.help]='FEATURE...'
		[.argc]=1-
	)

	flag.parse

	os.any "$@"
}

# Print distribution codename
os:codename() {
	local -A _; flag.parse

	os.codename "$@"
}

# Print distribution name
os:dist() {
	local -A _; flag.parse

	os.dist "$@"
}

# Assert OS feature
os:is() {
	local -A _=(
		[.help]='FEATURE'
		[.argc]=1
	)

	flag.parse

	os.is "$@"
}

# cmd/self - Commands related to theprogram itself

# Install self
self:install() {
	# shellcheck disable=2192,2128
	local -A _=(
		[-prefix]="$_USR"/bin
		[-name]=$PROGNAME

		[.help]=
		[.argc]=0
	)

	flag.parse

	_[1]=$(self.path)

	bin:install_
}

# Print self name
self:name() {
	local -A _; flag.parse

	self.name
}

# Print self path
self:path() {
	local -A _; flag.parse

	self.path
}

# Print self source
self:src() {
	local -A _; flag.parse

	self.src
}

# cmd/_ - Essential commands

# Return if program available
:available() {
	local -A _=(
		[.help]='PROGRAM'
		[.argc]=1
	)

	flag.parse

	.available "$@"
}

# Return if first argument found in remaining arguments
:contains() {
	local -A _=(
		[.help]='NEEDLE HAYSTACK'
		[.argc]=2-
	)

	flag.parse

	.contains "$@"
}

# Return if any of the files expired
:expired() {
	local -A _=(
		[-ttl]=3

		[.help]='[-ttl=MINUTES] FILE...'
		[.argc]=1-
	)

	flag.parse

	.expired "${_[-ttl]}" "$@"
}

# Ensure the given command succeeds
:must() {
	local -A _=(
		[.help]='MESSAGE ARGS...|-- ARGS...'
		[.argc]=2-
		[.dash]=true
	)

	flag.parse

	.must -- "$@"
}

# Ignore error if the given command fails
:should() {
	local -A _=(
		[.help]='MESSAGE ARGS...|-- ARGS...'
		[.argc]=2-
		[.dash]=true
	)

	flag.parse

	.should "$@"
}

# Run local file with optional environment
:run() {
	# shellcheck disable=2192
	local -A _=(
		[.help]='FILE|DIR [ARG]...'
		[.argc]=2-
	)

	flag.parse

	# shellcheck disable=2034
	local -a env=(); flag.env_ env

	file.rune env "$@"
}

# cmd/src - Source management

# Fetch and chdir to source
src:enter() {
	# shellcheck disable=2192
	local -A _=(
		[-ttl]=-1
		[-prefix]=$_RUN

		[.help]='[-(cache=MINUTES|cache=DIR)] URL'
		[.argc]=1
	)

	flag.parse

	local url=$1
	shift

	src.enter "$url" _
}

# Fetch and instal source into a known source tree
src:install() {
	# shellcheck disable=2192
	local -A _=(
		[-prefix]="$_USR"/local/src

		[.help]='[-prefix=DIR] URL|FILE'
		[.argc]=1
	)

	flag.parse

	# shellcheck disable=2128
	local url=$1
	shift

	local -A src=()

	src.get "$url" src

	[[ ${src[class]:-} = git ]] || .die "Not a git repository: $url"

	local path="${src[domain]}"/"${src[name]}"
	local dst="${_[-prefix]}"/"$path"

	[[ -d $dst ]] || .die "Already installed: $dst"

	file.cp "${src[cache]}" "$dst"
}

# Fetch source and run given command inside it
src:with() {
	# shellcheck disable=2192
	local -A _=(
		[-ttl]=-1
		[-prefix]=$_RUN

		[.help]='[-(ttl=MINUTES|cache=DIR)] URL COMMAND [ARG]...'
		[.argc]=2-
	)

	flag.parse

	# shellcheck disable=2128
	local url=$1 old_pwd=$PWD
	shift

	src.enter "$url" _
	"$@" "${_[cache]}"
	.must -- cd "$old_pwd"
}

# cmd/text - Text manipulation commands

# Append stdin content to the target file
text:fix() {
	local -A _=(
		[.help]='FILE [MARK]'
		[.argc]=1-
	)

	flag.parse

	text.fix "$@"
}

# Remove appended content
text:unfix() {
	local -A _=(
		[.help]='FILE [MARK]'
		[.argc]=1-
	)

	flag.parse

	text.unfix "$@"
}

# cmd/ui - UI commands

# Print bug message and exit failure
ui:bug() {
	local -A _=(
		[.help]='MESSAGE'
		[.argc]=1
	)

	flag.parse

	.bug "$@"
}

# Print message and exit success
ui:bye() {
	local -A _=(
		[.help]='MESSAGE'
		[.argc]=1
	)

	flag.parse

	.bye "$@"
}

# Print message and run command
ui:calling() {
	local -A _=(
		[.help]='MESSAGE'
		[.argc]=1-
	)

	flag.parse

	.calling "$@"
}

# Print warning message
ui:cry() {
	local -A _=(
		[.help]='MESSAGE'
		[.argc]=1
	)

	flag.parse

	.cry "$@"
}

# Print error message and exit failure
ui:die() {
	local -A _=(
		[.help]='MESSAGE'
		[.argc]=1
	)

	flag.parse

	.die "$@"
}

# Print message indicating a download and run command
ui:getting() {
	local -A _=(
		[.help]='MESSAGE'
		[.argc]=1-
	)

	flag.parse

	.getting "$@"
}

# Print info message
ui:hmm() {
	local -A _=(
		[.help]='MESSAGE'
		[.argc]=1
	)

	flag.parse

	.hmm "$@"
}

# Print not ok message
ui:notok() {
	local -A _=(
		[.help]='STRING'
		[.argc]=1
	)

	flag.parse

	.notok "$@"
}

# Print ok message
ui:ok() {
	local -A _=(
		[.help]='STRING'
		[.argc]=1
	)

	flag.parse

	.ok "$@"
}

# Print a busy message run command
ui:running() {
	local -A _=(
		[.help]='MESSAGE'
		[.argc]=1-
	)

	flag.parse

	.calling "$@"
}

# Print message on stderr
ui:say() {
	local -A _=(
		[.help]='MESSAGE'
		[.argc]=1
	)

	flag.parse

	.say "$@"
}

# cmd/url - URL processing commands

# Assert URL type
url:any() {
	local -A _=(
		[.help]='URL CLASS...'
		[.argc]=2-
	)

	flag.parse

	url.any "$@"
}

# Assert URL type
url:is() {
	local -A _=(
		[.help]='URL CLASS'
		[.argc]=2
	)

	flag.parse

	url.is "$@"
}

# Parse and dump URL
url:dump() {
	local -A _=(
		[.help]='URL ATTRIBUTE...'
		[.argc]=2-
	)

	flag.parse

	url.usl "$@"
}

init.url() {
	url.template cache "$_RUN/{{ .source | pathescape }}"
}

# cmd/version - Print version

declare -gr VERSION=0.0.0

# Return version
:version() {
	local -A _; flag.parse

	echo "${VERSION:-}"
}

# cmd/virt - Virtualization commands

# Assert any of the virtualization types
virt:any() {
	local -A _=(
		[.help]='VIRTUALIZATION...'
		[.argc]=1-
	)

	flag.parse

	virt.any "$@"
}

# Assert virtualization type
virt:is() {
	local -A _=(
		[.help]='VIRTUALIZATION'
		[.argc]=1
	)

	flag.parse

	virt.is "$@"
}

# Detect virtualization type
virt:which() {
	local -A _=(
		[.argc]=0
	)

	flag.parse

	virt.which
}

# cmd/zip - Compression/decompression commands

# Unpack compressed file
zip:unpack() {
	local -A _=(
		[-force]=false
		[-clean]=false

		[.help]='[-(force|clean)=BOOL] FILE [DIR]'
		[.argc]=1-
	)

	flag.parse

	local in=$1 out=${2:-};	.must "No such file: $in" [[ -f "$in" ]]

	if [[ -e $out ]]; then
		if flag.true -force; then
			rm -rf -- "$out"
		else
			.die "File already exist: $out"
		fi
	fi

	.must "Not a compressed file of known type: $in" filetype:is:compressed- "$in"

	local func=zip.unpack.${_[.file.zip]:-}

	.must "Unsupported compressed file: $in" .callable "$func"

	"$func" "$in" "$out"

	if flag.true -clean; then
		rm -f -- "$in"
	fi
}

if [[ "${BASH_SOURCE[0]}" = "$0" ]]; then
	declare -Ag _help=(
		[':available']='Return if program available'
		[':contains']='Return if first argument found in remaining arguments'
		[':expired']='Return if any of the files expired'
		[':must']='Ensure the given command succeeds'
		[':run']='Run local file with optional environment'
		[':should']='Ignore error if the given command fails'
		[':version']='Return version'
		['bin:install']='Install program to path'
		['bin:use']='Use program by installing to a volatile path'
		['deb:add']='Add Debian repository'
		['deb:install']='Install Debian packages'
		['deb:missings']='Print missing packages among given packages'
		['deb:uninstall']='Uninstall Debian packages'
		['deb:update']='Update Debian package index'
		['deb:using']='Use given official Debian distributions'
		['file:chmog']='Change owner, group and mode'
		['file:run']='Run program'
		['filetype:any']='Assert any file type'
		['filetype:is']='Assert file type'
		['filetype:mime']='Print mime type'
		['git:update']='Git pull if repository expired'
		['http:any']='Assert HTTP response against any of the given codes'
		['http:get']='Get URL'
		['http:is']='Assert HTTP response against the given code'
		['os:any']='Assert any OS feature'
		['os:codename']='Print distribution codename'
		['os:dist']='Print distribution name'
		['os:is']='Assert OS feature'
		['self:install']='Install self'
		['self:name']='Print self name'
		['self:path']='Print self path'
		['self:src']='Print self source'
		['src:enter']='Fetch and chdir to source'
		['src:install']='Fetch and instal source into a known source tree'
		['src:with']='Fetch source and run given command inside it'
		['text:fix']='Append stdin content to the target file'
		['text:unfix']='Remove appended content'
		['ui:bug']='Print bug message and exit failure'
		['ui:bye']='Print message and exit success'
		['ui:calling']='Print message and run command'
		['ui:cry']='Print warning message'
		['ui:die']='Print error message and exit failure'
		['ui:getting']='Print message indicating a download and run command'
		['ui:hmm']='Print info message'
		['ui:notok']='Print not ok message'
		['ui:ok']='Print ok message'
		['ui:running']='Print a busy message run command'
		['ui:say']='Print message on stderr'
		['url:any']='Assert URL type'
		['url:dump']='Parse and dump URL'
		['url:is']='Assert URL type'
		['virt:any']='Assert any of the virtualization types'
		['virt:is']='Assert virtualization type'
		['virt:which']='Detect virtualization type'
		['zip:unpack']='Unpack compressed file'
	)

	declare -Ag _command=(
		['available']=':available'
		['bin install']='bin:install'
		['bin use']='bin:use'
		['contains']=':contains'
		['deb add']='deb:add'
		['deb install']='deb:install'
		['deb missings']='deb:missings'
		['deb uninstall']='deb:uninstall'
		['deb update']='deb:update'
		['deb using']='deb:using'
		['expired']=':expired'
		['file chmog']='file:chmog'
		['file run']='file:run'
		['filetype any']='filetype:any'
		['filetype is']='filetype:is'
		['filetype mime']='filetype:mime'
		['git update']='git:update'
		['http any']='http:any'
		['http get']='http:get'
		['http is']='http:is'
		['must']=':must'
		['os any']='os:any'
		['os codename']='os:codename'
		['os dist']='os:dist'
		['os is']='os:is'
		['run']=':run'
		['self install']='self:install'
		['self name']='self:name'
		['self path']='self:path'
		['self src']='self:src'
		['should']=':should'
		['src enter']='src:enter'
		['src install']='src:install'
		['src with']='src:with'
		['text fix']='text:fix'
		['text unfix']='text:unfix'
		['ui bug']='ui:bug'
		['ui bye']='ui:bye'
		['ui calling']='ui:calling'
		['ui cry']='ui:cry'
		['ui die']='ui:die'
		['ui getting']='ui:getting'
		['ui hmm']='ui:hmm'
		['ui notok']='ui:notok'
		['ui ok']='ui:ok'
		['ui running']='ui:running'
		['ui say']='ui:say'
		['url any']='url:any'
		['url dump']='url:dump'
		['url is']='url:is'
		['version']=':version'
		['virt any']='virt:any'
		['virt is']='virt:is'
		['virt which']='virt:which'
		['zip unpack']='zip:unpack'
	)

	# main - Application

	.usage() {
		# shellcheck disable=2128
		.say "Usage: $PROGNAME COMMAND... [-FLAG=VALUE...] [ARGS]"
		.say ""
		.say "Commands:"

		local cmd

		# shellcheck disable=2154
		for cmd in "${!_command[@]}"; do
			local fun=${_command[$cmd]}

			printf "\\t%-24s  %s\n" "$cmd" "${_help[$fun]:-}"
		done | sort >&2
	}

	# shellcheck disable=2154
	.dispatch() {
		local orig="${*}"

		if [[ $# -eq 0 ]]; then
			.usage

			.die 'Command required'
		fi

		local help=

		if [[ $1 = help ]]; then
			help=true

			shift

			if [[ $# -eq 0 ]]; then
				.usage

				.die 'Help topic required'
			fi
		fi

		local -a args=("$@") try

		local cmd
		while [[ $# -gt 0 ]]; do
			try+=("$1")
			shift

			if [[ -n ${_command[${try[*]}]:-} ]]; then
				cmd=${try[*]}
				args=("$@")
			fi
		done

		[[ -n ${cmd:-} ]] || .die "No command found: $orig"

		local fun=${_command["$cmd"]}

		PROGNAME+=("$cmd")

		if [[ -n ${help:-} ]]; then
			.say "${_help[$fun]:-}" ""

			"$fun" -help
		else
			"$fun" "${args[@]}"
		fi
	}

	.redirect() {
		local -a args=("$@") try

		local cmd
		while [[ $# -gt 0 ]]; do
			try+=("$1")
			shift

			if [[ -n ${_command[${try[*]}]:-} ]]; then
				cmd=${try[*]}
				args=("$@")
			fi
		done

		[[ -n ${cmd:-} ]] || .die "No command found: $orig"

		local fun=${_command["$cmd"]}

		unset 'PROGNAME[${#PROGNAME[@]}-1]'
		PROGNAME+=("$cmd")

		"$fun" "${args[@]}"
	}

	main() {
		if ! .interactive && [[ $# -eq 0 ]]; then
			echo "_SELF=$(self.path)"
			echo
			sed 's/^\t\t\t\t//' <<'EOF'
				# shellcheck disable=2034,2128
				.prelude() {
					set -Eeuo pipefail; shopt -s nullglob; [[ -z ${TRACE:-} ]] || set -x; unset CDPATH; IFS=$' \t\n'

					export LC_ALL=C.UTF-8 LANG=C.UTF-8

					declare -ag PROGNAME=("${0##*/}") # Program name

					declare -Ag PWD; PWD[.]=$PWD      # Manage PWD
				}

				.prelude

				declare -gr _SELF=$_SELF

				._() {
					case ${1:-} in
					-root)
						[[ ${EUID:-} -eq 0 ]] || { echo >&2 'Root privileges required.'; exit 1; }
						shift
						;;
					esac

					_.die() {
						"$_SELF" die "$@"; exit $?
					}

					_.cry() {
						"$_SELF" cry "$@"
					}

					_.bye() {
						"$_SELF" bye "$@"; exit $?
					}

					_.bug() {
						"$_SELF" bug "$@"; exit $?
					}

					_.must() {
						"$_SELF" must "$@" || exit $?
					}

					_.enter() {
						local dir

						if dir=$("$_SELF" enter "$@") && [[ -n $dir ]]; then
							pushd "$dir" &>/dev/null || exit
						fi
					}

					_.leave() {
						popd &>/dev/null || exit
					}

					unset -f "${FUNCNAME[0]}"
				}

				_() {
					local cmd=$1

					case $cmd in
					die|cry|bye|bug|must|enter|leave) shift; _."$cmd" "$@" ;;
					*)                                       "$_SELF" "$@" ;;
					esac
				}

				._ "$@"
EOF
		else
			.runtime
			.callback init
			.dispatch "$@"
		fi
	}

	main "$@"
fi