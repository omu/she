#!/usr/bin/env bash

[ -n "${BASH_VERSION:-}"        ] || { echo >&2 'Bash required.';                     exit 1; }
[[ ${BASH_VERSINFO[0]:-} -ge 4 ]] || { echo >&2 'Bash version 4 or higher required.'; exit 1; }

# shellcheck disable=2034,2128
.prelude() {
	set -Eeuo pipefail; shopt -s nullglob; [[ -z ${TRACE:-} ]] || set -x; unset CDPATH; IFS=$' \t\n'

	export LC_ALL=C.UTF-8 LANG=C.UTF-8

	declare -ag PROGNAME=("${0##*/}") # Program name

	declare -Ag PWD; PWD[.]=$PWD      # Manage PWD
}

.prelude

.say() {
	echo -e "${@-""}"
}

.cry() {
	if [[ $# -gt 0 ]]; then
		echo -e >&2 "W: $*"
	else
		echo >&2 ""
	fi
}

.die() {
	if [[ $# -gt 0 ]]; then
		echo -e >&2 "E: $*"
	else
		echo >&2 ""
	fi

	exit 1
}

.bug() {
	if [[ $# -gt 0 ]]; then
		echo -e >&2 "BUG: $*"
	else
		echo >&2 ""
	fi

	exit 127
}

.contains() {
	: "${1?${FUNCNAME[0]}: missing argument}"

	local element

	for element in "${@:2}"; do
		if [[ $element = "$1" ]]; then
			return 0
		fi
	done

	return 1
}

.available() {
	command -v "${1?${FUNCNAME[0]}: missing argument}" &>/dev/null
}

.callable() {
	[[ $(type -t "${1?${FUNCNAME[0]}: missing argument}" || true) == function ]]
}

.load() {
	# shellcheck disable=2128
	local _load_old_=$PWD

	[[ -v _load_dirs_ ]] || declare -ag _load_dirs_=(
		"$(dirname "$(readlink -f "$0")")"
	)

	local _load_src_

	for _load_src_; do
		builtin cd "${_load_dirs_[-1]}" || .die "Chdir error: ${_load_dirs_[-1]}"

		local _load_src_found_

		for _load_src_found_ in "$_load_src_" "$_load_src_".sh; do
			if [[ -f $_load_src_found_ ]]; then
				_load_src_found_=$(readlink -f "$_load_src_found_")

				_load_dirs_+=("$(dirname "$_load_src_found_")")

				builtin source "$_load_src_found_"
			fi
		done

		unset _load_src_found_
	done

	unset _load_src_

	builtin cd "$_load_old_" || .die "Chdir error: $_load_old_"
	unset _load_old_
}

# _.sh - Required functions

.out() {
	local arg

	for arg; do
		echo -e "$arg"
	done

	if .piped; then
		cat
	fi
}

.err() {
	.out "$@" >&2
}

.bye() {
	.out "$@"

	exit 0
}

.net() {
	local message="${1?${FUNCNAME[0]}: missing argument}"; shift

	.say "$message..."
	"$@"
}

.dbg() {
	[[ $# -gt 0 ]] || return 0

	# shellcheck disable=2178,2155
	local -n dbg_=$1

	echo "${!dbg_}"

	local key
	for key in "${!dbg_[@]}"; do
		printf '  %-16s  %s\n' "${key}" "${dbg_[$key]}"
	done | sort

	echo
}

.piped() {
	[[ ! -t 0 ]]
}

.interactive() {
	[[   -t 1 ]]
}

.bool() {
	local value=${1:-}

	value=${value,,}

	case $value in
	true|t|1|on|yes|y)
		return 0
		;;
	false|f|0|off|no|n|"")
		return 1
		;;
	*)
		.bug "Invalid boolean: $value"
	esac
}

# Check the expirations of given files
.expired() {
	local -i expiry=${1?${FUNCNAME[0]}: missing argument}; shift

	[[ $expiry -gt 0 ]] || return 1

	local file
	for file; do
		if [[ -e $file ]] && [[ -z $(find "$file" -mmin +"$expiry" 2>/dev/null) ]]; then
			return 0
		fi
	done

	return 1
}

# Capture outputs to arrays and return exit code
# shellcheck disable=2034,2178
.capture() {
	local out err ret

	if [[ ${1?${FUNCNAME[0]}: missing argument} != '-' ]]; then
		local -n util_capture_out_=$1

		out=$(mktemp)
	fi
	shift

	if [[ ${1?${FUNCNAME[0]}: missing argument} != '-' ]]; then
		local -n util_capture_err_=$1

		err=$(mktemp)
	fi
	shift

	"$@" >"${out:-/dev/stdout}" 2>"${err:-/dev/stderr}" && ret=$? || ret=$?

	if [[ -n ${out:-} ]]; then
		mapfile -t util_capture_out_ <"$out" || true
		rm -f -- "$out"
	fi

	if [[ -n ${err:-} ]]; then
		mapfile -t util_capture_err_ <"$err" || true
		rm -f -- "$err"
	fi

	return $ret
}

# Initialize underscore system

.init() {
	# Default variable as a hash
	declare -gA _=()

	# shellcheck disable=2034

	# Core environment
	if [[ ${EUID:-} -eq 0 ]]; then
		readonly _RUN=${UNDERSCORE_VOLATILE_PREFIX:-/run/_}
		readonly _USR=${UNDERSCORE_PERSISTENT_PREFIX:-/usr/local}
		readonly _ETC=${UNDERSCORE_CONFIG_PATH:-/etc/_:"$_USR"/etc/_:"$_RUN"/etc}
	else
		XDG_RUNTIME_DIR=${XDG_RUNTIME_DIR:-/run/user/"$EUID"}
		XDG_CONFIG_HOME=${XDG_CONFIG_HOME:-"$HOME"/.config}
		XDG_CACHE_HOME=${XDG_CACHE_HOME:-"$HOME"/.cache}

		readonly _RUN=${UNDERSCORE_VOLATILE_PREFIX:-"$XDG_RUNTIME_DIR"/_}
		readonly _USR=${UNDERSCORE_PERSISTENT_PREFIX:-"$HOME"/.local}
		readonly _ETC=${UNDERSCORE_CONFIG_PATH:-/etc/_:/usr/local/etc/_:"$XDG_CONFIG_HOME"/_:"$_RUN"/etc}
	fi

	export PATH="$_RUN"/bin:"$PATH"

	unset -f "${FUNCNAME[0]}"
}

# flag.sh - Flag handling

shopt -s expand_aliases

# shellcheck disable=2142
alias flag.parse='flag.parse_ "$@"; local -a __a; flag.args_ __a; set -- "${__a[@]}"; unset -v __a'

# shellcheck disable=2034
declare -gr NIL="\0"

flag.usage_() {
	if [[ -n ${_[.help]:-} ]]; then
		# shellcheck disable=2128
		.say "Usage: ${PROGNAME[*]} ${_[.help]}"
	else
		# shellcheck disable=2128
		.say "Usage: ${PROGNAME[*]}"
	fi

	[[ $# -gt 0 ]] || return 0

	exit "$1"
}

# shellcheck disable=2034
flag.parse_() {
	if .contains -help "$@"; then
		flag.usage_ 0
	fi

	local -A flag_result_

	local -i argc=0
	while [[ $# -gt 0 ]]; do
		local key value

		if [[ $1 =~ ^-*[[:alpha:]_][[:alnum:]_]*= ]]; then
			key=${1%%=*}; value=${1#*=}
			if [[ $key =~ ^-.+$ ]] && [[ ! -v _[$key] ]]; then
				.die "Unrecognized flag: $key"
			fi
		elif [[ $1 == '--' ]]; then
			shift
			break
		else
			key=$((++argc)); value=$1
		fi

		flag_result_["$key"]=${value:-${_["$key"]:-}}

		shift
	done

	flag.load flag_result_

	flag._validate_ $argc
}

flag.load() {
	local -n _load_src_=${1?${FUNCNAME[0]}: missing argument}; shift

	local key
	for key in "${!_load_src_[@]}"; do
		# shellcheck disable=2034
		_[$key]=${_load_src_[$key]}
	done
}

flag.values() {
	local pattern=${1?${FUNCNAME[0]}: missing argument}; shift

	local -a keys

	mapfile -t keys < <(
		for key in "${!_[@]}"; do
			[[ $key =~ $pattern ]] || continue

			echo "$key"
		done | sort -u
	)

	local key

	if [[ $# -gt 0 ]]; then
		local -n _values_=$1

		for key in "${keys[@]}"; do
			_values_+=("${_[$key]}")
		done

		_values_=("${_values_[@]}")
	else
		for key in "${keys[@]}"; do
			echo "${_[$key]}"
		done
	fi
}

flag.args_() {
	flag.values '^[1-9][0-9]*$' "$@"
}

flag.env_() {
	flag.values '^[[:alpha:]_][[:alnum:]_]*$' "$@"
}

flag.true() {
	.bool "${_[$1]:-}"
}

flag.false() {
	! flag.true "$@"
}

flag.nil() {
	[[ ${_[$1]:-} = "$NIL" ]]
}

flag._nils_() {
	local -a required=()

	local key
	for key in "${!_[@]}"; do
		if flag.nil "$key"; then
			required+=("$key")
		fi
	done

	[[ ${#required[@]} -eq 0 ]] || .die "Missing values for: ${required[*]}"
}

flag._args_() {
	local n=${1?${FUNCNAME[0]}: missing argument}; shift

	local argc=${_[.argc]:-0}

	[[ $argc != '-' ]] || return 0

	local lo hi

	if [[ $argc =~ ^[0-9]+$ ]]; then
		lo=$argc; hi=$argc
	elif [[ $argc =~ ^[0-9]*-[0-9]*$ ]]; then
		IFS=- read -r lo hi <<<"$argc"
	else
		.bug "Incorrect range: $argc"
	fi

	if   [[ -n ${lo:-} ]] && [[ $n -lt $lo ]]; then
		.die 'Too few arguments' # FIXME
	elif [[ -n ${hi:-} ]] && [[ $n -gt $hi ]]; then
		.die 'Too many arguments'
	else
		return 0
	fi

	flag.usage_ 1
}

flag._validate_() {
	flag._args_ "$@"
	flag._nils_
}

# must.sh - Guard functions

# Test -e
must.e() {
	local arg=${1?${FUNCNAME[0]}: missing argument}; shift
	local message=${1:-"No such file or directory: $arg"}

	[[ -e $arg ]] || .die "$message"
}

# Test -f
must.f() {
	local arg=${1?${FUNCNAME[0]}: missing argument}; shift
	local message=${1:-"No such file: $arg"}

	[[ -f $arg ]] || .die "$message"
}

# Test -d
must.d() {
	local arg=${1?${FUNCNAME[0]}: missing argument}; shift
	local message=${1:-"No such directory: $arg"}

	[[ -d $arg ]] || .die "$message"
}

# Test -x
must.x() {
	local arg=${1?${FUNCNAME[0]}: missing argument}; shift
	local message=${1:-"Not executable: $arg"}

	[[ -x $arg ]] || .die "$message"
}

# Test -r
must.r() {
	local arg=${1?${FUNCNAME[0]}: missing argument}; shift
	local message=${1:-"No such file: $arg"}

	[[ -r $arg ]] || .die "$message"
}

# Test -w
must.w() {
	local arg=${1?${FUNCNAME[0]}: missing argument}; shift
	local message=${1:-"No such file: $arg"}

	[[ -w $arg ]] || .die "$message"
}

# Test -n
must.n() {
	local arg=${1?${FUNCNAME[0]}: missing argument}; shift
	local message=${1:-"Empty value: $arg"}

	[[ -n $arg ]] || .die "$message"
}

# Test -z
must.z() {
	local arg=${1?${FUNCNAME[0]}: missing argument}; shift
	local message=${1:-"Empty value: $arg"}

	[[ -z $arg ]] || .die "$message"
}

# Must be root
must.root() {
	[[ ${EUID:-} -eq 0 ]] || .die 'Root permissions required; please use sudo.'
}

# Command must success
must.success() {
	"$@" || .die "Command failed: $*"
}

# Command may fail but must proceed
must.proceed() {
	"$@" || .cry "Exit code $? is suppressed: $*"
}

# Condition must be true
must.true() {
	local message=${1?${FUNCNAME[0]}: missing argument}; shift

	"$@" || .die "$message"
}

# Condition must be false
must.false() {
	local message=${1?${FUNCNAME[0]}: missing argument}; shift

	"$@" && .die "$message"
}

# Program must exist
must.available() {
	local arg=${1?${FUNCNAME[0]}: missing argument}; shift
	local message=${1:-"No program found: $arg"}

	command -v "$arg" &>/dev/null || .die "$message"
}

# Function must exist
must.callable() {
	local arg=${1?${FUNCNAME[0]}: missing argument}; shift
	local message=${1:-"No function found: $arg"}

	.callable "$arg" || .die "$message"
}

# Stdin must exist
# shellcheck disable=2120
must.piped() {
	local message=${1:-'No stdin data found'}

	.piped || .die "$message"
}

# Stdout must exist
must.interactive() {
	local message=${1:-'No stdout found'}

	.interactive || .die "$message"
}

# color.sh - Colors

# shellcheck disable=2034
color._init() {
	declare -Ag _color=(
		# Basic colors with variants - prefix +: bold, prefix -: dim, suffix -: reverse

		[black]='\e[38;5;8m'          [+black]='\e[1m\e[38;5;8m'     [-black]='\e[38;5;0m'
		[black-]='\e[48;5;8m'         [+black-]='\e[1m\e[48;5;8m'    [-black-]='\e[48;5;0m'

		[blue]='\e[38;5;12m'          [+blue]='\e[1m\e[38;5;12m'     [-blue]='\e[38;5;4m'
		[blue-]='\e[48;5;12m'         [+blue-]='\e[1m\e[48;5;12m'    [-blue-]='\e[48;5;4m'

		[cyan]='\e[38;5;14m'          [+cyan]='\e[1m\e[38;5;14m'     [-cyan]='\e[38;5;6m'
		[cyan-]='\e[48;5;14m'         [+cyan-]='\e[1m\e[48;5;14m'    [-cyan-]='\e[48;5;6m'

		[green]='\e[38;5;10m'         [+green]='\e[1m\e[38;5;10m'    [-green]='\e[38;5;2m'
		[green-]='\e[48;5;10m'        [+green-]='\e[1m\e[48;5;10m'   [-green-]='\e[48;5;2m'

		[magenta]='\e[38;5;13m'       [+magenta]='\e[1m\e[38;5;13m'  [-magenta]='\e[38;5;5m'
		[magenta-]='\e[48;5;13m'      [+magenta-]='\e[1m\e[48;5;13m' [-magenta-]='\e[48;5;5m'

		[red]='\e[38;5;9m'            [+red]='\e[1m\e[38;5;9m'       [-red]='\e[38;5;1m'
		[red-]='\e[48;5;9m'           [+red-]='\e[1m\e[48;5;9m'      [-red-]='\e[48;5;1m'

		[white]='\e[38;5;15m'         [+white]='\e[1m\e[38;5;15m'    [-white]='\e[38;5;7m'
		[white-]='\e[48;5;15m'        [+white-]='\e[1m\e[48;5;15m'   [-white-]='\e[48;5;7m'

		[yellow]='\e[38;5;11m'        [+yellow]='\e[1m\e[38;5;11m'   [-yellow]='\e[38;5;3m'
		[yellow-]='\e[48;5;11m'       [+yellow-]='\e[1m\e[48;5;11m'  [-yellow-]='\e[48;5;3m'

		# Attributes

		[bold]='\e[1m'                [dark]='\e[2m'                 [underlined]='\e[4m'
		[blink]='\e[5m'               [reverse]='\e[7m'              [reset]='\e[0m'

		# Priority aliases
		[high]='\e[1m'                [medium]=''                    [low]='\e[2m'
	)
}

color.expand() {
	while [[ $# -gt 0 ]]; do
		local -n color_expand_=${1?missing argument}
		shift

		local key value
		for key in "${!color_expand_[@]}"; do
			value=${color_expand_[$key]}

			color_expand_[$key]=${_color[$value]}
		done
	done
}

color.setup() {
	while [[ $# -gt 0 ]]; do
		local key=${1%%=*}; value=${1#*=}

		if [[ -n ${_color[$value]:-} ]]; then
			_color[$key]=${_color[$value]}
		else
			_color[$key]=$value
		fi

		shift
	done
}

color.code() {
	local name="${1?${FUNCNAME[0]}: missing argument}"; shift
	local code="${_color[$color]:-}"

	[[ -n $code ]] || .bug "No such color: $name"

	echo -en "$code"
}

color.out() {
	local color="${1?${FUNCNAME[0]}: missing argument}"; shift

	local code reset
	code=$(color.code "$color")
	reset=$(color.code reset)

	echo -en "$code"
	.out
	echo -en "$reset"
}

color.echo() {
	local color="${1?${FUNCNAME[0]}: missing argument}"; shift

	local code reset
	code=$(color.code "$color")
	reset=$(color.code reset)

	echo -e "${code}${*}${reset}"
}

color._init

# ui.sh - UI functions

ui.caution()  { ui._echo "$@"; }
ui.failure()  { ui._echo "$@"; }
ui.headline() { ui._echo "$@"; }
ui.info()     { ui._echo "$@"; }
ui.network()  { ui._echo "$@"; }
ui.panic()    { ui._echo "$@"; }
ui.plain()    { ui._echo "$@"; }
ui.question() { ui._echo "$@"; }
ui.success()  { ui._echo "$@"; }
ui.warning()  { ui._echo "$@"; }

# Report bug and exit failure
ui.bug() {
	ui.panic "$@" >&2; exit 127
}

# Print messages on standard error
ui.say() {
	ui.plain "$@" >&2
}

# Print messages on standard error and exit success
ui.bye() {
	ui.plain "$@" >&2; exit 0
}

# Print warning messages on standard error
ui.cry() {
	ui.warning "$@" >&2
}

# Print error messages and exit failure
ui.die() {
	ui.failure "$@" >&2; exit 1
}

# Print messages taking attention
ui.hey() {
	ui.headline "$@" >&2
}

ui.net() {
	local message="${1?${FUNCNAME[0]}: missing argument}"; shift

	ui.network "$message"
	"$@"
}

ui.out() {
	local name=$1
	shift

	local sign=${_sign[$name]}

	# shellcheck disable=2154
	local sign_color=${_sign_color[$name]} text_color=${_text_color[$name]} reset=${_color[reset]}

	echo -en "${sign_color}${sign}${reset} "
	.out
	echo -en "$reset "
}

# Private functions

# shellcheck disable=2034,2154
ui._init() {
	declare -Ag _sign _sign_color _text_color

	# Style

	_sign[caution]='★';    _sign_color[caution]=+cyan;      _text_color[caution]=high
	_sign[failure]='✗';    _sign_color[failure]=+red;       _text_color[failure]=high
	_sign[headline]='>';   _sign_color[headline]=+cyan;     _text_color[headline]=high
	_sign[info]='ℹ';       _sign_color[info]=-yellow;       _text_color[info]=low
	_sign[network]='↓';    _sign_color[network]=+cyan;      _text_color[network]=low
	_sign[panic]='✖';      _sign_color[panic]=red;          _text_color[panic]=high
	_sign[plain]='∙';      _sign_color[plain]=+white;       _text_color[plain]=medium
	_sign[question]='?';   _sign_color[question]=+yellow;   _text_color[question]=high
	_sign[success]='✓';    _sign_color[success]=+green;     _text_color[success]=high
	_sign[warning]='!';    _sign_color[warning]=+yellow;    _text_color[warning]=medium

	color.expand _sign_color _text_color
}

# shellcheck disable=2034,2154
ui._echo() {
	local name=${FUNCNAME[1]#*.}

	local sign=${_sign[$name]}

	local sign_color=${_sign_color[$name]} text_color=${_text_color[$name]} reset=${_color[reset]}

	echo -e "${sign_color}${sign}${reset} ${text_color}$*${reset}"
}

ui._init

shopt -s expand_aliases

alias .bug=ui.bug
alias .bye=ui.bye
alias .cry=ui.cry
alias .die=ui.die
alias .hey=ui.hey
alias .net=ui.net

readonly _TAP_VERSION_=13

tap.startup() {
	# shellcheck disable=2192
	local -A _=(
		[.help]='[FILE]'
		[.argc]=1
	)

	flag.parse

	local file=$1

	echo "# Running tests in $file"
}

tap.shutdown() {
	# shellcheck disable=2192
	local -A _=(
		[total]=$NIL
		[success]=$NIL
		[failure]=$NIL
		[duration]=$NIL

		[.help]='total=NUM success=NUM failure=NUM duration=SECONDS'
	)

	flag.parse

	:
}

tap.version() {
	local -A _=(
		[.argc]=0
	)

	echo TAP version $_TAP_VERSION_
	echo
}

tap.plan() {
	# shellcheck disable=2192
	local -A _=(
		[failure]=$NIL
		[skip]=0
		[success]=$NIL
		[todo]=0
		[total]=$NIL

		[.help]='total=NUM success=NUM failure=NUM [todo=NUM] [skip=NUM]'
	)

	flag.parse

	echo "1..${_[total]}"
	echo
	echo "# ${_[success]} test(s) succeeded, ${_[failure]} test(s) failed, ${_[skip]} test(s) skipped."
	echo "# There are ${_[todo]} todo test(s) waiting to be done."
}

# Success
tap.success() {
	# shellcheck disable=2192
	local -A _=(
		[test]=$NIL
		[number]=

		[.help]='test=MSG [number=NUM]'
	)

	flag.parse

	echo -n 'ok     '
	ui.out success

	if [[ -n ${_[number]:-} ]]; then
		echo "${_[number]} - ${_[test]}"
	else
		echo "${_[test]}"
	fi | color.out +blue
}

# Failure
tap.failure() {
	# shellcheck disable=2192
	local -A _=(
		[test]=$NIL
		[number]=

		[.help]='test=MSG [number=NUM] [MSG...]'
		[.argc]=0-
	)

	flag.parse

	echo -n 'not ok '
	ui.out failure

	if [[ -n ${_[number]:-} ]]; then
		echo "${_[number]} - ${_[test]}"
	else
		echo "${_[test]}"
	fi | color.out +blue

	local message
	for message; do
		echo "$message"
	done | sed -u -e 's/^/# /'
}

# Skip
tap.skip() {
	# shellcheck disable=2192
	local -A _=(
		[test]=$NIL
		[number]=

		[.help]='test=MSG [number=NUM]'
	)

	flag.parse

	echo -n 'ok     '
	ui.out plain

	{
		if [[ -n ${_[number]:-} ]]; then
			echo -n "${_[number]} - ${_[test]}"
		else
			echo -n "${_[test]}"
		fi

		color.echo +yellow ' # SKIP'
	} | color.out +blue
}

tap.todo() {
	# shellcheck disable=2192
	local -A _=(
		[test]=$NIL
		[number]=

		[.help]='test=MSG [number=NUM]'
	)

	flag.parse

	echo -n 'not ok '
	ui.out failure

	{
		if [[ -n ${_[number]:-} ]]; then
			echo -n "${_[number]} - ${_[test]}"
		else
			echo -n "${_[test]}"
		fi

		color.echo +yellow ' # TODO'
	} | color.out +blue

	local message
	for message; do
		echo "$message"
	done | sed -u -e 's/^/# /'
}

tap.out() {
	sed 's:^:# out> :' | color.out +green
}

tap.err() {
	sed 's:^:# err> :' | color.out +red
}

tap.stack() {
	sed 's:^:# :' | color.out yellow
}

# self.sh - Functions related to program itself

# Print self
self() {
	local path

	path=$(self.path)
	if .interactive; then
		echo "$path"
	else
		echo "builtin source '$path'"
	fi
}

# Print self version
self.version() {
	local -A _; flag.parse

	echo 0.0
}

# Print self name
self.name() {
	local -A _; flag.parse

	# shellcheck disable=2128
	echo "$PROGNAME"
}

# Print self path
# shellcheck disable=2120
self.path() {
	local -A _; flag.parse

	local self

	self=${BASH_SOURCE[0]}
	case $self in
	./*) readlink -f "$self" ;;
	/*)  echo "$self" ;;
	*)   readlink -f "$(command -v "$self")" ;;
	esac
}

# Install self
self.install() {
	# shellcheck disable=2192,2128
	local -A _=(
		[-prefix]="$_USR"/bin
		[-name]=$PROGNAME

		[.help]=
		[.argc]=0
	)

	flag.parse

	_[1]=$(self.path)

	bin.install_
}

if [[ ${OVERSCORE_SOURCE:-} = true ]] || [[ "${BASH_SOURCE[0]}" = "$0" ]]; then
	declare -Ag _help=(
		['must.e']='Test -e'
		['must.f']='Test -f'
		['must.d']='Test -d'
		['must.x']='Test -x'
		['must.r']='Test -r'
		['must.w']='Test -w'
		['must.n']='Test -n'
		['must.z']='Test -z'
		['must.root']='Must be root'
		['must.success']='Command must success'
		['must.proceed']='Command may fail but must proceed'
		['must.true']='Condition must be true'
		['must.false']='Condition must be false'
		['must.available']='Program must exist'
		['must.callable']='Function must exist'
		['must.piped']='Stdin must exist'
		['must.interactive']='Stdout must exist'
		['ui.bug']='Report bug and exit failure'
		['ui.say']='Print messages on standard error'
		['ui.bye']='Print messages on standard error and exit success'
		['ui.cry']='Print warning messages on standard error'
		['ui.die']='Print error messages and exit failure'
		['ui.hey']='Print messages taking attention'
		['tap.success']='Success'
		['tap.failure']='Failure'
		['tap.skip']='Skip'
		['self']='Print self'
		['self.version']='Print self version'
		['self.name']='Print self name'
		['self.path']='Print self path'
		['self.install']='Install self'
		['app.dispatch']='shellcheck disable=2154'
		['defer.init']='shellcheck disable=2120'
		['temp.inside']='Execute command in temp dir'
		['assert.ok']='Assert command succeed'
		['assert.notok']='Assert command failed'
		['assert.is']='Assert actual value equals to the expected'
		['assert.isnt']='Assert got value not equals to the expected'
		['assert.like']='Assert got value matches with the expected'
		['assert.unlike']='Assert got value not matches with the expected'
		['assert.out']='Assert successful command outputs'
		['assert.err']='Assert failed command outputs'
		['assert.pass']='Just pass'
		['assert.fail']='Just fail'
		['t.go']='shellcheck disable=2034'
		['t']='shellcheck disable=2034'
	)

	declare -Ag _command=(
		['isnt']='test.isnt'
		['is']='test.is'
		['notok']='test.notok'
		['ok']='test.ok'
		['tap err']='tap.err'
		['tap failure']='tap.failure'
		['tap plan']='tap.plan'
		['tap skip']='tap.skip'
		['tap success']='tap.success'
		['tap todo']='tap.todo'
		['tap version']='tap.version'
	)

	# app.sh - Application handling

	app.usage() {
		local cmd

		# shellcheck disable=2128
		.say "$PROGNAME COMMAND... [-FLAG=VALUE...] [ARGS]"
		.say "Commands:"

		# shellcheck disable=2154
		for cmd in "${!_command[@]}"; do
			local fun=${_command[$cmd]}

			printf "\\t%-24s  %s\n" "$cmd" "${_help[$fun]}"
		done | sort >&2
	}

	# shellcheck disable=2154
	app.dispatch() {
		local orig="${*}"

		if [[ $# -eq 0 ]]; then
			app.usage

			.die 'Command required'
		fi

		local help=

		if [[ $1 = help ]]; then
			help=true

			shift

			if [[ $# -eq 0 ]]; then
				app.usage

				.die 'Help topic required'
			fi
		fi

		local -a args=("$@") try

		local cmd
		while [[ $# -gt 0 ]]; do
			try+=("$1")
			shift

			if [[ -n ${_command[${try[*]}]:-} ]]; then
				cmd=${try[*]}
				args=("$@")
			fi
		done

		[[ -n ${cmd:-} ]] || .die "No command found: $orig"

		local fun=${_command["$cmd"]}

		readonly PROGNAME+=("$cmd")

		if [[ -n ${help:-} ]]; then
			.say "${_help[$fun]}" ""

			"$fun" -help
		else
			"$fun" "${args[@]}"
		fi
	}

	.source() {
		echo "_SELF=$(self.path)"
		echo
		sed 's/^\t\t//' <<'EOF'
		#!/usr/bin/env bash

		[ -n "${BASH_VERSION:-}"        ] || { echo >&2 'Bash required.';                     exit 1; }
		[[ ${BASH_VERSINFO[0]:-} -ge 4 ]] || { echo >&2 'Bash version 4 or higher required.'; exit 1; }

		# shellcheck disable=2034,2128
		.prelude() {
			set -Eeuo pipefail; shopt -s nullglob; [[ -z ${TRACE:-} ]] || set -x; unset CDPATH; IFS=$' \t\n'

			export LC_ALL=C.UTF-8 LANG=C.UTF-8

			declare -ag PROGNAME=("${0##*/}") # Program name

			declare -Ag PWD; PWD[.]=$PWD      # Manage PWD
		}

		.prelude

		.say() {
			echo -e "${@-""}"
		}

		.cry() {
			if [[ $# -gt 0 ]]; then
				echo -e >&2 "W: $*"
			else
				echo >&2 ""
			fi
		}

		.die() {
			if [[ $# -gt 0 ]]; then
				echo -e >&2 "E: $*"
			else
				echo >&2 ""
			fi

			exit 1
		}

		.bug() {
			if [[ $# -gt 0 ]]; then
				echo -e >&2 "BUG: $*"
			else
				echo >&2 ""
			fi

			exit 127
		}

		.contains() {
			: "${1?${FUNCNAME[0]}: missing argument}"

			local element

			for element in "${@:2}"; do
				if [[ $element = "$1" ]]; then
					return 0
				fi
			done

			return 1
		}

		.available() {
			command -v "${1?${FUNCNAME[0]}: missing argument}" &>/dev/null
		}

		.callable() {
			[[ $(type -t "${1?${FUNCNAME[0]}: missing argument}" || true) == function ]]
		}

		.load() {
			# shellcheck disable=2128
			local _load_old_=$PWD

			[[ -v _load_dirs_ ]] || declare -ag _load_dirs_=(
				"$(dirname "$(readlink -f "$0")")"
			)

			local _load_src_

			for _load_src_; do
				builtin cd "${_load_dirs_[-1]}" || .die "Chdir error: ${_load_dirs_[-1]}"

				local _load_src_found_

				for _load_src_found_ in "$_load_src_" "$_load_src_".sh; do
					if [[ -f $_load_src_found_ ]]; then
						_load_src_found_=$(readlink -f "$_load_src_found_")

						_load_dirs_+=("$(dirname "$_load_src_found_")")

						builtin source "$_load_src_found_"
					fi
				done

				unset _load_src_found_
			done

			unset _load_src_

			builtin cd "$_load_old_" || .die "Chdir error: $_load_old_"
			unset _load_old_
		}

		# defer.sh - Deferred functions

		# shellcheck disable=2120
		defer.init() {
			if [[ -v _defer_initialized_ ]]; then
				return
			else
				_defer_initialized_=true

				declare -ag _defer_clean_=()

				if [[ -n $(builtin trap -p 2>/dev/null) ]]; then
					.cry 'Trap already taken.'

					return
				fi
			fi

			local -a signals=("$@")
			[[ $# -gt 0 ]] || signals=(EXIT HUP INT KILL QUIT TERM)

			local signal
			for signal in "${signals[@]}"; do
				# shellcheck disable=2064
				builtin trap "_defer_ $signal" "$signal"
			done

			# Prevent using trap
			trap() {
				.bug 'Using trap is forbidden; please use defer.* functions.'
			}

			# shellcheck disable=2139
			alias .untrap="trap - ${signals[*]}"

			# defer - Private functions

			_defer_() {
				local -r SIG=$1 ERR=$?

				local -a _defer_funcs_

				mapfile -t _defer_funcs_ < <(
					shopt -s extdebug

					declare -F | grep 'declare -f defer[.]' | awk '{ print $3 }' |
					while read -r func; do declare -F "$func"; done |
					sort -t' ' -k2 -n | awk '
						$1 !~ /defer[.]early|defer[.]late/ {
							print $1
						}
					'
				)

				! .callable defer.early || defer.early

				local func
				for func in "${_defer_funcs_[@]}"; do
					"$func" || [[ $SIG = INT ]] || [[ $SIG = QUIT ]] || .cry "Deferred function failed: $func"
				done

				if [[ -v _defer_clean_ ]] && [[ "${#_defer_clean_[@]}" -gt 0 ]]; then
					rm -rf -- "${_defer_clean_[@]}"
				fi

				! .callable defer.late || defer.late

				builtin trap - EXIT

				if [[ $SIG = INT ]] || [[ $SIG = QUIT ]]; then
					builtin trap - "$SIG"; kill -s "$SIG" "$$"
				fi

				return "$ERR"
			}

			readonly -f _defer_
		}

		# Register files/directories to clean up at exit
		.clean() {
			[[ -v _defer_initialized_ ]] || defer.init

			_defer_clean_+=("$@")
		}

		temp.dir() {
			# shellcheck disable=2155
			local -n temp_dir_=${1?${FUNCNAME[0]}: missing argument}; shift

			local dir

			# shellcheck disable=2128
			dir=$(mktemp -p "${TMPDIR:-/tmp}" -d "$PROGNAME".XXXXXXXX) || .die 'Fatal error: mktemp'
			.clean "$dir"

			# shellcheck disable=2034
			temp_dir_=$dir
		}

		temp.clean() {
			while [[ $# -gt 0 ]]; do
				local -n temp_clean_=$1; shift

				rm -rf -- "$temp_clean_"
			done
		}


		# assert.sh - Assert functions

		# Assert command succeed
		# shellcheck disable=2034
		assert.ok() {
			local -n assert_ok_=${1?${FUNCNAME[0]}: missing argument}; shift

			assert_ok_="Command expected to succeed but failed: $*"

			eval -- "$@"
		}

		# Assert command failed
		assert.notok() {
			local -n assert_notok_=${1?${FUNCNAME[0]}: missing argument}; shift

			assert_notok_="Command expected to fail but succeeded: $*"

			! eval -- "$@"
		}

		# Assert actual value equals to the expected
		assert.is() {
			local -n assert_is_=${1?${FUNCNAME[0]}: missing argument}; shift

			local got=${1?${FUNCNAME[0]}: missing argument};      shift
			local expected=${1?${FUNCNAME[0]}: missing argument}; shift

			assert_is_="Got '$got' where expected '$expected'"

			[[ $got = "$expected" ]]
		}

		# Assert got value not equals to the expected
		assert.isnt() {
			local -n assert_isnt_=${1?${FUNCNAME[0]}: missing argument}; shift

			local got=${1?${FUNCNAME[0]}: missing argument};      shift
			local expected=${1?${FUNCNAME[0]}: missing argument}; shift

			assert_isnt_=("Got unexpected '$got'")

			[[ $got != "$expected" ]]
		}

		# Assert got value matches with the expected
		assert.like() {
			local -n assert_like_=${1?${FUNCNAME[0]}: missing argument}; shift

			local got=${1?${FUNCNAME[0]}: missing argument};      shift
			local expected=${1?${FUNCNAME[0]}: missing argument}; shift

			assert_like_=("Got '$got' where expected to match with '$expected'")

			[[ $got =~ $expected ]]
		}

		# Assert got value not matches with the expected
		assert.unlike() {
			local -n assert_unlike_=${1?${FUNCNAME[0]}: missing argument}; shift

			local got=${1?${FUNCNAME[0]}: missing argument};      shift
			local expected=${1?${FUNCNAME[0]}: missing argument}; shift

			assert_unlike_=("Got '$got' where expected to unmatch with '$expected'")

			[[ ! $got =~ $expected ]]
		}

		# Assert successful command outputs
		assert.out() {
			local -n assert_out_=${1?${FUNCNAME[0]}: missing argument}; shift

			assert_out_=("$(
				hope -success=true "$@"
			)")
		}

		# Assert failed command outputs
		assert.err() {
			local -n assert_err_=${1?${FUNCNAME[0]}: missing argument}; shift

			assert_err_=("$(
				hope -success=false "$@"
			)")
		}

		# Just pass
		assert.pass() {
			true
		}

		# Just fail
		assert.fail() {
			false
		}

		declare -gr _SELF=$_SELF

		declare -Ag _test_=(
			[current]=0
			[start]=$SECONDS
		)

		.self() {
			"$_SELF" "$@"
		}

		.assert() {
			local assert=assert.${1?${FUNCNAME[0]}: missing argument}; shift

			local -a args

			while [[ $# -gt 0 ]]; do
				if [[ $1 = '--' ]]; then
					shift
					break
				fi

				args+=("$1")
				shift
			done

			_test_[current]=$((${_test_[current]:-0} + 1))

			local current=${_test_[current]} message

			if [[ ${1:-} =~ [sS][kK][iI][pP]\S* ]]; then
				shift; message="$*"

				.self tap skip test="$message" number="$current"
				_test_[skip]=$((${_test_[skip]:-0} + 1))
				_test_[success]=$((${_test_[success]:-0} + 1))
			elif [[ ${1:-} =~ [tT][oO][dD][oO]\S* ]]; then
				shift; message="$*"

				.self tap todo test="$message" number="$current"
				_test_[todo]=$((${_test_[todo]:-0} + 1))
				_test_[failure]=$((${_test_[failure]:-0} + 1))
			else
				message="$*"

				local -a err

				if "$assert" err "${args[@]}"; then
					.self tap success test="$message" number="$current"
					_test_[success]=$((${_test_[success]:-0} + 1))
				else
					.self tap failure test="$message" number="$current" "${err[@]}"
					_test_[failure]=$((${_test_[failure]:-0} + 1))
				fi
			fi
		}

		t.skip() {
			local message=${1?${FUNCNAME[0]}: missing argument}; shift

			_test_[current]=$((${_test_[current]:-0} + 1))

			local current=${_test_[current]}

			.self tap success test="$message" number="$current"
			_test_[success]=$((${_test_[success]:-0} + 1))
		}

		t.temp() {
			local tempdir

			if [[ -n ${PWD[tmp]:-} ]]; then
				tempdir=${PWD[tmp]}

				temp.clean tempdir
			fi

			temp.dir tempdir

			cd "$tempdir" || .die "Chdir error: $tempdir"

			# shellcheck disable=2128
			PWD[tmp]=$PWD
		}

		# shellcheck disable=2034
		t.go() {
			local -a _t_go_tests_

			mapfile -t _t_go_tests_ < <(
				shopt -s extdebug

				declare -F | grep 'declare -f test[.]' | awk '{ print $3 }' |
				while read -r t; do declare -F "$t"; done |
				sort -t' ' -k2 -n | awk '
					$1 !~ /test[.]setup|test[.]teardown|test[.]startup|test[.]shutdown/ {
						print $1
					}
				'
			)

			! .callable test.startup || test.startup

			local _t_go_
			for _t_go_ in "${_t_go_tests_[@]}"; do
				! .callable test.setup    || test.setup
				"$_t_go_"
				! .callable test.teardown || test.teardown
			done

			! .callable test.shutdown || test.shutdown

			.self tap plan	total="${_test_[current]:-}" \
					success="${_test_[success]:-}" \
					failure="${_test_[failure]:-0}" \
					todo="${_test_[todo]:-0}" \
					skip="${_test_[skip]:-0}"
		}

		# shellcheck disable=2034
		t() {
			local cmd

			[[ $# -gt 0 ]] || .die 'Test command required'

			cmd=$1
			shift

			[[ $cmd =~ ^[a-z][a-z0-9-]+$ ]] || .die "Invalid command name: $cmd"

			if .callable assert."$cmd"; then
				.assert "$cmd" "$@"
			elif .callable t."$cmd"; then
				t."$cmd"
			else
				.self "$@"
			fi
		}

		[[ $# -eq 0 ]] || .load "$@"
EOF
	}

	.main() {
		if ! .interactive && [[ $# -eq 0 ]]; then
			.source
		else
			app.dispatch "$@"
		fi
	}

	.main "$@"
fi