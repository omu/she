#!/usr/bin/env bash

[ -n "${BASH_VERSION:-}"        ] || { echo >&2 'Bash required.';                     exit 1; }
[[ ${BASH_VERSINFO[0]:-} -ge 4 ]] || { echo >&2 'Bash version 4 or higher required.'; exit 1; }

# Protected functions

.available() {
	command -v "${1?${FUNCNAME[0]}: missing argument}" &>/dev/null
}

.bug() {
	if [[ $# -gt 0 ]]; then
		echo -e >&2 "BUG: $*"
	else
		echo >&2 ""
	fi

	exit 127
}

.bye() {
	if [[ $# -gt 0 ]]; then
		echo -e >&2 "$*"
	else
		echo >&2 ""
	fi

	exit 0
}

.callable() {
	[[ $(type -t "${1?${FUNCNAME[0]}: missing argument}" || true) == function ]]
}

.contains() {
	: "${1?${FUNCNAME[0]}: missing argument}"

	local element

	for element in "${@:2}"; do
		if [[ $element = "$1" ]]; then
			return 0
		fi
	done

	return 1
}

.cry() {
	if [[ $# -gt 0 ]]; then
		echo -e >&2 "W: $*"
	else
		echo >&2 ""
	fi
}

.die() {
	if [[ $# -gt 0 ]]; then
		echo -e >&2 "E: $*"
	else
		echo >&2 ""
	fi

	exit 1
}

.err() {
	.out "$@" >&2
}

.expired() {
	local -i expiry=${1?${FUNCNAME[0]}: missing argument}; shift

	case $expiry in
	-1) return 1 ;;
	0)  return 0 ;;
	esac

	local file
	for file; do
		if [[ -e $file ]] && [[ -z $(find "$file" -mmin +"$expiry" 2>/dev/null) ]]; then
			return 1
		fi
	done

	return 0
}

.interactive() {
	[[   -t 1 ]]
}

.out() {
	local arg

	for arg; do
		echo -e "$arg"
	done

	if .piped; then
		cat
	fi
}

.piped() {
	[[ ! -t 0 ]]
}

.load() {
	# shellcheck disable=2128
	local _load_old_=$PWD

	[[ -v _load_dirs_ ]] || declare -ag _load_dirs_=(
		"$(dirname "$(readlink -f "$0")")"
	)

	local _load_src_

	for _load_src_; do
		builtin cd "${_load_dirs_[-1]}" || .die "Chdir error: ${_load_dirs_[-1]}"

		local _load_src_found_

		for _load_src_found_ in "$_load_src_" "$_load_src_".sh; do
			if [[ -f $_load_src_found_ ]]; then
				_load_src_found_=$(readlink -f "$_load_src_found_")

				_load_dirs_+=("$(dirname "$_load_src_found_")")

				builtin source "$_load_src_found_"
			fi
		done

		unset _load_src_found_
	done

	unset _load_src_

	builtin cd "$_load_old_" || .die "Chdir error: $_load_old_"
	unset _load_old_
}

.merge() {
	local -n lhs=${1?${FUNCNAME[0]}: missing argument}; shift
	local -n rhs=${1?${FUNCNAME[0]}: missing argument}; shift

	local key
	for key in "${!rhs[@]}"; do
		# shellcheck disable=2034
		lhs[$key]=${rhs[$key]}
	done
}

.must() {
	if [[ ${1:-} = -- ]]; then
		shift

		eval -- "${@?${FUNCNAME[0]}: missing argument}" || .die "Command failed: $*"
	else
		eval -- "${@:2}" || .die "${1?${FUNCNAME[0]}: missing argument}"
	fi
}

.say() {
	echo -e "${@-""}"
}

.should() {
	if [[ ${1:-} = -- ]]; then
		shift

		eval -- "${@?${FUNCNAME[0]}: missing argument}" || .cry "Exit code $? is suppressed: $*"
	else
		eval -- "${@:2}" || .cry "${1?${FUNCNAME[0]}: missing argument}"
	fi
}

# Init

# shellcheck disable=2034,2128
.prelude() {
	set -Eeuo pipefail; shopt -s nullglob; [[ -z ${TRACE:-} ]] || set -x; unset CDPATH; IFS=$' \t\n'

	export LC_ALL=C.UTF-8 LANG=C.UTF-8

	# Program name
	declare -gr PROGNAME=${0##*/}

	# Command names
	declare -g CMDNAMES=()
}

.prelude

# _.sh - Underscore spesific functions

# Core environment
.runtime() {
	# Default variable as a hash
	declare -gA _=()

	# Recycle PWD as a hash
	declare -Ag PWD

	# shellcheck disable=2128
	PWD[.]="$PWD"

	# shellcheck disable=2034
	if [[ ${EUID:-} -eq 0 ]]; then
		readonly _RUN=${UNDERSCORE_VOLATILE_PREFIX:-/run/_}
		readonly _USR=${UNDERSCORE_PERSISTENT_PREFIX:-/usr/local}
		readonly _ETC=${UNDERSCORE_CONFIG_PATH:-/etc/_:"$_USR"/etc/_:"$_RUN"/etc}
	else
		XDG_RUNTIME_DIR=${XDG_RUNTIME_DIR:-/run/user/"$EUID"}
		XDG_CONFIG_HOME=${XDG_CONFIG_HOME:-"$HOME"/.config}
		XDG_CACHE_HOME=${XDG_CACHE_HOME:-"$HOME"/.cache}

		readonly _RUN=${UNDERSCORE_VOLATILE_PREFIX:-"$XDG_RUNTIME_DIR"/_}
		readonly _USR=${UNDERSCORE_PERSISTENT_PREFIX:-"$HOME"/.local}
		readonly _ETC=${UNDERSCORE_CONFIG_PATH:-/etc/_:/usr/local/etc/_:"$XDG_CONFIG_HOME"/_:"$_RUN"/etc}
	fi

	export PATH="$_RUN"/bin:"$PATH" SRCTMP="$_RUN"
}

# assert.sh - Assertions

assert.err() {
	local -n assert_err_=${1?${FUNCNAME[0]}: missing argument}; shift

	# shellcheck disable=2034
	assert_err_=("$(
		hope -success=false "$@"
	)")
}

assert.fail() {
	false
}

assert.is() {
	local -n assert_is_=${1?${FUNCNAME[0]}: missing argument}; shift

	local got=${1?${FUNCNAME[0]}: missing argument};      shift
	local expected=${1?${FUNCNAME[0]}: missing argument}; shift

	# shellcheck disable=2034
	assert_is_="Got '$got' where expected '$expected'"

	[[ $got = "$expected" ]]
}

assert.isnt() {
	local -n assert_isnt_=${1?${FUNCNAME[0]}: missing argument}; shift

	local got=${1?${FUNCNAME[0]}: missing argument};      shift
	local expected=${1?${FUNCNAME[0]}: missing argument}; shift

	# shellcheck disable=2034
	assert_isnt_=("Got unexpected '$got'")

	[[ $got != "$expected" ]]
}

assert.like() {
	local -n assert_like_=${1?${FUNCNAME[0]}: missing argument}; shift

	local got=${1?${FUNCNAME[0]}: missing argument};      shift
	local expected=${1?${FUNCNAME[0]}: missing argument}; shift

	# shellcheck disable=2034
	assert_like_=("Got '$got' where expected to match with '$expected'")

	[[ $got =~ $expected ]]
}

assert.notok() {
	local -n assert_notok_=${1?${FUNCNAME[0]}: missing argument}; shift

	# shellcheck disable=2034
	assert_notok_="Command expected to fail but succeeded: $*"

	! eval -- "$@"
}

# shellcheck disable=2034
assert.ok() {
	local -n assert_ok_=${1?${FUNCNAME[0]}: missing argument}; shift

	assert_ok_="Command expected to succeed but failed: $*"

	eval -- "$@"
}

assert.out() {
	local -n assert_out_=${1?${FUNCNAME[0]}: missing argument}; shift

	# shellcheck disable=2034
	assert_out_=("$(
		hope -success=true "$@"
	)")
}

assert.pass() {
	true
}

assert.unlike() {
	local -n assert_unlike_=${1?${FUNCNAME[0]}: missing argument}; shift

	local got=${1?${FUNCNAME[0]}: missing argument};      shift
	local expected=${1?${FUNCNAME[0]}: missing argument}; shift

	# shellcheck disable=2034
	assert_unlike_=("Got '$got' where expected to unmatch with '$expected'")

	[[ ! $got =~ $expected ]]
}


# color.sh - Colors

color.code() {
	local name="${1?${FUNCNAME[0]}: missing argument}"; shift
	local code="${_color[$name]:-}"

	[[ -n $code ]] || .bug "No such color: $name"

	echo -en "$code"
}

color.echo() {
	local color="${1?${FUNCNAME[0]}: missing argument}"; shift

	local code reset
	code=$(color.code "$color")
	reset=$(color.code reset)

	echo -e "${code}${*}${reset}"
}

color.expand() {
	while [[ $# -gt 0 ]]; do
		local -n color_expand_=${1?missing argument}
		shift

		local key value
		for key in "${!color_expand_[@]}"; do
			value=${color_expand_[$key]}

			color_expand_[$key]=${_color[$value]}
		done
	done
}

color.out() {
	local color="${1?${FUNCNAME[0]}: missing argument}"; shift

	local code reset

	code=$(color.code "$color")
	reset=$(color.code reset)

	echo -en "$code"
	.out
	echo -en "$reset"
}

color.setup() {
	while [[ $# -gt 0 ]]; do
		local key=${1%%=*}; value=${1#*=}

		if [[ -n ${_color[$value]:-} ]]; then
			_color[$key]=${_color[$value]}
		else
			_color[$key]=$value
		fi

		shift
	done
}

# color - Init

# shellcheck disable=2034
color.init-() {
	declare -Ag _color=(
		# Basic colors with variants - prefix +: bold, prefix -: dim, suffix -: reverse

		[black]='\e[38;5;8m'          [+black]='\e[1m\e[38;5;8m'     [-black]='\e[38;5;0m'
		[black-]='\e[48;5;8m'         [+black-]='\e[1m\e[48;5;8m'    [-black-]='\e[48;5;0m'

		[blue]='\e[38;5;12m'          [+blue]='\e[1m\e[38;5;12m'     [-blue]='\e[38;5;4m'
		[blue-]='\e[48;5;12m'         [+blue-]='\e[1m\e[48;5;12m'    [-blue-]='\e[48;5;4m'

		[cyan]='\e[38;5;14m'          [+cyan]='\e[1m\e[38;5;14m'     [-cyan]='\e[38;5;6m'
		[cyan-]='\e[48;5;14m'         [+cyan-]='\e[1m\e[48;5;14m'    [-cyan-]='\e[48;5;6m'

		[green]='\e[38;5;10m'         [+green]='\e[1m\e[38;5;10m'    [-green]='\e[38;5;2m'
		[green-]='\e[48;5;10m'        [+green-]='\e[1m\e[48;5;10m'   [-green-]='\e[48;5;2m'

		[magenta]='\e[38;5;13m'       [+magenta]='\e[1m\e[38;5;13m'  [-magenta]='\e[38;5;5m'
		[magenta-]='\e[48;5;13m'      [+magenta-]='\e[1m\e[48;5;13m' [-magenta-]='\e[48;5;5m'

		[red]='\e[38;5;9m'            [+red]='\e[1m\e[38;5;9m'       [-red]='\e[38;5;1m'
		[red-]='\e[48;5;9m'           [+red-]='\e[1m\e[48;5;9m'      [-red-]='\e[48;5;1m'

		[white]='\e[38;5;15m'         [+white]='\e[1m\e[38;5;15m'    [-white]='\e[38;5;7m'
		[white-]='\e[48;5;15m'        [+white-]='\e[1m\e[48;5;15m'   [-white-]='\e[48;5;7m'

		[yellow]='\e[38;5;11m'        [+yellow]='\e[1m\e[38;5;11m'   [-yellow]='\e[38;5;3m'
		[yellow-]='\e[48;5;11m'       [+yellow-]='\e[1m\e[48;5;11m'  [-yellow-]='\e[48;5;3m'

		# Attributes

		[bold]='\e[1m'                [dark]='\e[2m'                 [underlined]='\e[4m'
		[blink]='\e[5m'               [reverse]='\e[7m'              [reset]='\e[0m'

		# Priority aliases
		[high]='\e[1m'                [medium]=''                    [low]='\e[2m'
	)
}

color.init-

# callback.sh - Handle callback functions

.callback() {
	local group=${1?${FUNCNAME[0]}: missing argument}; shift

	local -a _callback_funcs_

	mapfile -t _callback_funcs_ < <(
		shopt -s extdebug

		declare -F | awk '/^declare -f '"$group"'[.]/ { print $3 }' |
		while read -r func; do declare -F "$func"; done |
		sort -t' ' -k2 -n | cut -f1 -d' '
	)

	local func

	local -a _callback_early_ _callback_now_ _callback_late_

	for func in "${_callback_funcs_[@]}"; do
		case $func in
		*_early|*.early_|*.early) _callback_early_+=("$func") ;;
		*_late|*.late_|*.late)    _callback_late_+=("$func")  ;;
		*)                        _callback_now_+=("$func")   ;;
		esac
	done

	local failer=$group.fail
	.callable "$failer" || failer=.callback-fail-default-

	local -i err=0

	for func in "${_callback_early_[@]}"; do
		"$func" "$@" || { "$failer" "$func" "$@"; err+=1; }
	done

	for func in "${_callback_now_[@]}"; do
		"$func" "$@" || { "$failer" "$@"; err+=1; }
	done

	for func in "${_callback_late_[@]}"; do
		"$func" "$@" ||  { "$failer" "$@"; err+=1; }
	done

	return $err
}

# Private functions

.callback-fail-default-() {
	local func=${1?${FUNCNAME[0]}: missing argument}; shift

	case ${SIGNAL:-} in
	INT|QUIT) return 0 ;;
	esac

	.cry "Callback failed: $func"
}

# defer.sh - Deferred functions

# Register files/directories to clean up at exit
.clean() {
	[[ -v _defer_initialized_ ]] || .defer

	_defer_clean_+=("$@")
}

# Trap defer setup
# shellcheck disable=2120
.defer() {
	if [[ -v _defer_initialized_ ]]; then
		return
	else
		_defer_initialized_=true

		declare -ag _defer_clean_=()

		if [[ -n $(builtin trap -p 2>/dev/null) ]]; then
			.cry 'Trap already taken.'

			return
		fi
	fi

	local -a signals=("$@")
	[[ $# -gt 0 ]] || signals=(EXIT HUP INT KILL QUIT TERM)

	local signal
	for signal in "${signals[@]}"; do
		# shellcheck disable=2064
		builtin trap "_defer_ $signal" "$signal"
	done

	# Prevent using trap
	trap() {
		.bug 'Using trap is forbidden; please use defer.* functions.'
	}

	# shellcheck disable=2139
	alias .untrap="trap - ${signals[*]}"

	_defer_() {
		local -r SIGNAL=$1 ERR=$?

		.callback defer

		if [[ -v _defer_clean_ ]] && [[ "${#_defer_clean_[@]}" -gt 0 ]]; then
			rm -rf -- "${_defer_clean_[@]}"
		fi

		builtin trap - EXIT

		if [[ $SIGNAL = INT ]] || [[ $SIGNAL = QUIT ]]; then
			builtin trap - "$SIGNAL"; kill -s "$SIGNAL" "$$"
		fi

		return "$ERR"
	}

	readonly -f _defer_
}

# flag.sh - Flag handling

flag.args() {
	local -a keys

	mapfile -t keys < <(
		for key in "${!_[@]}"; do
			[[ $key =~ ^[1-9][0-9]*$ ]] || continue

			echo "$key"
		done | sort -u
	)

	local key

	if [[ $# -gt 0 ]]; then
		local -n _values_=$1

		for key in "${keys[@]}"; do
			_values_+=("${_[$key]}")
		done

		_values_=("${_values_[@]}")
	else
		for key in "${keys[@]}"; do
			echo "${_[$key]}"
		done
	fi
}

flag.env() {
	local -a keys

	mapfile -t keys < <(
		for key in "${!_[@]}"; do
			[[ $key =~ ^[[:alpha:]_][[:alnum:]_]*$ ]] || continue

			echo "$key"
		done | sort -u
	)

	local key

	if [[ $# -gt 0 ]]; then
		# shellcheck disable=2178
		local -n _values_=$1

		for key in "${keys[@]}"; do
			_values_+=("$key='${_[$key]}'")
		done
	else
		for key in "${keys[@]}"; do
			echo "$key='${_[$key]}'"
		done
	fi
}

flag.false() {
	! flag.true "$@"
}

flag.load() {
	local -n _load_src_=${1?${FUNCNAME[0]}: missing argument}; shift

	local key
	for key in "${!_load_src_[@]}"; do
		# shellcheck disable=2034
		_[$key]=${_load_src_[$key]}
	done
}

flag.nil() {
	[[ ${_[$1]:-} = "$NIL" ]]
}

flag.parse-() {
	if .contains -help "$@"; then
		flag.usage-and-bye
	fi

	local -A flag_result_

	local -i argc=0
	while [[ $# -gt 0 ]]; do
		local key value

		if [[ $1 =~ ^-*[[:alpha:]_][[:alnum:]_]*= ]]; then
			key=${1%%=*}; value=${1#*=}
			if [[ $key =~ ^-.+$ ]] && [[ ! -v _[$key] ]]; then
				.die "Unrecognized flag: $key"
			fi
		elif [[ $1 == '--' ]] && [[ -z ${_[.dash]:-} ]]; then
			shift
			break
		else
			key=$((++argc)); value=$1
		fi

		# shellcheck disable=2034
		flag_result_["$key"]=${value:-${_["$key"]:-}}

		shift
	done

	flag.load flag_result_

	flag.validate- $argc
}

flag.peek-() {
	if .contains -help "$@"; then
		flag.usage-and-bye
	fi

	local -A flag_result_

	local -i argc=0
	while [[ $# -gt 0 ]]; do
		local key value

		if [[ $1 =~ ^-*[[:alpha:]_][[:alnum:]_]*= ]]; then
			key=${1%%=*}; value=${1#*=}
		elif [[ $1 == '--' ]] && [[ -z ${_[.dash]:-} ]]; then
			shift
			break
		else
			key=$((++argc)); value=$1
		fi

		# shellcheck disable=2034
		flag_result_["$key"]=${value:-${_["$key"]:-}}

		shift
	done

	flag.load flag_result_

	flag.validate- $argc
}

flag.true() {
	.bool "${_[$1]:-}"
}

flag.usage() {
	local name="$PROGNAME ${CMDNAMES[*]}"

	if [[ -n ${_[.help]:-} ]]; then
		# shellcheck disable=2128
		.say "Usage: $name ${_[.help]}"
	else
		# shellcheck disable=2128
		.say "Usage: $name"
	fi
}

flag.usage-and-die() {
	flag.usage

	.die "$@"
}

# shellcheck disable=2120
flag.usage-and-bye() {
	flag.usage

	.bye "$@"
}

# flag - Private functions

flag.args-() {
	local n=${1?${FUNCNAME[0]}: missing argument}; shift

	local argc=${_[.argc]:-0}

	[[ $argc != '-' ]] || return 0

	local lo hi

	if [[ $argc =~ ^[0-9]+$ ]]; then
		lo=$argc; hi=$argc
	elif [[ $argc =~ ^[0-9]*-[0-9]*$ ]]; then
		IFS=- read -r lo hi <<<"$argc"
	else
		.bug "Incorrect range: $argc"
	fi

	local message
	if   [[ -n ${lo:-} ]] && [[ $n -lt $lo ]]; then
		message='Too few arguments'
	elif [[ -n ${hi:-} ]] && [[ $n -gt $hi ]]; then
		message='Too many arguments'
	else
		return 0
	fi

	flag.usage-and-die "$message"
}

flag.nils-() {
	local -a required=()

	local key
	for key in "${!_[@]}"; do
		if flag.nil "$key"; then
			required+=("$key")
		fi
	done

	[[ ${#required[@]} -eq 0 ]] || .die "Value missing for: ${required[*]}"
}

flag.validate-() {
	flag.args- "$@"
	flag.nils-
}

# flag - Protected functions

.bool() {
	local value=${1:-}

	value=${value,,}

	case $value in
	true|t|1|on|yes|y)
		return 0
		;;
	false|f|0|off|no|n|"")
		return 1
		;;
	*)
		.bug "Invalid boolean: $value"
	esac
}

# flag - Init

flag.init-() {
	shopt -s expand_aliases

	# shellcheck disable=2142
	alias flag.parse='flag.parse- "$@"; local -a __argv__ ARGV=("$@"); flag.args __argv__; set -- "${__argv__[@]}"; unset -v __argv__'

	# shellcheck disable=2142
	alias flag.peek='flag.peek- "$@"; local -a __argv__=() ARGV=("$@"); flag.args __argv__; set -- "${__argv__[@]}"; unset -v __argv__'

	# shellcheck disable=2034
	declare -gr NIL="\0"
}

flag.init-

# self.sh - Functions related to program itself

self.name() {
	# shellcheck disable=2128
	echo "$PROGNAME"
}

self.path() {
	local self

	self=${BASH_SOURCE[0]}
	case $self in
	./*) readlink -f "$self" ;;
	/*)  echo "$self" ;;
	*)   readlink -f "$(command -v "$self")" ;;
	esac
}

self.src() {
	local path

	path=$(self.path)
	if .interactive; then
		echo "$path"
	else
		echo "builtin source '$path'"
	fi
}

self.version() {
	echo "${VERSION:-}"
}

# ui.sh - UI functions

ui.out() {
	local name=${1:-default}
	shift || true

	local sign=${_sign[$name]}

	# shellcheck disable=2154
	local sign_color=${_sign_color[$name]} text_color=${_text_color[$name]} reset=${_color[reset]}

	echo -en "${sign_color}${sign}${reset} "
	.out "$@"
	echo -en "$reset "
}

# shellcheck disable=2154
ui.echo() {
	[[ $# -gt 0 ]] || return 0

	local message=$1

	local name=${FUNCNAME[1]#*.}

	local sign=${_sign[$name]}

	local sign_color=${_sign_color[$name]} text_color=${_text_color[$name]} reset=${_color[reset]}

	if [[ -n ${sign:-} ]]; then
		echo -e "${sign_color}${sign}${reset} ${text_color}${message}${reset}"
	else
		echo -e "${text_color}${message}${reset}"
	fi
}

# ui - Init

# shellcheck disable=2034,2154
ui.init-() {
	declare -Ag _sign _sign_color _text_color

	# Style

	_sign[ask]='?';     _sign_color[ask]=+yellow;    _text_color[ask]=high
	_sign[bug]='✖';     _sign_color[bug]=red;        _text_color[bug]=high
	_sign[cry]='!';     _sign_color[cry]=+yellow;    _text_color[cry]=medium
	_sign[die]='✗';     _sign_color[die]=+red;       _text_color[die]=high
	_sign[hmm]='ℹ';     _sign_color[hmm]=-yellow;    _text_color[hmm]=low
	_sign[say]='' ;     _sign_color[say]=+white;     _text_color[say]=medium

	_sign[notok]='✗';   _sign_color[notok]=+red;     _text_color[notok]=high
	_sign[ok]='✓';      _sign_color[ok]=+green;      _text_color[ok]=high

	_sign[calling]='>'; _sign_color[calling]=+cyan;  _text_color[calling]=high
	_sign[getting]='↓'; _sign_color[getting]=+cyan;  _text_color[getting]=low
	_sign[running]='∙'; _sign_color[running]=+cyan;  _text_color[running]=low
	_sign[default]='∙'; _sign_color[default]=+white; _text_color[default]=medium

	color.expand _sign_color _text_color

	.bug()     { ui.echo "$@" >&2; exit 127; }
	.bye()     { ui.echo "$@" >&2; exit 0;   }
	.calling() { ui.echo "$1" >&2; "${@:2}"; }
	.cry()     { ui.echo "$@" >&2;           }
	.die()     { ui.echo "$@" >&2; exit 1;   }
	.getting() { ui.echo "$1" >&2; "${@:2}"; }
	.hmm()     { ui.echo "$@" >&2;           }
	.notok()   { ui.echo "$@" >&2;           }
	.ok()      { ui.echo "$@" >&2;           }
	.running() { ui.echo "$1" >&2; "${@:2}"; }
	.say()     { ui.echo "$@" >&2;           }
}

ui.init-

# cmd/t - Testing

# Assert failed command outputs
t:err() {
	t:assert_ "$@"
}

# Return failure
t:fail() {
	t:assert_ "$@"
}

# Assert actual value equals to the expected
t:is() {
	t:assert_ "$@"
}

# Assert got value not equals to the expected
t:isnt() {
	t:assert_ "$@"
}

# Assert got value matches with the expected
t:like() {
	t:assert_ "$@"
}

# Assert command fails
t:notok() {
	t:assert_ "$@"
}

# Assert command succeeds
t:ok() {
	t:assert_ "$@"
}

# Assert successful command outputs
t:out() {
	t:assert_ "$@"
}

# Return success
t:pass() {
	t:assert_ "$@"
}

# Assert got value not matches with the expected
t:unlike() {
	t:assert_ "$@"
}

# Create and chdir to temp directory
t:temp() {
	local tempdir

	if [[ -n ${PWD[tmp]:-} ]]; then
		tempdir=${PWD[tmp]}

		temp.clean tempdir
	fi

	temp.dir tempdir

	.must -- cd "$tempdir"

	# shellcheck disable=2128
	PWD[tmp]=$PWD
}

# Run all test suites defined so far
# shellcheck disable=2034
t:go() {
	local -a _t_go_tests_

	mapfile -t _t_go_tests_ < <(
		shopt -s extdebug

		declare -F | grep 'declare -f test[.]' | awk '{ print $3 }' |
		while read -r t; do declare -F "$t"; done |
		sort -t' ' -k2 -n | awk '
			$1 !~ /test[.]setup|test[.]teardown|test[.]startup|test[.]shutdown/ {
				print $1
			}
		'
	)

	! .callable test.startup || test.startup

	local _t_go_
	for _t_go_ in "${_t_go_tests_[@]}"; do
		! .callable test.setup    || test.setup
		"$_t_go_"
		! .callable test.teardown || test.teardown
	done

	! .callable test.shutdown || test.shutdown

	tap plan total="${_test_[current]:-}"

	tap shutdown total="${_test_[current]:-}" \
		     success="${_test_[success]:-}" \
		     failure="${_test_[failure]:-0}" \
		     todo="${_test_[todo]:-0}" \
		     skip="${_test_[skip]:-0}"
}

# cmd/t - Protected functions

t:assert_() {
	local assert=assert.${FUNCNAME[1]#*:}

	local -a args

	while [[ $# -gt 0 ]]; do
		if [[ $1 = '--' ]]; then
			shift
			break
		fi

		args+=("$1")
		shift
	done

	_test_[current]=$((${_test_[current]:-0} + 1))

	local current=${_test_[current]} message

	if [[ ${1:-} =~ [sS][kK][iI][pP]\S* ]]; then
		shift; message="$*"

		tap skip test="$message" number="$current"
		_test_[skip]=$((${_test_[skip]:-0} + 1))
		_test_[success]=$((${_test_[success]:-0} + 1))
	elif [[ ${1:-} =~ [tT][oO][dD][oO]\S* ]]; then
		shift; message="$*"

		tap todo test="$message" number="$current"
		_test_[todo]=$((${_test_[todo]:-0} + 1))
		_test_[failure]=$((${_test_[failure]:-0} + 1))
	else
		message="$*"

		local -a err

		if "$assert" err "${args[@]}"; then
			tap success test="$message" number="$current"
			_test_[success]=$((${_test_[success]:-0} + 1))
		else
			tap failure test="$message" number="$current" "${err[@]}"
			_test_[failure]=$((${_test_[failure]:-0} + 1))
		fi
	fi
}

t:reset_() {
	_test_[current]=0
	_test_[start]=$SECONDS
}

# assert - Init

t:init_() {
	declare -Ag _test_=()

	t:reset_
}

t:init_

# cmd/version - Print version

declare -gr VERSION=0.0.0

# Return version
:version() {
	local -A _; flag.parse

	echo "${VERSION:-}"
}

if [[ "${BASH_SOURCE[0]}" = "$0" ]]; then
	declare -Ag _help=(
		[':version']='Return version'
		['t:err']='Assert failed command outputs'
		['t:fail']='Return failure'
		['t:go']='Run all test suites defined so far'
		['t:is']='Assert actual value equals to the expected'
		['t:isnt']='Assert got value not equals to the expected'
		['t:like']='Assert got value matches with the expected'
		['t:notok']='Assert command fails'
		['t:ok']='Assert command succeeds'
		['t:out']='Assert successful command outputs'
		['t:pass']='Return success'
		['t:temp']='Create and chdir to temp directory'
		['t:unlike']='Assert got value not matches with the expected'
	)

	declare -Ag _command=(
		['err']='t:err'
		['fail']='t:fail'
		['go']='t:go'
		['is']='t:is'
		['isnt']='t:isnt'
		['like']='t:like'
		['notok']='t:notok'
		['ok']='t:ok'
		['out']='t:out'
		['pass']='t:pass'
		['temp']='t:temp'
		['unlike']='t:unlike'
		['version']=':version'
	)

	# main - Application

	.usage() {
		# shellcheck disable=2128
		.say "Usage: $PROGNAME COMMAND... [-FLAG=VALUE...] [ARGS]"
		.say ""
		.say "Commands:"

		local cmd

		# shellcheck disable=2154
		for cmd in "${!_command[@]}"; do
			local fun=${_command[$cmd]}

			printf "\\t%-24s  %s\n" "$cmd" "${_help[$fun]:-}"
		done | sort >&2
	}

	# shellcheck disable=2154
	.dispatch() {
		local orig="${*}"

		if [[ $# -eq 0 ]]; then
			.usage

			.die 'Command required'
		fi

		local help=

		if [[ $1 = help ]]; then
			help=true

			shift

			if [[ $# -eq 0 ]]; then
				.usage

				.die 'Help topic required'
			fi
		fi

		local -a args=("$@") try

		local cmd
		while [[ $# -gt 0 ]]; do
			try+=("$1")
			shift

			if [[ -n ${_command[${try[*]}]:-} ]]; then
				cmd=${try[*]}
				args=("$@")
			fi
		done

		[[ -n ${cmd:-} ]] || .die "No command found: $orig"

		local fun=${_command["$cmd"]}

		CMDNAMES+=("$cmd")

		if [[ -n ${help:-} ]]; then
			.say "${_help[$fun]:-}" ""

			"$fun" -help
		else
			"$fun" "${args[@]}"
		fi
	}

	.redirect() {
		local -a args=("$@") try

		local cmd
		while [[ $# -gt 0 ]]; do
			try+=("$1")
			shift

			if [[ -n ${_command[${try[*]}]:-} ]]; then
				cmd=${try[*]}
				args=("$@")
			fi
		done

		[[ -n ${cmd:-} ]] || .die "No command found: $orig"

		local fun=${_command["$cmd"]}

		unset 'CMDNAMES[${#CMDNAMES[@]}-1]'
		CMDNAMES+=("$cmd")

		"$fun" "${args[@]}"
	}

	main() {
		if ! .interactive && [[ $# -eq 0 ]]; then
			echo "readonly _SELF=$(self.path)"
			echo
			sed 's/^\t\t\t\t//' <<'EOF'
				#!/usr/bin/env bash

				[ -n "${BASH_VERSION:-}"        ] || { echo >&2 'Bash required.';                     exit 1; }
				[[ ${BASH_VERSINFO[0]:-} -ge 4 ]] || { echo >&2 'Bash version 4 or higher required.'; exit 1; }

				# Protected functions

				.available() {
					command -v "${1?${FUNCNAME[0]}: missing argument}" &>/dev/null
				}

				.bug() {
					if [[ $# -gt 0 ]]; then
						echo -e >&2 "BUG: $*"
					else
						echo >&2 ""
					fi

					exit 127
				}

				.bye() {
					if [[ $# -gt 0 ]]; then
						echo -e >&2 "$*"
					else
						echo >&2 ""
					fi

					exit 0
				}

				.callable() {
					[[ $(type -t "${1?${FUNCNAME[0]}: missing argument}" || true) == function ]]
				}

				.contains() {
					: "${1?${FUNCNAME[0]}: missing argument}"

					local element

					for element in "${@:2}"; do
						if [[ $element = "$1" ]]; then
							return 0
						fi
					done

					return 1
				}

				.cry() {
					if [[ $# -gt 0 ]]; then
						echo -e >&2 "W: $*"
					else
						echo >&2 ""
					fi
				}

				.die() {
					if [[ $# -gt 0 ]]; then
						echo -e >&2 "E: $*"
					else
						echo >&2 ""
					fi

					exit 1
				}

				.err() {
					.out "$@" >&2
				}

				.expired() {
					local -i expiry=${1?${FUNCNAME[0]}: missing argument}; shift

					case $expiry in
					-1) return 1 ;;
					0)  return 0 ;;
					esac

					local file
					for file; do
						if [[ -e $file ]] && [[ -z $(find "$file" -mmin +"$expiry" 2>/dev/null) ]]; then
							return 1
						fi
					done

					return 0
				}

				.interactive() {
					[[   -t 1 ]]
				}

				.out() {
					local arg

					for arg; do
						echo -e "$arg"
					done

					if .piped; then
						cat
					fi
				}

				.piped() {
					[[ ! -t 0 ]]
				}

				.load() {
					# shellcheck disable=2128
					local _load_old_=$PWD

					[[ -v _load_dirs_ ]] || declare -ag _load_dirs_=(
						"$(dirname "$(readlink -f "$0")")"
					)

					local _load_src_

					for _load_src_; do
						builtin cd "${_load_dirs_[-1]}" || .die "Chdir error: ${_load_dirs_[-1]}"

						local _load_src_found_

						for _load_src_found_ in "$_load_src_" "$_load_src_".sh; do
							if [[ -f $_load_src_found_ ]]; then
								_load_src_found_=$(readlink -f "$_load_src_found_")

								_load_dirs_+=("$(dirname "$_load_src_found_")")

								builtin source "$_load_src_found_"
							fi
						done

						unset _load_src_found_
					done

					unset _load_src_

					builtin cd "$_load_old_" || .die "Chdir error: $_load_old_"
					unset _load_old_
				}

				.merge() {
					local -n lhs=${1?${FUNCNAME[0]}: missing argument}; shift
					local -n rhs=${1?${FUNCNAME[0]}: missing argument}; shift

					local key
					for key in "${!rhs[@]}"; do
						# shellcheck disable=2034
						lhs[$key]=${rhs[$key]}
					done
				}

				.must() {
					if [[ ${1:-} = -- ]]; then
						shift

						eval -- "${@?${FUNCNAME[0]}: missing argument}" || .die "Command failed: $*"
					else
						eval -- "${@:2}" || .die "${1?${FUNCNAME[0]}: missing argument}"
					fi
				}

				.say() {
					echo -e "${@-""}"
				}

				.should() {
					if [[ ${1:-} = -- ]]; then
						shift

						eval -- "${@?${FUNCNAME[0]}: missing argument}" || .cry "Exit code $? is suppressed: $*"
					else
						eval -- "${@:2}" || .cry "${1?${FUNCNAME[0]}: missing argument}"
					fi
				}

				# Init

				# shellcheck disable=2034,2128
				.prelude() {
					set -Eeuo pipefail; shopt -s nullglob; [[ -z ${TRACE:-} ]] || set -x; unset CDPATH; IFS=$' \t\n'

					export LC_ALL=C.UTF-8 LANG=C.UTF-8

					# Program name
					declare -gr PROGNAME=${0##*/}

					# Command names
					declare -g CMDNAMES=()
				}

				.prelude

				# assert.sh - Assertions

				assert.err() {
					local -n assert_err_=${1?${FUNCNAME[0]}: missing argument}; shift

					# shellcheck disable=2034
					assert_err_=("$(
						hope -success=false "$@"
					)")
				}

				assert.fail() {
					false
				}

				assert.is() {
					local -n assert_is_=${1?${FUNCNAME[0]}: missing argument}; shift

					local got=${1?${FUNCNAME[0]}: missing argument};      shift
					local expected=${1?${FUNCNAME[0]}: missing argument}; shift

					# shellcheck disable=2034
					assert_is_="Got '$got' where expected '$expected'"

					[[ $got = "$expected" ]]
				}

				assert.isnt() {
					local -n assert_isnt_=${1?${FUNCNAME[0]}: missing argument}; shift

					local got=${1?${FUNCNAME[0]}: missing argument};      shift
					local expected=${1?${FUNCNAME[0]}: missing argument}; shift

					# shellcheck disable=2034
					assert_isnt_=("Got unexpected '$got'")

					[[ $got != "$expected" ]]
				}

				assert.like() {
					local -n assert_like_=${1?${FUNCNAME[0]}: missing argument}; shift

					local got=${1?${FUNCNAME[0]}: missing argument};      shift
					local expected=${1?${FUNCNAME[0]}: missing argument}; shift

					# shellcheck disable=2034
					assert_like_=("Got '$got' where expected to match with '$expected'")

					[[ $got =~ $expected ]]
				}

				assert.notok() {
					local -n assert_notok_=${1?${FUNCNAME[0]}: missing argument}; shift

					# shellcheck disable=2034
					assert_notok_="Command expected to fail but succeeded: $*"

					! eval -- "$@"
				}

				# shellcheck disable=2034
				assert.ok() {
					local -n assert_ok_=${1?${FUNCNAME[0]}: missing argument}; shift

					assert_ok_="Command expected to succeed but failed: $*"

					eval -- "$@"
				}

				assert.out() {
					local -n assert_out_=${1?${FUNCNAME[0]}: missing argument}; shift

					# shellcheck disable=2034
					assert_out_=("$(
						hope -success=true "$@"
					)")
				}

				assert.pass() {
					true
				}

				assert.unlike() {
					local -n assert_unlike_=${1?${FUNCNAME[0]}: missing argument}; shift

					local got=${1?${FUNCNAME[0]}: missing argument};      shift
					local expected=${1?${FUNCNAME[0]}: missing argument}; shift

					# shellcheck disable=2034
					assert_unlike_=("Got '$got' where expected to unmatch with '$expected'")

					[[ ! $got =~ $expected ]]
				}


				# defer.sh - Deferred functions

				# Register files/directories to clean up at exit
				.clean() {
					[[ -v _defer_initialized_ ]] || .defer

					_defer_clean_+=("$@")
				}

				# Trap defer setup
				# shellcheck disable=2120
				.defer() {
					if [[ -v _defer_initialized_ ]]; then
						return
					else
						_defer_initialized_=true

						declare -ag _defer_clean_=()

						if [[ -n $(builtin trap -p 2>/dev/null) ]]; then
							.cry 'Trap already taken.'

							return
						fi
					fi

					local -a signals=("$@")
					[[ $# -gt 0 ]] || signals=(EXIT HUP INT KILL QUIT TERM)

					local signal
					for signal in "${signals[@]}"; do
						# shellcheck disable=2064
						builtin trap "_defer_ $signal" "$signal"
					done

					# Prevent using trap
					trap() {
						.bug 'Using trap is forbidden; please use defer.* functions.'
					}

					# shellcheck disable=2139
					alias .untrap="trap - ${signals[*]}"

					_defer_() {
						local -r SIGNAL=$1 ERR=$?

						.callback defer

						if [[ -v _defer_clean_ ]] && [[ "${#_defer_clean_[@]}" -gt 0 ]]; then
							rm -rf -- "${_defer_clean_[@]}"
						fi

						builtin trap - EXIT

						if [[ $SIGNAL = INT ]] || [[ $SIGNAL = QUIT ]]; then
							builtin trap - "$SIGNAL"; kill -s "$SIGNAL" "$$"
						fi

						return "$ERR"
					}

					readonly -f _defer_
				}

				# Create a temp dir
				temp.dir() {
					# shellcheck disable=2155
					local -n temp_dir_=${1?${FUNCNAME[0]}: missing argument}; shift

					local dir

					# shellcheck disable=2128
					dir=$(mktemp -p "${TMPDIR:-/tmp}" -d "$PROGNAME".XXXXXXXX) || .die 'Fatal error: mktemp'
					.clean "$dir"

					# shellcheck disable=2034
					temp_dir_=$dir
				}

				# Remove temp files or directories
				temp.clean() {
					while [[ $# -gt 0 ]]; do
						local -n temp_clean_=$1; shift

						rm -rf -- "$temp_clean_"
					done
				}


				# cmd/t - Testing

				# Assert failed command outputs
				t:err() {
					t:assert_ "$@"
				}

				# Return failure
				t:fail() {
					t:assert_ "$@"
				}

				# Assert actual value equals to the expected
				t:is() {
					t:assert_ "$@"
				}

				# Assert got value not equals to the expected
				t:isnt() {
					t:assert_ "$@"
				}

				# Assert got value matches with the expected
				t:like() {
					t:assert_ "$@"
				}

				# Assert command fails
				t:notok() {
					t:assert_ "$@"
				}

				# Assert command succeeds
				t:ok() {
					t:assert_ "$@"
				}

				# Assert successful command outputs
				t:out() {
					t:assert_ "$@"
				}

				# Return success
				t:pass() {
					t:assert_ "$@"
				}

				# Assert got value not matches with the expected
				t:unlike() {
					t:assert_ "$@"
				}

				# Create and chdir to temp directory
				t:temp() {
					local tempdir

					if [[ -n ${PWD[tmp]:-} ]]; then
						tempdir=${PWD[tmp]}

						temp.clean tempdir
					fi

					temp.dir tempdir

					.must -- cd "$tempdir"

					# shellcheck disable=2128
					PWD[tmp]=$PWD
				}

				# Run all test suites defined so far
				# shellcheck disable=2034
				t:go() {
					local -a _t_go_tests_

					mapfile -t _t_go_tests_ < <(
						shopt -s extdebug

						declare -F | grep 'declare -f test[.]' | awk '{ print $3 }' |
						while read -r t; do declare -F "$t"; done |
						sort -t' ' -k2 -n | awk '
							$1 !~ /test[.]setup|test[.]teardown|test[.]startup|test[.]shutdown/ {
								print $1
							}
						'
					)

					! .callable test.startup || test.startup

					local _t_go_
					for _t_go_ in "${_t_go_tests_[@]}"; do
						! .callable test.setup    || test.setup
						"$_t_go_"
						! .callable test.teardown || test.teardown
					done

					! .callable test.shutdown || test.shutdown

					tap plan total="${_test_[current]:-}"

					tap shutdown total="${_test_[current]:-}" \
						     success="${_test_[success]:-}" \
						     failure="${_test_[failure]:-0}" \
						     todo="${_test_[todo]:-0}" \
						     skip="${_test_[skip]:-0}"
				}

				# cmd/t - Protected functions

				t:assert_() {
					local assert=assert.${FUNCNAME[1]#*:}

					local -a args

					while [[ $# -gt 0 ]]; do
						if [[ $1 = '--' ]]; then
							shift
							break
						fi

						args+=("$1")
						shift
					done

					_test_[current]=$((${_test_[current]:-0} + 1))

					local current=${_test_[current]} message

					if [[ ${1:-} =~ [sS][kK][iI][pP]\S* ]]; then
						shift; message="$*"

						tap skip test="$message" number="$current"
						_test_[skip]=$((${_test_[skip]:-0} + 1))
						_test_[success]=$((${_test_[success]:-0} + 1))
					elif [[ ${1:-} =~ [tT][oO][dD][oO]\S* ]]; then
						shift; message="$*"

						tap todo test="$message" number="$current"
						_test_[todo]=$((${_test_[todo]:-0} + 1))
						_test_[failure]=$((${_test_[failure]:-0} + 1))
					else
						message="$*"

						local -a err

						if "$assert" err "${args[@]}"; then
							tap success test="$message" number="$current"
							_test_[success]=$((${_test_[success]:-0} + 1))
						else
							tap failure test="$message" number="$current" "${err[@]}"
							_test_[failure]=$((${_test_[failure]:-0} + 1))
						fi
					fi
				}

				t:reset_() {
					_test_[current]=0
					_test_[start]=$SECONDS
				}

				# assert - Init

				t:init_() {
					declare -Ag _test_=()

					t:reset_
				}

				t:init_

				t() {
					local cmd

					[[ $# -gt 0 ]] || .die 'Test command required'

					cmd=$1
					shift

					[[ $cmd =~ ^[a-z][a-z0-9-]+$ ]] || .die "Invalid command name: $cmd"

					if .callable t:"$cmd"; then
						t:"$cmd" "$@"
					else
						tap "$@"
					fi
				}

				[[ $# -eq 0 ]] || .load "$@"

				[[ -z "${BASH_SOURCE[1]:-}" ]] || tap startup "${BASH_SOURCE[1]}"
EOF
		else
			.dispatch "$@"
		fi
	}

	main "$@"
fi