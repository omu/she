#!/usr/bin/env ruby
# frozen_string_literal: true

module Hope
  TOKEN_LNUMC = '.'
  TOKEN_LNUML = '$'
  TOKEN_RANGE = ':'
  TOKEN_EQUAL = '='
  TOKEN_STRNE = '!'
  TOKEN_MATCH = '~'
  TOKEN_REGNE = '^'

  class Actuals
    attr_reader :out, :err, :exit_code

    def initialize(out: nil, err: nil, exit_code: 0)
      @out       = Lines.new(out || [])
      @err       = Lines.new(err || [])
      @exit_code = exit_code
    end

    class Lines
      attr_reader :lines

      def initialize(lines)
        @lines = lines
      end
    end
  end

  class Expects
    attr_reader :out, :err

    def initialize(out: nil, err: nil)
      @out = Lines.new(out || [])
      @err = Lines.new(err || [])
    end

    def self.slice(lines, *names)
      streams = lines.map(&:chomp).slice_when(&:empty?)
      raise 'Error' if streams.size > names.size

      new Hash[
        *names.map { |name| [name.to_sym, streams.shift] }.flatten
      ]
    end

    class Lines
      attr_reader :lines

      def initialize(raw_lines)
        @lines = []
        raw_lines.map do |raw|
          next unless (line = Line.parse raw)

          @lines << line
        end
      end

      class Line
        attr_reader :raw, :expectation, :starting, :ending

        def initialize(raw:, expectation:, starting:, ending:, negate: false)
          @raw         = raw
          @expectation = expectation
          @starting    = starting
          @ending      = ending
          @negate      = negate
        end

        def ok?(got)
          result = expectation.is_a?(Regexp) ? got.match?(expectation) : got == expectation
          negate ? !result : result
        end

        class << self
          PATTERN = /
            ^
            (?<starting>
              -?\d+
              |
              #{Regexp.escape TOKEN_LNUML}
              |
              #{Regexp.escape TOKEN_LNUMC}
            )?
              #{Regexp.escape TOKEN_RANGE}?
            (?<ending>
              -?\d+
              |
              #{Regexp.escape TOKEN_LNUML}
              |
              #{Regexp.escape TOKEN_LNUMC}
            )?
            (?<type>
              #{Regexp.escape TOKEN_EQUAL}
              |
              #{Regexp.escape TOKEN_STRNE}
              |
              #{Regexp.escape TOKEN_MATCH}
              |
              #{Regexp.escape TOKEN_REGNE}
            )?
            $
          /.x.freeze

          DEFAULT = TOKEN_LNUMC

          def parse(raw) # rubocop:disable Metrics/MethodLength, Metrics/CyclomaticComplexity, Metrics/AbcSize
            return if raw =~ /^#/

            leading, expectation = raw.split(/\s/, 2)
            leading = DEFAULT if leading.empty?

            raise 'Error' unless (m = leading.match(PATTERN))

            type = TOKEN_EQUAL if m[:type].empty?

            negate = false

            case type
            when TOKEN_EQUAL then nil
            when TOKEN_STRNE then negate = true
            when TOKEN_MATCH then expectation = Regexp.new expectation
            when TOKEN_REGNE then expectation, negate = Regexp.new expectation, true
            else                  raise 'Error'
            end

            Line.new(raw: raw, expectation: expectation, starting: m[:starting], ending: m[:ending], negate: negate)
          end
        end
      end
    end

    class Scanner
      def self.call(actual_lines, expect_lines)
        new(actual_lines).call(expect_lines)
      end

      module Refinery
        refine Integer do
          def to_lnum
            self + 1
          end

          def from_lnum
            self - 1
          end
        end
      end

      using Refinery

      attr_reader :actual_lines, :current, :last, :error

      def initialize(actual_lines)
        @actual_lines  = actual_lines
        @current       = 0
        @last          = actual_lines.size.from_lnum
      end

      def call(expect_lines)
        expect_lines.each do |expect|
          return false unless assert(expect)
        end
      end

      protected

      def assert(expect)
        actual_lines_in_range, start = relevant_actual_lines(expect)
        return error_not_applicable(expect) if actual_lines_in_range.empty?

        actual_lines_in_range.each_with_index do |actual, i|
          next unless expect.ok?(actual)

          advance start + i
          return true
        end

        error_not_expected(expect)
      end

      def error_not_applicable(expect)
        self.error = [
          'Expectation not applicable',
          "\tExpect: #{expect.raw}"
        ].join("\n")

        false
      end

      def error_not_expected(expect)
        actual_lines_in_range, = relevant_actual_lines(expect)

        self.error = [
          "Expectation failed at #{current.to_lnum}",
          "\tExpect: #{expect.raw}", *actual_lines_in_range.map { |line| "\tGot: #{line}" }
        ].join("\n")

        false
      end

      def last?
        current >= last
      end

      def advance(step = 1)
        self.current += step
      end

      def range(expect)
        Range.new(int(expect.starting) || 0, int(expect.ending) || last)
      end

      private

      attr_writer :error

      def relevant_actual_lines(expect)
        [actual_lines[range = range(expect)], range.first]
      end

      def int(string)
        return unless string

        return current if string == TOKEN_LNUMC
        return last    if string == TOKEN_LNUML

        string.to_i.from_lnum
      end
    end
  end

  module_function

  def call(actuals, expects)
    out_error, err_error = Scanner.(actuals.out, expects.out), Scanner.(actuals.err, expects.err)
    [out_error && err_error, out_error, err_error]
  end

  def actuals(_argv = ARGV)
    Actuals.new
  end

  def expect(_argv = ARGV)
    Expects.new
  end
end

def main
  _ok, _out_error, _err_error = Hope.(Hope.actuals, Hope.expects)
end
