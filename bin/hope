#!/usr/bin/env ruby
# frozen_string_literal: true

require 'open3'

module Hope
  TOKEN_LNUMC = '.'
  TOKEN_LNUML = '$'
  TOKEN_RANGE = ':'
  TOKEN_EQUAL = '='
  TOKEN_STRNE = '!'
  TOKEN_MATCH = '~'
  TOKEN_REGNE = '^'

  class Result
    attr_accessor :ok

    def initialize(**items)
      @bag = {}

      put(**items)
    end

    def get(item)
      bag.fetch(item)
    end

    def put(**items)
      bag.merge! items
    end

    def ok?
      ok
    end

    def reset
      self.bag = {}
      self.ok  = nil
    end

    def flash(*messages)
      messages.each { |message| warn(message) }
      bag.each_value { |value| warn value }

      reset
    end

    private

    attr_accessor :bag
  end

  class Runner
    def self.run(*args)
      new.run(*args)
    end

    def initialize
      @coathooks = 0
    end

    def run(*args)
      out, err, status =
        Open3.popen3(*args) do |_, stdout, stderr, wait_thread|
          block(stdout, stderr, wait_thread)
        end

      result = Result.new cmd: args.join(' '), out: out, err: err
      result.ok = status.exitstatus&.zero?

      result
    end

    private

    attr_reader :coathooks

    def block(stdout, stderr, wait_thread)
      # Handle `^C`
      trap('INT') { handle_sigint(wait_thread.pid) }

      out = stdout.readlines.map(&:chomp)
      err = stderr.readlines.map(&:chomp)

      [out, err, wait_thread.value]
    end

    def handle_sigint(pid)
      message, signal = message_and_signal
      warn "\n" + message
      ::Process.kill signal, pid
      @coathooks += 1
    rescue Errno::ESRCH
      warn 'No process to kill.'
    end

    def message_and_signal
      if coathooks > 1
        ['SIGINT received again. Force quitting...', 'KILL']
      else
        ['SIGINT received.', 'TERM']
      end
    end
  end

  class Lines < SimpleDelegator
    NotApplicableError = Class.new StandardError

    def current_index
      @current_index ||= 0
    end

    def last_index
      @last_index ||= size - 1
    end

    def first_lnum
      '1'
    end

    def current_lnum
      to_lnum current_index
    end

    def last_lnum
      to_lnum last_index
    end

    def slice_between(starting: TOKEN_LNUMC, ending: TOKEN_LNUML)
      self[from_lnum(starting)..from_lnum(ending)]
    end

    def match_slice_between(starting: TOKEN_LNUMC, ending: TOKEN_LNUML)
      slice = self[(start = from_lnum(starting))..from_lnum(ending)]
      raise NotApplicableError if !slice || slice.empty?

      slice.each_with_index do |item, index|
        next unless yield(item)

        self.current_index = start + index + 1
        return true
      end

      false
    end

    def from_lnum(lnum)
      case lnum.to_s
      when TOKEN_LNUMC then current_index
      when TOKEN_LNUML then last_index
      else                  (num = lnum.to_i).negative? ? last_index + num + 1 : num - 1
      end
    end

    def to_lnum(index)
      (index + 1).to_s
    end

    private

    attr_writer :current_index
  end

  class Actuals
    attr_reader :out, :err

    def initialize(out: nil, err: nil)
      @out       = Lines.new(out || [])
      @err       = Lines.new(err || [])
    end
  end

  class Expects
    attr_reader :out, :err

    def initialize(out: nil, err: nil)
      @out = parse(out || [])
      @err = parse(err || [])
    end

    private

    def parse(raw_lines)
      lines = Lines.new []

      raw_lines.each do |raw|
        next unless (expect = Expect.parse(raw))

        lines << expect
      end

      lines
    end

    class << self
      def slice(lines, *names) # rubocop:disable Metrics/MethodLength
        result = {}

        i = 0
        lines.each do |line|
          line.chomp!
          if line.empty?
            raise 'Error' if i > names.size

            i += 1
          end
          (result[names[i].to_sym] ||= []) << line
        end

        result
      end
    end

    class Expect
      attr_reader :raw, :expectation, :starting, :ending, :negate

      def initialize(raw:, expectation:, starting:, ending:, negate: false)
        @raw         = raw
        @expectation = expectation
        @starting    = starting
        @ending      = ending
        @negate      = negate
      end

      def ok?(got)
        result = expectation.is_a?(Regexp) ? got.match?(expectation) : got == expectation
        negate ? !result : result
      end

      class << self
        PATTERN = /
          ^
          (?<starting>
            -?\d+
            |
            #{Regexp.escape TOKEN_LNUML}
            |
            #{Regexp.escape TOKEN_LNUMC}
          )?
          (?<range>
            #{Regexp.escape TOKEN_RANGE}
          )?
          (?<ending>
            -?\d+
            |
            #{Regexp.escape TOKEN_LNUML}
            |
            #{Regexp.escape TOKEN_LNUMC}
          )?
          (?<type>
            #{Regexp.escape TOKEN_EQUAL}
            |
            #{Regexp.escape TOKEN_STRNE}
            |
            #{Regexp.escape TOKEN_MATCH}
            |
            #{Regexp.escape TOKEN_REGNE}
          )?
          $
        /x.freeze

        DEFAULT = "#{TOKEN_LNUMC}#{TOKEN_RANGE}#{TOKEN_LNUMC}"

        def parse(raw) # rubocop:disable Metrics/MethodLength, Metrics/CyclomaticComplexity, Metrics/AbcSize
          return if raw.match?(/^#/)

          leading, expectation = raw.split(/\s/, 2)
          leading = DEFAULT if leading.empty?

          raise 'Error' unless (m = leading.match(PATTERN))

          negate = false

          case m[:type]
          when TOKEN_EQUAL, NilClass, '' then nil
          when TOKEN_STRNE               then negate = true
          when TOKEN_MATCH               then expectation = Regexp.new(expectation)
          when TOKEN_REGNE               then expectation, negate = Regexp.new(expectation), true
          else                                raise "Error: #{type}"
          end

          Expect.new(raw: raw, expectation: expectation, negate: negate, **scope(m))
        end

        def scope(match)
          arg = {}
          if match[:range]
            arg[:starting] = match[:starting] || '1'
            arg[:ending]   = match[:ending]   || TOKEN_LNUML
          else
            arg[:starting] = match[:starting] || TOKEN_LNUMC
            arg[:ending]   = match[:ending]   || arg[:starting]
          end
          arg
        end
      end
    end
  end

  class Scanner
    def self.call(actual_lines, expect_lines)
      new(actual_lines).call(expect_lines)
    end

    attr_reader :actual_lines, :result

    def initialize(actual_lines)
      @actual_lines  = actual_lines
      @result        = Result.new
    end

    def call(expect_lines)
      expect_lines.each do |expect|
        next if assert(expect)

        error_not_expected(expect)
      rescue Lines::NotApplicableError
        error_not_applicable(expect)
      end

      result
    end

    protected

    def assert(expect)
      actual_lines.match_slice_between(starting: expect.starting, ending: expect.ending) do |actual|
        expect.ok? actual
      end
    end

    def error_not_applicable(expect)
      result.put error: [
        "Expectation not applicable: #{expect.raw}"
      ].join("\n")

      result.ok = false
    end

    def error_not_expected(expect)
      actual_lines_in_range = actual_lines.slice_between(starting: expect.starting, ending: expect.ending)

      result.put error: [
        "Expectation failed at line: #{actual_lines.current_lnum}",
        "  Expect: #{expect.raw}", *actual_lines_in_range.map { |line| "     Got: #{line}" }
      ].join("\n")

      result.ok = false
    end
  end

  class << self
    def call(actuals, expects)
      %i[out err].each do |stream|
        result = Scanner.(actuals.send(stream), expects.send(stream))
        return result unless result.ok?
      end
    end

    def run(argv = ARGV)
      stdin = STDIN.tty? ? [] : STDIN.readlines
      flag = argv.shift if argv.first.start_with? '-success'
      result = Runner.run(*argv)

      streams = sanitize(flag, result)

      result = self.(
        actuals(out: result.get(:out), err: result.get(:err)),
        expects(Expects.slice(stdin, *streams))
      )

      result.flash
    end

    private

    def actuals(**args)
      Actuals.new(**args)
    end

    def expects(**args)
      Expects.new(**args)
    end

    def sanitize(flag, result) # rubocop:disable Metrics/MethodLength
      case flag
      when '-success=true', NilClass
        return %i[out err] if result.ok?

        puts "Command expected to succeed where it failed: #{result.get :cmd}"
        puts result.get(:err)

        exit 1
      when '-success=false'
        return %i[err out] unless result.ok?

        puts "Command expected to fail where it succeeded: #{result.get :cmd}"
        puts result.get(:err)

        exit 1
      end
    end
  end
end

Hope.run
