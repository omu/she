#!/usr/bin/env ruby
# frozen_string_literal: true

module Hope
  TOKEN_LNUMC = '.'
  TOKEN_LNUML = '$'
  TOKEN_RANGE = ':'
  TOKEN_EQUAL = '='
  TOKEN_STRNE = '!'
  TOKEN_MATCH = '~'
  TOKEN_REGNE = '^'

  class Result
    attr_accessor :ok

    def initialize
      @bag = {}
    end

    def get(item)
      bag.fetch(item)
    end

    def put(**items)
      bag.merge! items
    end

    def ok?
      ok
    end

    def reset
      self.bag = {}
      self.ok  = nil
    end

    def flash(*messages)
      messages.each { |message| warn(message) }
      bag.each_value { |value| warn value }

      reset
    end

    private

    attr_accessor :bag
  end

  class Lines < SimpleDelegator
    def current_index
      @current_index ||= 0
    end

    def last_index
      @last_index ||= size - 1
    end

    def first_lnum
      '1'
    end

    def current_lnum
      to_lnum current_index
    end

    def last_lnum
      to_lnum last_index
    end

    def advance(step = 1)
      self.current_index += step
    end

    def slice_from_lnum(starting: TOKEN_LNUMC, ending: TOKEN_LNUML)
      self[from_lnum(starting)..from_lnum(ending)]
    end

    NotApplicableError = Class.new StandardError

    def lnum_slice_match(starting: TOKEN_LNUMC, ending: TOKEN_LNUML)
      slice = self[(start = from_lnum(starting))..from_lnum(ending)]
      raise NotApplicableError if !slice || slice.empty?

      slice.each_with_index do |item, index|
        next unless yield(item)

        self.current_index = start + index + 1
        return true
      end

      false
    end

    def from_lnum(lnum)
      case lnum.to_s
      when TOKEN_LNUMC then current_index
      when TOKEN_LNUML then last_index
      else                  (num = lnum.to_i).negative? ? last_index + num + 1 : num - 1
      end
    end

    def to_lnum(index)
      (index + 1).to_s
    end

    private

    attr_writer :current_index
  end

  class Actuals
    attr_reader :out, :err, :exit_code

    def initialize(out: nil, err: nil, exit_code: 0)
      @out       = Lines.new(out || [])
      @err       = Lines.new(err || [])
      @exit_code = exit_code
    end
  end

  class Expects
    attr_reader :out, :err

    def initialize(out: nil, err: nil)
      @out = parse(out || [])
      @err = parse(err || [])
    end

    private

    def parse(raw_lines)
      lines = Lines.new []

      raw_lines.each do |raw|
        next unless (line = Line.parse(raw))

        lines << line
      end

      lines
    end

    class << self
      def slice(lines, *names)
        streams = lines.map(&:chomp).slice_when(&:empty?)
        raise 'Error' if streams.size > names.size

        new Hash[
          *names.map { |name| [name.to_sym, streams.shift] }.flatten
        ]
      end
    end

    class Line
      attr_reader :raw, :expectation, :starting, :ending, :negate

      def initialize(raw:, expectation:, starting:, ending:, negate: false)
        @raw         = raw
        @expectation = expectation
        @starting    = starting
        @ending      = ending
        @negate      = negate
      end

      def ok?(got)
        result = expectation.is_a?(Regexp) ? got.match?(expectation) : got == expectation
        negate ? !result : result
      end

      class << self
        PATTERN = /
          ^
          (?<starting>
            -?\d+
            |
            #{Regexp.escape TOKEN_LNUML}
            |
            #{Regexp.escape TOKEN_LNUMC}
          )?
          (?<range>
            #{Regexp.escape TOKEN_RANGE}
          )?
          (?<ending>
            -?\d+
            |
            #{Regexp.escape TOKEN_LNUML}
            |
            #{Regexp.escape TOKEN_LNUMC}
          )?
          (?<type>
            #{Regexp.escape TOKEN_EQUAL}
            |
            #{Regexp.escape TOKEN_STRNE}
            |
            #{Regexp.escape TOKEN_MATCH}
            |
            #{Regexp.escape TOKEN_REGNE}
          )?
          $
        /x.freeze

        DEFAULT = "#{TOKEN_LNUMC}#{TOKEN_RANGE}#{TOKEN_LNUMC}"

        def parse(raw) # rubocop:disable Metrics/MethodLength, Metrics/CyclomaticComplexity, Metrics/AbcSize
          return if raw.match?(/^#/)

          leading, expectation = raw.split(/\s/, 2)
          leading = DEFAULT if leading.empty?

          raise 'Error' unless (m = leading.match(PATTERN))

          negate = false

          case m[:type]
          when TOKEN_EQUAL, NilClass, '' then nil
          when TOKEN_STRNE               then negate = true
          when TOKEN_MATCH               then expectation = Regexp.new(expectation)
          when TOKEN_REGNE               then expectation, negate = Regexp.new(expectation), true
          else                                raise "Error: #{type}"
          end

          Line.new(raw: raw, expectation: expectation, negate: negate, **scope(m))
        end

        def scope(match)
          arg = {}
          if match[:range]
            arg[:starting] = match[:starting] || '1'
            arg[:ending]   = match[:ending]   || TOKEN_LNUML
          else
            arg[:starting] = match[:starting] || TOKEN_LNUMC
            arg[:ending]   = match[:ending]   || TOKEN_LNUMC
          end
          arg
        end
      end
    end
  end

  class Scanner
    def self.call(actual_lines, expect_lines)
      new(actual_lines).call(expect_lines)
    end

    attr_reader :actual_lines, :result

    def initialize(actual_lines)
      @actual_lines  = actual_lines
      @result        = Result.new
    end

    def call(expect_lines)
      expect_lines.each do |expect|
        break unless assert(expect)
      end

      result
    end

    protected

    def assert(expect)
      actual_lines.lnum_slice_match(starting: expect.starting, ending: expect.ending) do |actual|
        expect.ok? actual
      end || error_not_expected(expect)
    rescue Lines::NotApplicableError
      error_not_applicable(expect)
    end

    def error_not_applicable(expect)
      result.put error: [
        "Expectation not applicable: #{expect.raw}"
      ].join("\n")

      result.ok = false
    end

    def error_not_expected(expect)
      actual_lines_in_range = actual_lines.slice_from_lnum(starting: expect.starting, ending: expect.ending)

      result.put error: [
        "Expectation failed at line: #{actual_lines.current_lnum}",
        "  Expect: #{expect.raw}", *actual_lines_in_range.map { |line| "     Got: #{line}" }
      ].join("\n")

      result.ok = false
    end
  end

  module_function

  def call(actuals, expects)
    %i[out err].each do |stream|
      result = Scanner.(actuals.send(stream), expects.send(stream))
      return result unless result.ok?
    end
  end

  def actuals(_argv = ARGV)
    Actuals.new out: [
      'foo bar',
      'xxx yyy',
      'aa aaa'
    ]
  end

  def expects(_argv = ARGV)
    Expects.new out: [
      '1:~ ba[zr]$',
      '-2 xxx yyy',
      '~ ^a',
      '-3! oo bar'
    ]
  end
end

def main
  result = Hope.(Hope.actuals, Hope.expects)
  result.flash
end

main
