#!/usr/bin/env bash

# prelude.sh - Standard prelude

[ -n "${BASH_VERSION:-}"        ] || { echo >&2 'Bash required.';                         exit 1; }
[[ ${BASH_VERSINFO[0]:-} -ge 4 ]] || { echo >&2 'Bash version 4 or higher required.';     exit 1; }
[[ -x /usr/bin/apt-get         ]] || { echo >&2 'Only Debian and derivatives supported.'; exit 1; }

set -Eeuo pipefail; shopt -s nullglob; [[ -z ${TRACE:-} ]] || set -x; unset CDPATH

export LC_ALL=C.UTF-8 LANG=C.UTF-8

# kernel.sh - Core functions

# cry: Print warning messages on standard error
cry() {
	local message

	for message; do
		echo >&2 "$message"
	done
}

# die: Print error messages and exit failure
die() {
	local message

	for message; do
		echo >&2 "E: $message"
	done

        exit 1
}

# bug: Report bug and exit failure
bug() {
	local message

	for message; do
		echo >&2 "B: ${BASH_LINENO[0]}: $message"
	done

	exit 127
}

# bye: Print messages and exit successfully
bye() {
	cry "$@"
	exit 0
}

# Dump an array variable
hmm() {
	while [[ $# -gt 0 ]]; do
		# shellcheck disable=2178,2155
		local -n hmm_=$1

		echo "${!hmm_}"

		local key
		for key in "${!hmm_[@]}"; do
			printf '  %-16s  %s\n' "${key}" "${hmm_[$key]}"
		done | sort
		echo

		shift
	done
}

bool() {
	local value=${1:-}

	case $value in
	true|on|yes|1)
		return 0
		;;
	false|off|no|0|"")
		return 1
		;;
	*)
		bug "Invalid boolean: $value"
	esac
}

# Command must success
must() {
	"$@" || die "Command failed: $*"
}

# Command may fail
might() {
	"$@" || cry "Exit code $? is suppressed: $*"
}

# Announce constant (readonly) environment variable
const() {
	local export=

	while [[ $# -gt 0 ]]; do
		case $1 in
		-x|-export|--export)
			export=
			shift
			;;
		-*)
			die "Unrecognized flag: $1"
			;;
		*)
			break
			;;
		esac
	done

	local -n const_reference_=$1
	shift

	local value
	for value; do
		if [[ -n $value ]]; then
			# shellcheck disable=2034
			const_reference_=$value

			declare -gr "${!const_reference_}"
			[[ -z ${export:-} ]] || export "${!const_reference_}"

			break
		fi
	done
}

# Ensure that the directory pointed by given environment variable exists
ensured() {
	local -n ensured_reference_=${1?missing 1th argument: name reference}

	[[ -n $ensured_reference_ ]] || die "Blank environment value found: $ensured_reference_"
	[[ -d $ensured_reference_ ]] || must mkdir -p "$ensured_reference_"
}

# Check timestamp of reference files against given expiry in minutes
expired() {
	local expiry=${1?missing 1th argument: expiry} # minutes
	shift

	local file
	for file; do
		if [[ -e $file ]] && [[ -z $(find "$file" -mmin +"$expiry" 2>/dev/null) ]]; then
			return 1
		fi
	done

	return 0
}

# Initialize underscore system

.() {
	# Program name
	const PROGNAME "${0##*/}"

	# Core environment
	if [[ ${EUID:-} -eq 0 ]]; then
		const _RUN "${UNDERSCORE_VOLATILE_PREFIX:-}"   /run/_
		const _USR "${UNDERSCORE_PERSISTENT_PREFIX:-}" /usr/local
		const _ETC  /etc/_:"$_USR"/etc/_:"$_RUN"/etc
	else
		const XDG_RUNTIME_DIR "${XDG_RUNTIME_DIR:-}" /run/"$EUID"
		const XDG_CONFIG_HOME "${XDG_CONFIG_HOME:-}" "$HOME"/.config
		const XDG_CACHE_HOME  "${XDG_CACHE_HOME:-}"  "$HOME"/.cache

		const _RUN "${UNDERSCORE_VOLATILE_PREFIX:-}"   "$XDG_RUNTIME_DIR"/_
		const _USR "${UNDERSCORE_PERSISTENT_PREFIX:-}" "$HOME"/.local
		const _ETC  /etc/_:"$XDG_CONFIG_HOME"/_:"$_RUN"/etc
	fi

	export PATH="$_RUN"/bin:"$PATH"
	export _ROOT=$_RUN

	unset -f "${FUNCNAME[0]}"
}

# init
.

# flag.sh - Flag handling

flag.parse() {
	if [[ ${#_[@]} -gt 1 ]]; then
		flag.parse_strict_ "$@"
	else
		flag.parse_loose_ "$@"
	fi
}

flag.args() {
	local -n flag_args_=$1

	local -i i
	for i in {1..9}; do
		if [[ -v _[$i] ]]; then
			flag_args_+=("${_[$i]}")
		fi
	done
}

flag.true() {
	bool "${_[-$1]:-}"
}

flag.false() {
	! flag.true "$@"
}

flag.dump() {
	hmm _
}

flag.overlay() {
	local -i i=1

	while [[ $# -gt 0 ]]; do
		local key value

		if [[ $1 =~ ^-*[[:alpha:]_][[:alnum:]_]*= ]]; then
			key=${1%%=*}; value=${1#*=}
			_["$key"]=$value
		elif [[ $1 == '--' ]]; then
			shift
			break
		else
			# shellcheck disable=2154
			_[error]="Non flag or key: $1"
			return 1
		fi

		shift
	done
}

flag.underlay() {
	local -i i=1

	while [[ $# -gt 0 ]]; do
		local key value

		if [[ $1 =~ ^-*[[:alpha:]_][[:alnum:]_]*= ]]; then
			key=${1%%=*}; value=${1#*=}
			[[ -v _[$key] ]] || _["$key"]=$value
		elif [[ $1 == '--' ]]; then
			shift
			break
		else
			_[error]="Non flag or key: $1"
			return 1
		fi

		shift
	done
}

flag.parse_strict_() {
	local -i i=1

	while [[ $# -gt 0 ]]; do
		local key value

		if [[ $1 =~ ^-*[[:alpha:]_][[:alnum:]_]*= ]]; then
			key=${1%%=*}; value=${1#*=}
			if [[ $key =~ ^-.+$ ]] && [[ ! -v _[$key] ]]; then
				_[error]="Unrecognized flag: $key"

				return 1
			fi
		elif [[ $1 == '--' ]]; then
			shift
			break
		else
			key=$((i++)); value=$1
		fi

		_["$key"]=$value

		shift
	done
}

flag.parse_loose_() {
	local -i i=1

	while [[ $# -gt 0 ]]; do
		local key value

		if [[ $1 =~ ^-*[[:alpha:]_][[:alnum:]_]*= ]]; then
			key=${1%%=*}; value=${1#*=}
		elif [[ $1 == '--' ]]; then
			shift
			break
		else
			key=$((i++)); value=$1
		fi

		_["$key"]=$value

		shift
	done
}

# string.sh - String manipulation

string.has_prefix_deleted() {
	local -n string_has_prefix_deleted_=$1
	local prefix=$2

	if [[ $string_has_prefix_deleted_ =~ ^$prefix ]]; then
		string_has_prefix_deleted_=${string_has_prefix_deleted_#$prefix}

		return 0
	fi

	return 1
}

string.delete_prefix() {
	string.has_prefix_deleted "$@" || :
}

string.has_suffix_deleted() {
	local -n string_has_suffix_deleted_=$1
	local suffix=$2

	if [[ $string_has_suffix_deleted_ =~ $suffix$ ]]; then
		string_has_suffix_deleted_=${string_has_suffix_deleted_%$suffix}

		return 0
	fi

	return 1
}

string.delete_suffix() {
	string.has_suffix_deleted "$@" || :
}

# path.sh - Path management

path.is_volatile() {
	df -t tmpfs "$1" &>/dev/null
}

path.is_equal() {
	[[ $(realpath -m "$1") = $(realpath -m "$2") ]]
}

path.is_inside() {
	local given=$1 path=$2

	local relative
	relative=$(realpath --relative-to "$given" "$path" 2>/dev/null) || return

	[[ ! $relative =~ ^[.] ]]
}

# https.sh - HTTP functions

# http.get: Get URL
http.get() {
	local url=$1

	[[ $url =~ ^.*:// ]] || url=https://$url

	curl -fsSL "$url"
}

# self.sh - Functions related to program itself

# self.version: Print self version
self.version() {
	echo 0.0
}

# self.name: Print self name
self.name() {
	echo she
}

# self.path: Print self path
self.path() {
	local self

	self=${BASH_SOURCE[0]}
	case $self in
	./*) readlink -f "$self" ;;
	/*)  echo "$self" ;;
	*)   readlink -f "$(command -v "$self")" ;;
	esac
}

self.usage() {
	local message

	for message;  do
		echo >&2 "$message"
	done

	echo >&2 "Usage: $(self.path) CMD [ARGS]..."
	exit 1
}

# trap.sh - Trap setup

declare -ag _at_exit_funcs_=()

declare -ag _at_exit_files_=()

# Register hooks at exit
at_exit() {
	local arg

	for arg; do
		[[ $(type -t "$arg" || true) == function ]] || bug "Not a function: $arg"
	done

	_at_exit_funcs_=("$@" "${_at_exit_funcs_[@]}")
}

# Register files/directories to clean up at exit
at_exit_files() {
	_at_exit_files_+=("$@")
}

_exit_() {
	local err=$?

	local func
	for func in "${_at_exit_funcs_[@]}"; do
		"$func" || cry "Exit hook failed: $func"
	done

	return "$err"
}

# Prevent using trap
trap() {
	bug 'Using trap is forbidden; please use at_exit to register hooks.'
}

_at_exit_cleanup_() {
	[[ ${#_at_exit_files_[@]} -gt 0 ]] || return 0

	rm -rf -- "${_at_exit_files_[@]}"
}

# shellcheck disable=2120
trap.setup() {
	local -a signals=(EXIT HUP INT QUIT TERM)

	[[ $# -eq 0 ]] || signals=("$@")

	# shellcheck disable=2154,2218
	builtin trap _exit_ "${signals[@]}"

	at_exit _at_exit_cleanup_
}

# temp.sh - Functions involving temporary directories or files

temp.file() {
	# shellcheck disable=2155
	local -n temp_file_=${1?missing 1th argument: name reference}

	local file

	file=$(mktemp -p "${TMPDIR:-/tmp}" "$PROGNAME".XXXXXXXX) || die 'Fatal error: mktemp'
	at_exit_files "$file"

	# shellcheck disable=2034
	temp_file_=$file
}

temp.dir() {
	# shellcheck disable=2155
	local -n temp_dir_=${1?missing 1th argument: name reference}

	local dir
	dir=$(mktemp -p "${TMPDIR:-/tmp}" -d "$PROGNAME".XXXXXXXX) || die 'Fatal error: mktemp'
	at_exit_files "$dir"

	# shellcheck disable=2034
	temp_dir_=$dir
}

# temp.inside: Execute command in temp dir and (optionally) move it elsewhere
temp.inside() {
	local temp_dir orig_dir=$PWD
	temp.dir temp_dir

	must cd "$temp_dir"
	"$@"
	must cd "$orig_dir"

	rm -rf -- "$temp_dir"
}

temp.clean() {
	local -n temp_clean_=${1?missing 1th argument: name reference}

	[[ -z ${!temp_clean_:-} ]] || rm -f -- "${!temp_clean_}"
}

# array.sh - Array functions

# Join array with the given separator
array.join() {
	local IFS=$1
	shift

	echo "$*"
}
# Duplicate array
array.dup() {
	local -n array_dup_lhs_=$1 array_dup_rhs_=$2

	local key
	for key in "${!array_dup_rhs_[@]}"; do
		# shellcheck disable=2034
		array_dup_lhs_[$key]=${array_dup_rhs_[$key]}
	done
}

# uel.sh - URL processing

# Parse URL
# shellcheck disable=2034
url.parse() {
	local -n url_parse_=_
	if [[ ${1:-} = -A ]]; then
		shift
		url_parse_=${1?missing 1th argument: hash reference}
	fi

	local url=${1?missing 1th argument: url}

	# shellcheck disable=1007
	local proto= userinfo= host= port= path= frag=

	if [[ $url =~ ^(/|./|file://) ]]; then
		proto='file';  url=${url#*://}
		tag=${url#*@}; url=${url%@*}
		path=$url

		# shellcheck disable=2209
		url_parse_[proto]=file
		url_parse_[path]=$path

		return 0
	fi

	if [[ $url =~ ^.+:// ]]; then
		proto=${url%%://*}; url=${url#*://}
	fi

	if [[ $url =~ ^[^@/]+@[^/:]+ ]]; then
		userinfo=${url%%@*}; url=${url#*@}
	fi

	if [[ $url =~ ^[^:]+:[0-9]+ ]]; then
		host=${url%%:*};      url=${url#$host:}
		port=${url%%[^0-9]*}; url=${url#$port}
	else
		host=${url%%[/:]*};   url=${url#*[/:]}
	fi

	if [[ $url =~ ^: ]]; then
		url=${url#*:}

		if [[ -n $proto ]]; then
			if [[ $proto != ssh ]]; then
				# shellcheck disable=2154
				url_parse_[error]='protocol mismatch'
				return 1
			fi
		else
			proto=ssh
		fi
	else
		url=${url#/}

		if [[ -n $proto && $proto = ssh ]]; then
			url_parse_[error]='invalid SSH url'
			return 1
		fi
	fi

	if [[ -z $proto ]]; then
		proto=https
	fi

	if [[ $url =~ [#].*$ ]]; then
		frag=${url#*#}; url=${url%#*}
	fi

	path=$url

	url_parse_[frag]=$frag
	url_parse_[host]=$host
	url_parse_[path]=$path
	url_parse_[port]=$port
	url_parse_[proto]=$proto
	url_parse_[userinfo]=$userinfo
}

# url.dump: TODO
url.dump() {
	url.parse "$1"
	hmm _
}

# git.sh - Git functions

git.is_git() {
	local path=$1

	[[ -d $path/.git ]] && git rev-parse --resolve-git-dir "$path/.git" &>/dev/null
}

git.must_sane() {
	git rev-parse --is-inside-work-tree &>/dev/null || die "Must be inside a git work tree: $PWD"
	git rev-parse --verify HEAD >/dev/null          || die "Unverified git HEAD: $PWD"
}

git.is_clean() {
	git rev-parse --verify HEAD >/dev/null &&
	git update-index -q --ignore-submodules --refresh &&
	git diff-files --quiet --ignore-submodules &&
	git diff-index --cached --quiet --ignore-submodules HEAD --
}

git.must_clean() {
	git.is_clean || die "Must be a clean git work tree: $PWD"
}

git.topdir() {
	local dir

	dir=$(git rev-parse --git-dir) && dir=$(cd "$dir" && pwd)/ && echo "${dir%%/.git/*}"
}

git.top() {
	git.must_sane

	must cd "$(git.topdir)"
}

git.default_branch() {
	git.must_sane

	git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@'
}

git.switch() {
	local branch=${1:-}

	[[ -n $branch ]] || branch=$(git.default_branch)

	git checkout --quiet "$branch"
}

git.refresh() {
	local -A _=(
		[-expiry]=3
	)

	flag.parse "$@"

	if expired "${_[-expiry]}" .git/FETCH_HEAD; then
		git.must_clean
		git pull --quiet origin
	fi
}

git.clone_() {
	local -a opt=(--quiet)

	[[ -z ${_[-shallow]:-} ]] || opt+=(--depth 1)
	[[ -z ${_[branch]:-}   ]] || opt+=(--branch "${_[branch]}")

	temp.inside git clone "${opt[@]}" "${_[url]}"

	_[src]=.
	_[dst]=${_[-prefix]:-.}/${_[name]}

	file.copy_by_flag

	temp.clean

	must cd "${_[dir]}"
}

git.refresh_() {
	must cd "${_[dst]}"

	git.switch "${_[branch]:-}"

	if expired "${_[expiry]}" .git/FETCH_HEAD; then
		git.must_clean
		git pull --quiet origin
	fi
}

# deb.sh - Debian package management

export DEBIAN_FRONTEND=noninteractive APT_KEY_DONT_WARN_ON_DANGEROUS_USAGE=DontWarn

# deb.update: Update Debian package index
deb.update() {
	expired 60 /var/cache/apt/pkgcache.bin || apt-get update
}

# deb.install: Install Debian packages
deb.install() {
	deb.update

	[[ $# -eq 0 ]] || apt-get -y install --no-install-recommends "$@"
}

# file.sh - File related operations

# file.install: Install file from URL
file.install() {
	# shellcheck disable=2192
	local -A _=(
		[-group]=
		[-mode]=
		[-owner]=
		[-prefix]=
	)

	flag.parse "$@"

	local url=${_[1]?missing value at [1]: url}

	_[url]=$url
	_[dst]=${_[2]:-${url##*/}}

	file.install_
}

# Copy file/directory to dstination creating all parents if necessary
file.copy() {
	file._do_args_ file.copy_ "$@"
}

# Move file/directory to destination creating all parents if necessary
file.move() {
	file._do_args_ file.move_ "$@"
}

# Link file/directory to dstination creating all parents if necessary
file.link() {
	file._do_args_ file.link_ "$@"
}

file.chogm() {
	# shellcheck disable=2192
	local -A _=(
		[-group]=
		[-mode]=
		[-owner]=
	)

	flag.parse "$@"

	local file=${1?missing 1th argument: file}

	file.chogm_ "$file"
}

file.ln() {
	local src=${1?missing 1th argument: src} dst=${2?missing 2nd argument: dst}

	src=$(realpath -m --relative-base "${dst%/*}" "$src")
	must ln -sf "$src" "$dst"
}

# file.sh - Private functions

file._do_args_() {
	local func=${1?missing 1th argument: func}
	shift

	# shellcheck disable=2192
	local -A _=(
		[-group]=
		[-mode]=
		[-owner]=
		[-prefix]=
	)

	flag.parse "$@"

	_[src]=${_[1]?missing value at [1]: src} _[dst]=${_[2]?missing value at [2]: dst}

	file._do_ "$func"
}

file._do_() {
	local func=${1?missing 1th argument: func}
	shift

	[[ -e ${_[src]} ]] || die "Source not found: ${_[src]}"

	[[ -z ${_[-prefix]:-} ]] || _[dst]=${_[-prefix]}/${_[dst]}

	local dst=${_[dst]} dstdir

	if string.has_suffix_deleted dst /; then
		dstdir=$dst
	else
		dstdir=$(dirname "$dst")
	fi

	_[dst]=$dst

	[[ $dstdir = . ]] || must mkdir -p "$dstdir"

	"$func"

	file.chogm_ "${_[dst]}"
}

file.install_() {
	local url=${_[url]?missing value: url} tempfile

	local tempfile

	if [[ $url =~ ^[.]*/ ]]; then
		_[src]=$url
	else
		temp.file tempfile
		http.get "$url" >"$tempfile"
		_[src]=$tempfile
	fi

	file._do_ file.copy_

	temp.clean tempfile
}

file.copy_() {
	must cp -a "${_[src]}" "${_[dst]}"
}

file.move_() {
	must mv -f "${_[src]}" "${_[dst]}"
}

file.link_() {
	file.ln "${_[src]}" "${_[dst]}"
}

file.chogm_() {
	local file=${1?missing 1th argument: file}

	[[ -z ${_[-mode]:-}  ]] || must chmod "${_[-mode]}"  "$file"
	[[ -z ${_[-owner]:-} ]] || must chown "${_[-owner]}" "$file"
	[[ -z ${_[-group]:-} ]] || must chgrp "${_[-group]}" "$file"
}

# is.sh - System predications

# is.virtual: Detect given virtualization
is.virtual() {
	if [[ $# -gt 0 ]]; then
		[[ "$(which.virtual)" = "$1" ]]
	else
		[[ -z ${CI:-} ]] || return 0
		[[ -z ${PACKER_BUILDER_TYPE:-} ]] || return 0

		is.docker && return 0

		systemd-detect-virt -q
	fi
}

# is.debian: Detect Debian or its given release
is.debian() {
	if [[ $# -gt 0 ]]; then
		[[ "$(which.codename)" = "$1" ]]
	else
		[[ "$(which.distribution)" = 'debian' ]]
	fi
}

# is.ubuntu: Detect Ubuntu or its given release
is.ubuntu() {
	if [[ $# -gt 0 ]]; then
		[[ "$(which.codename)" = "$1" ]]
	else
		[[ "$(which.distribution)" = 'ubuntu' ]]
	fi
}

# which.sh - Show facts

# which.virtual: Which virtualization
which.virtual() {
	systemd-detect-virt
}

# which.distribution: Which distribution
which.distribution() {
	# shellcheck disable=1091
	(unset ID && . /etc/os-release 2>/dev/null && echo "$ID")
}

# which.codename: Which distribution release
which.codename() {
	lsb_release -sc
}

declare -Ag help=(
	['cry']='Print warning messages on standard error'
	['die']='Print error messages and exit failure'
	['bug']='Report bug and exit failure'
	['bye']='Print messages and exit successfully'
	['http get']='Get URL'
	['self version']='Print self version'
	['self name']='Print self name'
	['self path']='Print self path'
	['temp inside']='Execute command in temp dir and (optionally) move it elsewhere'
	['url dump']='TODO'
	['deb update']='Update Debian package index'
	['deb install']='Install Debian packages'
	['file install']='Install file from URL'
	['is virtual']='Detect given virtualization'
	['is debian']='Detect Debian or its given release'
	['is ubuntu']='Detect Ubuntu or its given release'
	['which virtual']='Which virtualization'
	['which distribution']='Which distribution'
	['which codename']='Which distribution release'
)

.usage() {
	local cmd

	cry "Usage:    $0 commands ..."
	cry "Commands:"

	# shellcheck disable=2154
	for cmd in "${!help[@]}"; do
		printf "\\t%-24s  %s\n" "$cmd" "${help[$cmd]}"
	done | sort >&2
}

.help() {
	if [[ $# -eq 0 ]]; then
		.usage
		die 'Help topic required.'
	fi

	local subject=${help["${*}"]:-}

	[[ -n ${subject:-} ]] || die "E: No help found: ${*}."
	bye "$subject"
}

declare -Ag command=(
	['cry']='cry'
	['die']='die'
	['bug']='bug'
	['bye']='bye'
	['http get']='http.get'
	['self version']='self.version'
	['self name']='self.name'
	['self path']='self.path'
	['temp inside']='temp.inside'
	['url dump']='url.dump'
	['deb update']='deb.update'
	['deb install']='deb.install'
	['file install']='file.install'
	['is virtual']='is.virtual'
	['is debian']='is.debian'
	['is ubuntu']='is.ubuntu'
	['which virtual']='which.virtual'
	['which distribution']='which.distribution'
	['which codename']='which.codename'
)

.dispatch() {
	local -a args=("$@")

	if [[ $# -eq 0 ]]; then
		.usage
		die 'Command required.'
	fi

	if [[ $1 = help ]]; then
		shift

		.help "$@"
		exit
	fi

	local -a try
	while [[ $# -gt 0 ]]; do
		try+=("$1")
		shift

		local key="${try[*]}"

		local func
		func=${command["$key"]:-}

		if [[ -n $func ]]; then
			"$func" "$@"
			return $?
		fi
	done

	die "No command found: ${args[*]}."
}

.source() {
	echo "UNDERSCORE=$(self.path)"
	echo
	cat <<'EOF'
.() {
	# prelude.sh - Standard prelude

	[ -n "${BASH_VERSION:-}"        ] || { echo >&2 'Bash required.';                         exit 1; }
	[[ ${BASH_VERSINFO[0]:-} -ge 4 ]] || { echo >&2 'Bash version 4 or higher required.';     exit 1; }
	[[ -x /usr/bin/apt-get         ]] || { echo >&2 'Only Debian and derivatives supported.'; exit 1; }

	set -Eeuo pipefail; shopt -s nullglob; [[ -z ${TRACE:-} ]] || set -x; unset CDPATH

	export LC_ALL=C.UTF-8 LANG=C.UTF-8

	declare -grx UNDERSCORE=$UNDERSCORE

	case ${1:-} in
	-root)
		[[ ${EUID:-} -eq 0 ]] || { echo >&2 'Root privileges required.'; exit 1; }
		shift
		;;
	esac

	_.die() {
		"$UNDERSCORE" die "$@"; exit $?
	}

	_.bye() {
		"$UNDERSCORE" bye "$@"; exit $?
	}

	_.bug() {
		"$UNDERSCORE" bug "$@"; exit $?
	}

	_.enter() {
		local dir

		if dir=$("$UNDERSCORE" enter "$@") && [[ -n $dir ]]; then
			pushd "$dir" &>/dev/null || exit
		fi
	}

	_.leave() {
		popd &>/dev/null || exit
	}

	unset -f "${FUNCNAME[0]}"
}

_() {
	local cmd=$1

	case $cmd in
	die|bye|bug|enter|leave) shift; _."$cmd" "$@" ;;
	*)                       "$UNDERSCORE" "$@"   ;;
	esac
}


. "$@"
EOF
}

.sourced() {
	if [[ $# -gt 0 ]]; then
		[[ $1 = src ]] && return 0 # source explicitly specified
	else
		[[ -t 1 ]] || return 0     # backticked or piped without args
	fi

	return 1
}

.init() {
	trap.setup
}

main() {
	if .sourced "$@"; then
		.source "$@"
	else
		.init
		.dispatch "$@"
	fi
}

[[ "${BASH_SOURCE[0]}" != "$0" ]] || main "$@"
