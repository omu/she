#!/usr/bin/env bash

# Standard prelude

[ -n "${BASH_VERSION:-}"        ] || { echo >&2 'Bash required.';                         exit 1; }
[[ ${BASH_VERSINFO[0]:-} -ge 4 ]] || { echo >&2 'Bash version 4 or higher required.';     exit 1; }
[[ -x /usr/bin/apt-get         ]] || { echo >&2 'Only Debian and derivatives supported.'; exit 1; }

set -Eeuo pipefail; shopt -s nullglob; [[ -z ${TRACE:-} ]] || set -x; unset CDPATH

export LC_ALL=C.UTF-8 LANG=C.UTF-8

# Core functions

# cry: Print warning messages on standard error
cry() {
	local message

	for message; do
		echo >&2 "$message"
	done
}

# die: Print error messages and exit failure
die() {
	local message

	for message; do
		echo >&2 "E: $message"
	done

        exit 1
}

# bug: Report bug and exit failure
bug() {
	local message

	for message; do
		echo >&2 "B: ${BASH_LINENO[0]}: $message"
	done

	exit 127
}

# fin: Print messages and exit successfully
fin() {
	cry "$@"
	exit 0
}

# Command must success
must() {
	"$@" || die "Command failed: $*"
}

# Command may fail
might() {
	"$@" || cry "Exit code $? is suppressed: $*"
}

# Announce constant (readonly) environment variable
const() {
	local export=

	while [[ $# -gt 0 ]]; do
		case $1 in
		-x|-export|--export)
			export=
			shift
			;;
		-*)
			die "Unrecognized flag: $1"
			;;
		*)
			break
			;;
		esac
	done

	local -n variable_=$1
	shift

	local value_
	for value_; do
		if [[ -n $value_ ]]; then
			# shellcheck disable=2034
			variable_=$value_

			declare -gr "${!variable_}"
			[[ -z ${export:-} ]] || export "${!variable_}"

			break
		fi
	done
}

# Ensure that the directory pointed by given environment variable exists
ensured() {
	local -n variable_=$1

	[[ -n ${!variable_} ]] || die "Blank environment value found: $variable_"
	must mkdir -p "${!variable_}"
}

# Initialize underscore system

.() {
	# Program name
	const PROGNAME "${0##*/}"

	# Core environment
	if [[ ${EUID:-} -eq 0 ]]; then
		local etc=/usr/local/etc/_
		[[ ! $PROGNAME =~ /usr/bin ]] || etc=/etc/_

		const _SRC_DIR        "${UNDERSCORE_SRC_DIR:-}"   "${SRCDIR:-}"   /run/_/src
		const _TMP_DIR        "${UNDERSCORE_TMP_DIR:-}"   "${TMPDIR:-}"   /run/_/tmp
		const _ETC_DIR        "${UNDERSCORE_ETC_DIR:-}"   "${ETCDIR:-}"   "$etc"
		const _CACHE_DIR      "${UNDERSCORE_CACHE_DIR:-}" "${CACHEDIR:-}" /run/_/cache
		const _VAR_DIR        "${UNDERSCORE_VAR_DIR:-}"   "${VARDIR:-}"   /run/_/var
	else
		const XDG_RUNTIME_DIR "${XDG_RUNTIME_DIR:-}"      /run/"$EUID"
		const XDG_CONFIG_HOME "${XDG_CONFIG_HOME:-}"      "$HOME"/.config
		const XDG_CACHE_HOME  "${XDG_CACHE_HOME:-}"       "$HOME"/.cache

		const _SRC_DIR        "${UNDERSCORE_SRC_DIR:-}"   "${SRCDIR:-}"   "$HOME"/.local/src
		const _TMP_DIR        "${UNDERSCORE_TMP_DIR:-}"   "${TMPDIR:-}"   "$XDG_RUNTIME_DIR"/_/tmp
		const _ETC_DIR        "${UNDERSCORE_ETC_DIR:-}"   "${ETCDIR:-}"   "$XDG_CONFIG_HOME"/_
		const _CACHE_DIR      "${UNDERSCORE_CACHE_DIR:-}" "${CACHEDIR:-}" "$XDG_CACHE_HOME"/_
		const _VAR_DIR        "${UNDERSCORE_VAR_DIR:-}"   "${VARDIR:-}"   "$XDG_RUNTIME_DIR"/_/var
	fi

	unset -f "${FUNCNAME[0]}"
}

. # init

# Functions related to program itself

# self.version: Print self version
self.version() {
	echo 0.0
}

# self.name: Print self name
self.name() {
	echo she
}

# self.path: Print self path
self.path() {
	local self

	self=${BASH_SOURCE[0]}
	case $self in
	./*) readlink -f "$self" ;;
	/*)  echo "$self" ;;
	*)   readlink -f "$(command -v "$self")" ;;
	esac
}

self.usage() {
	local message

	for message;  do
		echo >&2 "$message"
	done

	echo >&2 "Usage: $(self.path) CMD [ARGS]..."
	exit 1
}

# Meta functions

meta.public() {
	if [[ $1 =~ (^_|_$) ]]; then
		bug "Not a simple name: $1"
	else
		echo "$1"
	fi
}

meta.print() {
	while [[ $# -gt 0 ]]; do
		# shellcheck disable=2178,2155
		local -n variable_=$(meta.public "$1")

		echo "${!variable_}"

		local key_
		for key_ in "${!variable_[@]}"; do
			printf '  %-16s  %s\n' "${key_}" "${variable_[$key_]}"
		done | sort
		echo

		shift
	done
}

meta.narg() {
	local lower=$1 upper=$2
	shift 2

	[[ $# -ge $lower                                 ]] || bug "Too few arguments: $*"
	[[ -n $upper && $upper != - && $upper -le $upper ]] || bug "Too many arguments: $*"
}

# Trap setup

declare -ag _at_exit_funcs_=()

declare -ag _at_exit_files_=()

# Register hooks at exit
at_exit() {
	local arg

	for arg; do
		[[ $(type -t "$arg" || true) == function ]] || bug "Not a function: $arg"
	done

	_at_exit_funcs_=("$@" "${_at_exit_funcs_[@]}")
}

# Register files/directories to clean up at exit
at_exit_files() {
	_at_exit_files_+=("$@")
}

_exit_() {
	local err=$?

	local func
	for func in "${_at_exit_funcs_[@]}"; do
		"$func" || cry "Exit hook failed: $func"
	done

	return "$err"
}

# Prevent using trap
trap() {
	bug 'Using trap is forbidden; please use at_exit to register hooks.'
}

_at_exit_cleanup_() {
	[[ ${#_at_exit_files_[@]} -gt 0 ]] || return 0

	rm -rf -- "${_at_exit_files_[@]}"
}

# shellcheck disable=2120
trap.setup() {
	local -a signals=(EXIT HUP INT QUIT TERM)

	[[ $# -eq 0 ]] || signals=("$@")

	# shellcheck disable=2154,2218
	builtin trap _exit_ "${signals[@]}"

	at_exit _at_exit_cleanup_
}

# Functions involving temporary directories or files

temp.file() {
	# shellcheck disable=2155
	local -n variable_=$(meta.public "$1")

	ensured _TMP_DIR

	local file_

	file_=$(mktemp -p "$_TMP_DIR" "$PROGNAME".XXXXXXXX) || die 'Fatal error: mktemp'
	at_exit_files "$file_"

	# shellcheck disable=2034
	variable_=$file_
}

temp.dir() {
	# shellcheck disable=2155
	local -n variable_=$(meta.public "$1")

	ensured _TMP_DIR

	local dir_
	dir_=$(mktemp -p "$_TMP_DIR" -d "$PROGNAME".XXXXXXXX) || die 'Fatal error: mktemp'
	at_exit_files "$dir_"

	# shellcheck disable=2034
	variable_=$dir_
}

# temp.inside: Execute command in temp dir and (optionally) move it elsewhere
temp.inside() {
	local outdir='' parents=''

	while [[ $# -gt 0 ]]; do
		case $1 in
		-outside|-out|-o|--outside|--out)
			[[ $# -gt 1 ]] || die "Argument required for flag: $1"
			shift

			outdir=$1
			shift
			;;
		-p|-parents|--parents)
			parents=true
			shift
			;;
		-*)
			die "Unrecognized flag: $1"
			;;
		*)
			break
			;;
		esac
	done

	meta.narg 1 - "$@"

	if [[ -z $parents ]]; then
		[[ -d $outdir ]] || die "Outside directory must exist: $outdir"
		[[ -w $outdir ]] || die "Outside directory must be writable: $outdir"
	else
		[[ -n $outdir ]] || die 'No outside directory specified'
	fi

	local origdir=$PWD

	local tempdir
	temp.dir tempdir

	must cd "$tempdir"
	"$@"
	must cd "$origdir"

	if [[ -n $outdir  ]]; then
		[[ -z $parents ]] || must mkdir -p "$outdir"
		cp -aT "$tempdir" "$outdir"
	fi

	rm -rf -- "$tempdir"
}

# Array functions

# array.join: Join array with the given separator
array.join() {
	local IFS=$1
	shift

	echo "$*"
}

# Parse URL

url.parse() {
	local prefix_=.
	while [[ $# -gt 0 ]]; do
		case $1 in
		-prefix|--prefix)
			[[ $# -gt 1 ]] || die "Argument required for flag: $1"
			shift

			prefix_=$1
			shift
			;;
		-*)
			die "Unrecognized flag: $1"
			;;
		*)
			break
			;;
		esac
	done

	meta.narg 2 3 "$@"

	local given_=$1
	shift

	# shellcheck disable=2178,2155
	local -n remote_=$(meta.public "$1")
	shift

	# shellcheck disable=2178,2155
	[[ $# -eq 0 ]] || local -n local_=$(meta.public "$1")

	local protocol_ url_

	protocol_=
	case $given_ in
	*://*)
		protocol_=${given_%%:*}
		url_=${given_#*://}
		;;
	/*|./*)
		protocol_='file'
		url_=$(readlink -m "$given_")
		;;
	*)
		url_=$given_
		;;
	esac

	if [[ $protocol_ == file ]]; then
		remote_=(
			[protocol]=$protocol_
			[path]=$url_
		)
		return 0
	elif [[ -z $protocol_ ]]; then
		protocol_=https
	fi

	local provider_ owner_ repo_ slug_

	if ! IFS='/' read -r provider_ owner_ repo_ slug_ <<<"$url_"; then
		cry "Parse error at $given_"
		return 1
	fi

	[[ -n ${owner_:-} ]] || cry "Missing owner at $given_"
	[[ -n ${repo_:-}  ]] || cry "Missing repository at $given_"

	local auth_=
	if [[ $protocol_ == https ]] && [[ -n ${HTTPS_TOKEN:-} ]]; then
		auth_="${HTTPS_TOKEN}:x-oauth-basic"
	fi

	local base_
	if [[ -z $auth_ ]]; then
		base_=$protocol_://$provider_/$owner_
	else
		base_=$protocol_://$auth_@$provider_/$owner_
	fi

	local git_=$base_/$repo_.git
	[[ ${provider_:-} =~ (github.com|gitlab.com|bitbucket.com) ]] || git_=

	# shellcheck disable=2034
	remote_=(
		[auth]=$auth_
		[base]=$base_
		[canonic]=$base_/$repo_/$slug_
		[git]=$git_
		[namespace]=$provider_/$owner_
		[owner]=$owner_
		[path]=$provider_/$owner_/$repo_
		[protocol]=$protocol_
		[provider]=$provider_
		[repo]=$repo_
		[slug]=$slug_
	)

	# shellcheck disable=2034
	[[ $# -eq 0 ]] || local_=(
		[path]=$prefix_/$provider_/$owner_/$repo_
		[prefix]=$prefix_
		[namespace]=$prefix_/$provider_/$owner_
	)
}

url.is_git() {
	# shellcheck disable=2178,2155
	local -n remote_=$(meta.public "$1")

	[[ -n ${remote_[git]:-} ]]
}
#
# url.test() {
# 	# shellcheck disable=2034
# 	local -A there here
#
# 	url.parse -prefix /usr/local/src "$@" there here
#
# 	meta.print there
# 	meta.print here
#
# 	if url.is_git there; then
# 		echo OK
# 	else
# 		echo NOTOK
# 	fi
# }
#
# url.test "$@"
# exit

# Git functions

git.must_sane() {
	git rev-parse --is-inside-work-tree &>/dev/null || die "Must be inside a git work tree: $PWD"
	git rev-parse --verify HEAD >/dev/null          || die "Unverified git HEAD: $PWD"
}

git.is_clean() {
	git rev-parse --verify HEAD >/dev/null &&
	git update-index -q --ignore-submodules --refresh &&
	git diff-files --quiet --ignore-submodules &&
	git diff-index --cached --quiet --ignore-submodules HEAD --
}

git.must_clean() {
	git.is_clean || die "Must be a clean git work tree: $PWD"
}

git.topdir() {
	local dir

	dir=$(git rev-parse --git-dir) && dir=$(cd "$dir" && pwd)/ && echo "${dir%%/.git/*}"
}

git.top() {
	git.must_sane

	must cd "$(git.topdir)"
}

# git.get: Get (clone or update) Git repository
git.get() {
	local prefix=${_SRC_DIR:-} branch='' shallow=''

	while [[ $# -gt 0 ]]; do
		case $1 in
		-prefix|--prefix)
			[[ $# -gt 1 ]] || die "Argument required for flag: $1"
			shift

			prefix=$1
			[[ -d $prefix ]] || die "Prefix directory not found: $prefix"
			shift
			;;
		-branch|--branch)
			[[ $# -gt 1 ]] || die "Argument required for flag: $1"
			shift

			branch=$1
			shift
			;;
		-shallow|--shallow)
			shallow=true
			;;
		-*)
			die "Unrecognized flag: $1"
			;;
		*)
			break
			;;
		esac
	done

	meta.narg 1 1 "$@"

	# shellcheck disable=2034
	local -A remote local
	url.parse -prefix "${prefix:-.}" "$1" remote local

	local repo=${local[path]}

	if [[ ! -d $repo ]]; then
		local -a args=(git clone --quiet)

		[[ -z $branch  ]] || args+=(--branch "$branch")
		[[ -z $shallow ]] || args+=(--depth 1)

		args+=("${remote[git]}")

		local -a flags
		[[ -z $prefix ]] || flags=(-outside "${local[namespace]}" -parents)

		temp.inside "${flags[@]}" "${args[@]}"

		must cd "$repo"
	else
		must cd "$repo"

		git.must_clean
		git checkout "${branch:-master}"
		git pull origin "${branch:-master}"
	fi
}

# Debian package management

export DEBIAN_FRONTEND=noninteractive APT_KEY_DONT_WARN_ON_DANGEROUS_USAGE=DontWarn

# deb.update: Update Debian package index
deb.update() {
	[[ -n $(find /var/cache/apt/pkgcache.bin -mmin -60 2>/dev/null) ]] || apt-get update
}

# deb.install: Install Debian packages
deb.install() {
	deb.update

	[[ $# -eq 0 ]] || apt-get -y install --no-install-recommends "$@"
}

# File related operations

# bin: Install executable from URL
file.bin() {
	curl -fsSL -o "$2" "$1" && chmod +x "$2"
}

# enter: Get files from URL and chdir to directory
file.enter() {
	local source=$1

	local -A url

	url.parse url "$source"

	local path
	if [[ ${url[protocol]:-} == file ]] ||[[ -n ${FROM_TO:-} ]]; then
		if [[ -n ${FROM_TO:-} ]]; then
			path=$FROM_TO
		else
			path=${url[path]}
		fi
		[[ -d $path ]] || die "No directory: $path"
		cd "$path"     || die "Chdir error: $path"
	elif [[ -n ${url[protocol]:-} ]]; then
		file.tempdir path

		local addr=${url[path]}
		[[ -z ${url[auth]:-} ]] || addr="${url[auth]}@${addr}"
		addr="${url[protocol]}://${addr}"

		cd "$path" || die "Chdir error: $path"

		file.get "$addr"
	else
		die "No protocol found at:$1"
	fi

	if [[ -n ${url[slug]:-} ]]; then
		local slug=${url[slug]}

		[[ -d $slug ]] || die "No directory: $slug"
		cd "./$slug"   || die "Chdir error: $slug"
	fi

	[[ -z ${tmpdir:-} ]] || echo "$tmpdir" >"${SHE_SHIBBOLETH:-.she}"
}

file.get() {
	local source=$1

	local -A url
	url.parse url

	local tempdir
	file.tempdir tempdir
}

file.moveable() {
	:
}

file.move() {
	mv -f "$@"
}

# System predications

# is.virtual: Detect given virtualization
is.virtual() {
	if [[ $# -gt 0 ]]; then
		[[ "$(which.virtual)" = "$1" ]]
	else
		[[ -z ${CI:-} ]] || return 0
		[[ -z ${PACKER_BUILDER_TYPE:-} ]] || return 0

		is.docker && return 0

		systemd-detect-virt -q
	fi
}

# is.debian: Detect Debian or its given release
is.debian() {
	if [[ $# -gt 0 ]]; then
		[[ "$(which.codename)" = "$1" ]]
	else
		[[ "$(which.distribution)" = 'debian' ]]
	fi
}

# is.ubuntu: Detect Ubuntu or its given release
is.ubuntu() {
	if [[ $# -gt 0 ]]; then
		[[ "$(which.codename)" = "$1" ]]
	else
		[[ "$(which.distribution)" = 'ubuntu' ]]
	fi
}

# Show facts

# which.virtual: Which virtualization
which.virtual() {
	systemd-detect-virt
}

# which.distribution: Which distribution
which.distribution() {
	# shellcheck disable=1091
	(unset ID && . /etc/os-release 2>/dev/null && echo "$ID")
}

# which.codename: Which distribution release
which.codename() {
	lsb_release -sc
}

declare -Ag help=(
	['cry']='Print warning messages on standard error'
	['die']='Print error messages and exit failure'
	['bug']='Report bug and exit failure'
	['fin']='Print messages and exit successfully'
	['self version']='Print self version'
	['self name']='Print self name'
	['self path']='Print self path'
	['temp inside']='Execute command in temp dir and (optionally) move it elsewhere'
	['array join']='Join array with the given separator'
	['git get']='Get (clone or update) Git repository'
	['deb update']='Update Debian package index'
	['deb install']='Install Debian packages'
	['bin']='Install executable from URL'
	['enter']='Get files from URL and chdir to directory'
	['is virtual']='Detect given virtualization'
	['is debian']='Detect Debian or its given release'
	['is ubuntu']='Detect Ubuntu or its given release'
	['which virtual']='Which virtualization'
	['which distribution']='Which distribution'
	['which codename']='Which distribution release'
)

.usage() {
	local cmd

	ui.cry "Usage:    $0 commands ..."
	ui.cry "Commands:"

	# shellcheck disable=2154
	for cmd in "${!help[@]}"; do
		printf "\\t%-24s  %s\n" "$cmd" "${help[$cmd]}"
	done | sort >&2
}

.help() {
	if [[ $# -eq 0 ]]; then
		.usage
		ui.die 'E: Help topic required.'
	fi

	local subject=${help["${*}"]:-}

	[[ -n ${subject:-} ]] || ui.die "E: No help found: ${*}."
	ui.fin "$subject"
}

declare -Ag command=(
	['cry']='cry'
	['die']='die'
	['bug']='bug'
	['fin']='fin'
	['self version']='self.version'
	['self name']='self.name'
	['self path']='self.path'
	['temp inside']='temp.inside'
	['array join']='array.join'
	['git get']='git.get'
	['deb update']='deb.update'
	['deb install']='deb.install'
	['bin']='file.bin'
	['enter']='file.enter'
	['is virtual']='is.virtual'
	['is debian']='is.debian'
	['is ubuntu']='is.ubuntu'
	['which virtual']='which.virtual'
	['which distribution']='which.distribution'
	['which codename']='which.codename'
)

.dispatch() {
	local -a args=("$@")

	if [[ $# -eq 0 ]]; then
		.usage
		ui.die 'Command required.'
	fi

	if [[ $1 = help ]]; then
		shift

		.help "$@"
		exit
	fi

	local -a try
	while [[ $# -gt 0 ]]; do
		try+=("$1")
		shift

		local key="${try[*]}"

		local func
		func=${command["$key"]:-}

		if [[ -n $func ]]; then
			"$func" "$@"
			return $?
		fi
	done

	ui.die "No command found: ${args[*]}."
}

.source() {
	echo "UNDERSCORE=$(self.path)"
	echo
	cat <<'EOF'
.() {
	# Standard prelude
	
	[ -n "${BASH_VERSION:-}"        ] || { echo >&2 'Bash required.';                         exit 1; }
	[[ ${BASH_VERSINFO[0]:-} -ge 4 ]] || { echo >&2 'Bash version 4 or higher required.';     exit 1; }
	[[ -x /usr/bin/apt-get         ]] || { echo >&2 'Only Debian and derivatives supported.'; exit 1; }
	
	set -Eeuo pipefail; shopt -s nullglob; [[ -z ${TRACE:-} ]] || set -x; unset CDPATH
	
	export LC_ALL=C.UTF-8 LANG=C.UTF-8

	declare -grx UNDERSCORE=$UNDERSCORE

	case ${1:-} in
	-root)
		[[ ${EUID:-} -eq 0 ]] || { echo >&2 'Root privileges required.'; exit 1; }
		shift
		;;
	esac

	_.die() {
		"$UNDERSCORE" die "$@"; exit $?
	}

	_.fin() {
		"$UNDERSCORE" fin "$@"; exit $?
	}

	_.bug() {
		"$UNDERSCORE" fin "$@"; exit $?
	}

	_.enter() {
		local dir

		if dir=$("$UNDERSCORE" enter "$@") && [[ -n $dir ]]; then
			pushd "$dir" &>/dev/null || exit
		fi
	}

	_.leave() {
		popd &>/dev/null || exit
	}

	unset -f "${FUNCNAME[0]}"
}

_() {
	local cmd=$1

	case $cmd in
	die|fin|bug|enter|leave) shift; _."$cmd" "$@" ;;
	*)                       "$UNDERSCORE" "$@"   ;;
	esac
}


. "$@"
EOF
}

.sourced() {
	if [[ $# -gt 0 ]]; then
		[[ $1 = src ]] && return 0 # source explicitly specified
	else
		[[ -t 1 ]] || return 0     # backticked or piped without args
	fi

	return 1
}

.init() {
	trap.setup
}

main() {
	if .sourced "$@"; then
		.source "$@"
	else
		.init
		.dispatch "$@"
	fi
}

[[ "${BASH_SOURCE[0]}" != "$0" ]] || main "$@"
