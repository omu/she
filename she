#!/usr/bin/env bash

# prelude.sh - Standard prelude

[ -n "${BASH_VERSION:-}"        ] || { echo >&2 'Bash required.';                         exit 1; }
[[ ${BASH_VERSINFO[0]:-} -ge 4 ]] || { echo >&2 'Bash version 4 or higher required.';     exit 1; }
[[ -x /usr/bin/apt-get         ]] || { echo >&2 'Only Debian and derivatives supported.'; exit 1; }

set -Eeuo pipefail; shopt -s nullglob; [[ -z ${TRACE:-} ]] || set -x; unset CDPATH; IFS=$' \t\n'

export LC_ALL=C.UTF-8 LANG=C.UTF-8

# kernel.sh - Core functions

say() {
	if [[ $# -eq 0 ]]; then
		echo >&2 ""
	else
		local message

		for message; do
			echo -e >&2 "$message"
		done
	fi
}

cry() {
	if [[ $# -eq 0 ]]; then
		echo >&2 ""
	else
		local message

		for message; do
			echo -e >&2 "W: $message"
		done
	fi
}

die-() {
	if [[ $# -eq 0 ]]; then
		echo >&2 ""
	else
		local message

		for message; do
			echo -e >&2 "E: $message"
		done
	fi
}

die() {
	die- "$@"

	exit 1
}

bug-() {
	if [[ $# -eq 0 ]]; then
		echo >&2 ""
	else
		local message

		for message; do
			echo -e >&2 "B: $message"
		done
	fi
}

bug() {
	bug- "$@"

	exit 127
}

bye() {
	if [[ $# -eq 0 ]]; then
		echo >&2 ""
	else
		local message

		for message; do
			echo -e >&2 "$message"
		done
	fi

	exit 0
}

hey() {
	if [[ $# -eq 0 ]]; then
		echo >&2 ""
	else
		local message

		for message; do
			echo -e >&2 "\\e[38;5;14m-->\\e[0m\\e[1m $message\\e[0m"
		done
	fi
}

hmm() {
	while [[ $# -gt 0 ]]; do
		# shellcheck disable=2178,2155
		local -n hmm_=$1

		echo "${!hmm_}"

		local key
		for key in "${!hmm_[@]}"; do
			printf '  %-16s  %s\n' "${key}" "${hmm_[$key]}"
		done | sort
		echo

		shift
	done
}

bool() {
	local value=${1:-}

	value=${value,,}

	case $value in
	true|t|1|on|yes|y)
		return 0
		;;
	false|f|0|off|no|n|"")
		return 1
		;;
	*)
		bug "Invalid boolean: $value"
	esac
}

available() {
	command -v "$1" &>/dev/null
}

callable() {
	local name=${1?${FUNCNAME[0]}: missing argument}; shift

	[[ $(type -t "$name" || true) == function ]]
}

piped() {
	[[ ! -t 0 ]]
}

interactive() {
	[[ ! -t 1 ]]
}

included() {
	local needle=${1?${FUNCNAME[0]}: missing argument}; shift

	local element
	for element; do
		if [[ $element = "$needle" ]]; then
			return 0
		fi
	done

	return 1
}

expired() {
	local -i expiry=${1?${FUNCNAME[0]}: missing argument}; shift

	[[ $expiry -gt 0 ]] || return 1

	local file
	for file; do
		if [[ -e $file ]] && [[ -z $(find "$file" -mmin +"$expiry" 2>/dev/null) ]]; then
			return 1
		fi
	done

	return 0
}

# Initialize underscore system

# shellcheck disable=2034
.() {
	# Program name
	declare -ag PROGNAME=("${0##*/}")

	# Core environment
	if [[ ${EUID:-} -eq 0 ]]; then
		readonly _RUN=${UNDERSCORE_VOLATILE_PREFIX:-/run/_}
		readonly _USR=${UNDERSCORE_PERSISTENT_PREFIX:-/usr/local}
		readonly _ETC=/etc/_:"$_USR"/etc/_:"$_RUN"/etc
	else
		XDG_RUNTIME_DIR=${XDG_RUNTIME_DIR:-/run/"$EUID"}
		XDG_CONFIG_HOME=${XDG_CONFIG_HOME:-"$HOME"/.config}
		XDG_CACHE_HOME=${XDG_CACHE_HOME:-"$HOME"/.cache}

		readonly _RUN=${UNDERSCORE_VOLATILE_PREFIX:-"$XDG_RUNTIME_DIR"/_}
		readonly _USR=${UNDERSCORE_PERSISTENT_PREFIX:-"$HOME"/.local}
		readonly _ETC=/etc/_:"$XDG_CONFIG_HOME"/_:"$_RUN"/etc
	fi

	export PATH="$_RUN"/bin:"$PATH"

	unset -f "${FUNCNAME[0]}"
}

# init
.

# _.sh - Default result variable

declare -gA _=()

_.read() {
	local -i i=1

	while [[ $# -gt 0 ]]; do
		local key value

		if [[ $1 =~ ^-*[[:alpha:]_][[:alnum:]_]*= ]]; then
			key=${1%%=*}; value=${1#*=}
		elif [[ $1 == '--' ]]; then
			shift
			break
		else
			key=$((i++)); value=$1
		fi

		_["$key"]=${value:-${_["$key"]:-}}

		shift
	done
}

_.load() {
	# shellcheck disable=2034
	local -n _load_src_=${1?${FUNCNAME[0]}: missing argument}; shift

	array.dup _ _load_src_
}

_.values() {
	local pattern=${1?${FUNCNAME[0]}: missing argument}; shift

	local -a keys

	mapfile -t keys < <(
		for key in "${!_[@]}"; do
			[[ $key =~ $pattern ]] || continue

			echo "$key"
		done | sort -u
	)

	local key

	if [[ $# -gt 0 ]]; then
		local -n _values_=$1

		for key in "${keys[@]}"; do
			_values_+=("${_[$key]}")
		done

		_values_=("${_values_[@]}")
	else
		for key in "${keys[@]}"; do
			echo "${_[$key]}"
		done
	fi
}

_.dump() {
	hmm _
}

# flag.sh - Flag handling

shopt -s expand_aliases

# shellcheck disable=2142
alias flag.parse='flag.parse_ "$@"; local -a __a; flag.args_ __a; set -- "${__a[@]}"; unset -v __a'

flag.usage_() {
	if [[ -n ${_[.help]:-} ]]; then
		# shellcheck disable=2128
		say "Usage: ${PROGNAME[*]} ${_[.help]}"
	else
		# shellcheck disable=2128
		say "Usage: ${PROGNAME[*]}"
	fi

	[[ $# -gt 0 ]] || return 0

	exit "$1"
}

# shellcheck disable=2034
flag.parse_() {
	if included -help "$@"; then
		flag.usage_ 0
	fi

	local -A flag_result_

	local -i argc=0
	while [[ $# -gt 0 ]]; do
		local key value

		if [[ $1 =~ ^-*[[:alpha:]_][[:alnum:]_]*= ]]; then
			key=${1%%=*}; value=${1#*=}
			if [[ $key =~ ^-.+$ ]] && [[ ! -v _[$key] ]]; then
				die "Unrecognized flag: $key"
			fi
		elif [[ $1 == '--' ]]; then
			shift
			break
		else
			key=$((++argc)); value=$1
		fi

		flag_result_["$key"]=${value:-${_["$key"]:-}}

		shift
	done

	flag._post_ $argc

	_.load flag_result_
}

flag.args_() {
	_.values '^[1-9][0-9]*$' "$@"
}

flag.env_() {
	_.values '^[[:alpha:]_][[:alnum:]_]*$' "$@"
}

flag.true() {
	bool "${_[-$1]:-}"
}

flag.false() {
	! flag.true "$@"
}

flag.dump() {
	_.dump
}

flag._post_() {
	local n=${1?missing argument}

	local argc=${_[.argc]:-0}

	[[ $argc != '-' ]] || return 0

	local lo hi

	if [[ $argc =~ ^[0-9]+$ ]]; then
		lo=$argc; hi=$argc
	elif [[ $argc =~ ^[0-9]*-[0-9]*$ ]]; then
		IFS=- read -r lo hi <<<"$argc"
	else
		bug "Incorrect range: $argc"
	fi

	if   [[ -n ${lo:-} ]] && [[ $n -lt $lo ]]; then
		die- 'Too few arguments'
	elif [[ -n ${hi:-} ]] && [[ $n -gt $hi ]]; then
		die- 'Too many arguments'
	else
		return 0
	fi

	flag.usage_ 1
}

# ui.sh - UI functions

# say: Print messages on standard error
ui.say() {
	local -A _=(
		[.help]='[MESSAGE...]'
		[.argc]=0-
	)

	flag.parse

	ui._plain "$@"
}

# die: Print error messages and exit failure
ui.die() {
	local -A _=(
		[-unexit]=false
		[.help]='[-unexit=BOOL [MESSAGE...]]'
		[.argc]=0-
	)

	flag.parse

	ui._error "$@"

	flag.true unexit || exit 1
}

# cry: Print warning messages on standard error
ui.cry() {
	local -A _=(
		[.help]='[MESSAGE...]'
		[.argc]=0-
	)

	flag.parse

	ui._warning "$@"
}

# bug: Report bug and exit failure
ui.bug() {
	local -A _=(
		[-unexit]=false
		[.help]='[-unexit=BOOL [MESSAGE...]]'
		[.argc]=0-
	)

	flag.parse

	ui._bug "$@"

	flag.true unexit || exit 127
}

# hey: Print messages taking attention
ui.hey() {
	local -A _=(
		[.help]='[MESSAGE...]'
		[.argc]=0-
	)

	flag.parse

	ui._hey "$@"
}

ui._plain() {
	local message

	for message; do
		echo -e >&2 "$message"
	done
}

ui._error() {
	local message

	for message; do
		echo -e >&2 "E: $message"
	done
}

ui._warning() {
	local message

	for message; do
		echo -e >&2 "W: $message"
	done
}

ui._bug() {
	local message

	for message; do
		echo -e >&2 "B: $message"
	done
}

ui._hey() {
	local message

	for message; do
		echo -e >&2 "\\e[38;5;14m-->\\e[0m\\e[1m $message\\e[0m"
	done
}

# must.sh - Guard functions

# Test -e
must.e() {
	local arg=${1?${FUNCNAME[0]}: missing argument}; shift
	local message=${1:-"No such file or directory: $arg"}

	[[ -e $arg ]] || die "$message"
}

# Test -f
must.f() {
	local arg=${1?${FUNCNAME[0]}: missing argument}; shift
	local message=${1:-"No such file: $arg"}

	[[ -f $arg ]] || die "$message"
}

# Test -d
must.d() {
	local arg=${1?${FUNCNAME[0]}: missing argument}; shift
	local message=${1:-"No such directory: $arg"}

	[[ -d $arg ]] || die "$message"
}

# Test -x
must.x() {
	local arg=${1?${FUNCNAME[0]}: missing argument}; shift
	local message=${1:-"Not executable: $arg"}

	[[ -x $arg ]] || die "$message"
}

# Test -r
must.r() {
	local arg=${1?${FUNCNAME[0]}: missing argument}; shift
	local message=${1:-"No such file: $arg"}

	[[ -r $arg ]] || die "$message"
}

# Test -w
must.w() {
	local arg=${1?${FUNCNAME[0]}: missing argument}; shift
	local message=${1:-"No such file: $arg"}

	[[ -w $arg ]] || die "$message"
}

# Test -n
must.n() {
	local arg=${1?${FUNCNAME[0]}: missing argument}; shift
	local message=${1:-"Empty value: $arg"}

	[[ -n $arg ]] || die "$message"
}

# Test -z
must.z() {
	local arg=${1?${FUNCNAME[0]}: missing argument}; shift
	local message=${1:-"Empty value: $arg"}

	[[ -z $arg ]] || die "$message"
}

# Must be root
must.root() {
	[[ ${EUID:-} -eq 0 ]]
}

# Command must success
must.success() {
	"$@" || die "Command failed: $*"
}

# Command may fail but must proceed
must.proceed() {
	"$@" || cry "Exit code $? is suppressed: $*"
}

# Condition must be true
must.true() {
	local message=${1?${FUNCNAME[0]}: missing argument}; shift

	"$@" || die "$message"
}

# Condition must be false
must.false() {
	local message=${1?${FUNCNAME[0]}: missing argument}; shift

	"$@" && die "$message"
}

# Program must exist
must.available() {
	local arg=${1?${FUNCNAME[0]}: missing argument}; shift
	local message=${1:-"No program found: $arg"}

	command -v "$arg" &>/dev/null || die "$message"
}

# Function must exist
must.callable() {
	local arg=${1?${FUNCNAME[0]}: missing argument}; shift
	local message=${1:-"No function found: $arg"}

	callable "$arg" || die "$message"
}

# Stdin must exist
# shellcheck disable=2120
must.piped() {
	local message=${1:-'No stdin data found'}

	piped || die "$message"
}

# Stdout must exist
must.interactive() {
	local message=${1:-'No stdout found'}

	interactive || die "$message"
}

# self.sh - Functions related to program itself

# self.version: Print self version
self.version() {
	local -A _; flag.parse

	echo 0.0
}

# self.name: Print self name
self.name() {
	local -A _; flag.parse

	# shellcheck disable=2128
	echo "$PROGNAME"
}

# self.path: Print self path
# shellcheck disable=2120
self.path() {
	local -A _; flag.parse

	local self

	self=${BASH_SOURCE[0]}
	case $self in
	./*) readlink -f "$self" ;;
	/*)  echo "$self" ;;
	*)   readlink -f "$(command -v "$self")" ;;
	esac
}

# self.install: Install self
self.install() {
	# shellcheck disable=2192,2128
	local -A _=(
		[-prefix]="$_USR"/bin
		[-name]=$PROGNAME

		[.help]=
		[.argc]=0
	)

	flag.parse

	_[1]=$(self.path)

	bin.install_
}

# string.sh - String manipulation

string.has_prefix_deleted() {
	local -n string_has_prefix_deleted_=${1?${FUNCNAME[0]}: missing argument}; shift
	local    prefix=${1?${FUNCNAME[0]}: missing argument};                     shift

	if [[ $string_has_prefix_deleted_ =~ ^$prefix ]]; then
		string_has_prefix_deleted_=${string_has_prefix_deleted_#$prefix}

		return 0
	fi

	return 1
}

string.delete_prefix() {
	string.has_prefix_deleted "$@" || :
}

string.has_suffix_deleted() {
	local -n string_has_suffix_deleted_=${1?${FUNCNAME[0]}: missing argument}; shift
	local    suffix=${1?${FUNCNAME[0]}: missing argument};                     shift

	if [[ $string_has_suffix_deleted_ =~ $suffix$ ]]; then
		string_has_suffix_deleted_=${string_has_suffix_deleted_%$suffix}

		return 0
	fi

	return 1
}

string.delete_suffix() {
	string.has_suffix_deleted "$@" || :
}

# array.sh - Array functions

# Join array with the given separator
array.join() {
	local IFS=${1?${FUNCNAME[0]}: missing argument}; shift

	echo "$*"
}
# Duplicate array
array.dup() {
	local -n array_dup_lhs_=${1?${FUNCNAME[0]}: missing argument}; shift
	local -n array_dup_rhs_=${1?${FUNCNAME[0]}: missing argument}; shift

	local key
	for key in "${!array_dup_rhs_[@]}"; do
		# shellcheck disable=2034
		array_dup_lhs_[$key]=${array_dup_rhs_[$key]}
	done
}

# The element included in the given array
array.included() {
	local -n array_included_=${1?${FUNCNAME[0]}: missing argument}; shift
	local    element=${1?${FUNCNAME[0]}: missing argument};         shift

	included "$element" "${array_included_[@]}"
}

# path.sh - Path management

path.is.volatile() {
	local path=${1?${FUNCNAME[0]}: missing argument}; shift

	df -t tmpfs "$path" &>/dev/null
}

path.is.equal() {
	local actual=${1?${FUNCNAME[0]}: missing argument};   shift
	local expected=${1?${FUNCNAME[0]}: missing argument}; shift

	[[ $(realpath -m "$actual") = $(realpath -m "$expected") ]]
}

path.is.inside() {
	local path=${1?${FUNCNAME[0]}: missing argument};      shift
	local periphery=${1?${FUNCNAME[0]}: missing argument}; shift

	local relative
	relative=$(realpath --relative-to "$path" "$periphery" 2>/dev/null) || return

	[[ ! $relative =~ ^[.] ]]
}

path.dir() {
	local -n path_dir_=${1?${FUNCNAME[0]}: missing argument}; shift

	path.normalize path_dir_

	case $path_dir_ in
	*/*)
		path_dir_=${path_dir_%/*}
		[[ -n $path_dir_ ]] || path_dir_=/
		;;
	*)
		path_dir_=.
		;;
	esac
}

path.base() {
	local -n path_base_=${1?${FUNCNAME[0]}: missing argument}; shift
	local    ext=${1:-}

	path_base_=${path_base_##*/}
}

path.name() {
	local -n path_name_=${1?${FUNCNAME[0]}: missing argument}; shift
	local    ext=${1:-}

	path_name_=${path_name_##*/}
	path_name_=${path_name_%.*}
}

path.ext() {
	local -n path_ext_=${1?${FUNCNAME[0]}: missing argument}; shift

	path_ext_=${path_ext_##*/}

	case $path_ext_ in
	*.*)
		path_ext_=${path_ext_##*.}
		;;
	*)
		path_ext_=
		;;
	esac
}

path.subext() {
	local -n path_subext_=${1?${FUNCNAME[0]}: missing argument}; shift
	local    ext=${1?${FUNCNAME[0]}: missing argument};          shift

	case $path_subext_ in
	*.*)
		path_subext_=${path_subext_%.*}
		path_subext_=${path_subext_}.${ext}
		;;
	*)
		;;
	esac
}

path.suffixize() {
	local -n path_suffixize_=${1?${FUNCNAME[0]}: missing argument}; shift
	local    suffix=${1?${FUNCNAME[0]}: missing argument};          shift

	local -A _
	path.parse_ "$path_suffixize_"

	printf -v path_suffixize_ "%s/%s${suffix}%s" "${_[.dir]:-.}" "${_[.name]}" "${_[.dotext]}"
}

path.normalize() {
	local -n path_normalize_=${1?${FUNCNAME[0]}: missing argument}; shift

	while [[ $path_normalize_ =~ //+ ]]; do
		path_normalize_=${path_normalize_/\/\//\/}
	done
}

# shellcheck disable=2034
path.parse_() {
	local -n path_parse_=_

	if [[ ${1:-} = -A ]]; then
		shift
		path_parse_=${1?${FUNCNAME[0]}: missing argument}; shift
	fi

	local path=${1?${FUNCNAME[0]}: missing argument}; shift

	local dir=$path base=$path name=$path ext=$path

	path.dir dir
	path.base base
	path.name name
	path.ext ext

	path_parse_[.dir]=$dir
	path_parse_[.base]=$base
	path_parse_[.name]=$name
	path_parse_[.ext]=$ext

	if [[ -n $ext ]]; then
		path_parse_[.dotext]=.$ext
	else
		path_parse_[.dotext]=$ext
	fi
}


# trap.sh - Trap setup

declare -ag _at_exit_funcs_=()

declare -ag _at_exit_files_=()

# shellcheck disable=2120
trap.setup() {
	local -a signals=(EXIT HUP INT QUIT TERM)

	[[ $# -eq 0 ]] || signals=("$@")

	# shellcheck disable=2154,2218
	builtin trap _exit_ "${signals[@]}"

	at_exit _at_exit_cleanup_
}

# Prevent using trap
trap() {
	bug 'Using trap is forbidden; please use at_exit to register hooks.'
}

# Register hooks at exit
at_exit() {
	local arg

	for arg; do
		[[ $(type -t "$arg" || true) == function ]] || bug "Not a function: $arg"
	done

	_at_exit_funcs_=("$@" "${_at_exit_funcs_[@]}")
}

# Register files/directories to clean up at exit
at_exit_files() {
	_at_exit_files_+=("$@")
}

# trap.sh - Private functions

_exit_() {
	local err=$?

	local func
	for func in "${_at_exit_funcs_[@]}"; do
		"$func" || cry "Exit hook failed: $func"
	done

	return "$err"
}

_at_exit_cleanup_() {
	[[ ${#_at_exit_files_[@]} -gt 0 ]] || return 0

	rm -rf -- "${_at_exit_files_[@]}"
}

# temp.sh - Functions involving temporary directories or files

temp.file() {
	# shellcheck disable=2155
	local -n temp_file_=${1?${FUNCNAME[0]}: missing argument}; shift

	local file

	# shellcheck disable=2128
	file=$(mktemp -p "${TMPDIR:-/tmp}" "$PROGNAME".XXXXXXXX) || die 'Fatal error: mktemp'
	at_exit_files "$file"

	# shellcheck disable=2034
	temp_file_=$file
}

temp.dir() {
	# shellcheck disable=2155
	local -n temp_dir_=${1?${FUNCNAME[0]}: missing argument}; shift

	local dir

	# shellcheck disable=2128
	dir=$(mktemp -p "${TMPDIR:-/tmp}" -d "$PROGNAME".XXXXXXXX) || die 'Fatal error: mktemp'
	at_exit_files "$dir"

	# shellcheck disable=2034
	temp_dir_=$dir
}

# temp.inside: Execute command in temp dir
temp.inside() {
	local temp_dir orig_dir=$PWD
	temp.dir temp_dir

	must.success cd "$temp_dir"
	"$@"
	must.success cd "$orig_dir"

	rm -rf -- "$temp_dir"
}

temp.clean() {
	while [[ $# -gt 0 ]]; do
		local -n temp_clean_=$1; shift

		[[ -z ${!temp_clean_:-} ]] || rm -f -- "${!temp_clean_}"
	done
}

# os.sh - OS related functions

# os.virtual: Virtualization type
# shellcheck disable=2120
os.virtual() {
	local -A _=(
		[.argc]=0-
	)

	flag.parse

	systemd-detect-virt || true
}

# os.dist: Distribution name
# shellcheck disable=2120
os.dist() {
	local -A _; flag.parse

	# shellcheck disable=1091
	(unset ID && . /etc/os-release 2>/dev/null && echo "$ID")
}

# os.codename: Distribution codename
# shellcheck disable=2120
os.codename() {
	local -A _; flag.parse

	lsb_release -sc
}

# os.is: Detect OS feature
os.is() {
	local -A _=(
		[.help]='FEATURE'
		[.argc]=1-
	)

	flag.parse

	local feature=$1
	shift

	local func=os.is._"${feature}"

	must.callable "$func" "Unable to detect: $feature"

	"$func" "$@"
}

# os.sh - Private functions

# shellcheck disable=2120
os.is._virtual() {
	if [[ $# -gt 0 ]]; then
		[[ $(os.virtual) = "$1" ]]
	else
		[[ -z ${CI:-} ]] || return 0
		[[ -z ${PACKER_BUILDER_TYPE:-} ]] || return 0

		systemd-detect-virt -q
	fi
}

os.is._debian() {
	if [[ $# -gt 0 ]]; then
		case $1 in
		unstable|testing|sid)
			grep -qwE '(sid|unstable)' /etc/debian_version 2>/dev/null
			;;
		stable)
			! grep -qwE '(sid|unstable)' /etc/debian_version 2>/dev/null
			;;
		*)
			[[ "$(os.codename)" = "$1" ]]
			;;
		esac
	else
		[[ "$(os.dist)" = 'debian' ]]
	fi
}

os.is._ubuntu() {
	if [[ $# -gt 0 ]]; then
		[[ "$(os.codename)" = "$1" ]]
	else
		[[ "$(os.dist)" = 'ubuntu' ]]
	fi
}

os.is._proxmox() {
	available pveversion && uname -a | grep -q -i pve
}

os.is._vagrant() {
	# shellcheck disable=2119
	os.is._virtual || return 1

	[[ -d /vagrant ]] || id -u vagrant 2>/dev/null
}

os.is._physical() {
	! systemd-detect-virt -q
}

# url.sh - URL processing

# url.is: Assert URL feature
url.is() {
	local -A _=(
		[.help]='URL local|((proto|host|port|path|userinfo|frag) VALUE)'
		[.argc]=2-
	)

	flag.parse

	local url=$1 feature=$2

	if [[ $feature = local ]]; then
		[[ $url =~ ^(/|./|file://) ]]
		return
	fi

	url.parse_ "$url"
	url.is_ "$feature" "$@"
}

# url.sh - Protected functions

# Parse URL
# shellcheck disable=2034
url.parse_() {
	local -n url_parse_=_

	if [[ ${1:-} = -A ]]; then
		shift
		url_parse_=${1?${FUNCNAME[0]}: missing argument}; shift
	fi

	local url=${1?${FUNCNAME[0]}: missing argument}; shift

	# shellcheck disable=1007
	local proto= userinfo= host= port= path= frag=

	if [[ $url =~ ^(/|./|file://) ]]; then
		proto='file';  url=${url#*://}
		tag=${url#*@}; url=${url%@*}
		path=$url

		# shellcheck disable=2209
		url_parse_[.proto]=file
		url_parse_[.path]=$path

		return 0
	fi

	if [[ $url =~ ^.+:// ]]; then
		proto=${url%%://*}; url=${url#*://}
	fi

	if [[ $url =~ ^[^@/]+@[^/:]+ ]]; then
		userinfo=${url%%@*}; url=${url#*@}
	fi

	if [[ $url =~ ^[^:]+:[0-9]+ ]]; then
		host=${url%%:*};      url=${url#$host:}
		port=${url%%[^0-9]*}; url=${url#$port}
	else
		host=${url%%[/:]*};   url=${url#*[/:]}
	fi

	if [[ $url =~ ^: ]]; then
		url=${url#*:}

		if [[ -n $proto ]]; then
			if [[ $proto != ssh ]]; then
				# shellcheck disable=2154
				url_parse_[.error]='protocol mismatch'
				return 1
			fi
		else
			proto=ssh
		fi
	else
		url=${url#/}

		if [[ -n $proto && $proto = ssh ]]; then
			url_parse_[.error]='invalid SSH url'
			return 1
		fi
	fi

	if [[ -z $proto ]]; then
		proto=https
	fi

	if [[ $url =~ [#].*$ ]]; then
		frag=${url#*#}; url=${url%#*}
	fi

	path=$url

	url_parse_[.frag]=$frag
	url_parse_[.host]=$host
	url_parse_[.path]=$path
	url_parse_[.port]=$port
	url_parse_[.proto]=$proto
	url_parse_[.userinfo]=$userinfo
}

url.is_() {
	local feature=${1?${FUNCNAME[0]}: missing argument};  shift
	local expected=${1?${FUNCNAME[0]}: missing argument}; shift

	[[ ${_[.${feature}]:-} = "$expected" ]]
}

# https.sh - HTTP functions

# http.get: Get URL
http.get() {
	local -A _=(
		[.help]='URL'
		[.argc]=1
	)

	flag.parse

	local url=$1

	[[ $url =~ ^.*:// ]] || url=https://$url

	curl -fsSL "$url"
}

# http.is: Assert URL response
http.is() {
	local -A _=(
		[.help]='URL CODE'
		[.argc]=2
	)

	flag.parse

	local url=$1 code=$2

	if [[ ${code,,} = ok ]]; then
		code=200
	fi

	local response
	response=$(curl -fsL -w '%{http_code}\n' -o /dev/null "$url" || true)

	[[ $response = "$code" ]]
}

# file.sh - File related operations

# file.install: Install file from URL
file.install() {
	# shellcheck disable=2192
	local -A _=(
		[-group]=
		[-mode]=
		[-owner]=
		[-prefix]=

		[.help]='[-(group|mode|owner|prefix)=VALUE] URL [FILE]'
		[.argc]=1
	)

	flag.parse

	local url=$1 dst=${2:-${1##*/}}

	file.install_ "$url" "$dst"
}

# Copy file/directory to dstination creating all parents if necessary
file.copy() {
	file._do_args_ copy "$@"
}

# Move file/directory to destination creating all parents if necessary
file.move() {
	file._do_args_ move "$@"
}

# Link file/directory to dstination creating all parents if necessary
file.link() {
	file._do_args_ link "$@"
}

file.chogm() {
	# shellcheck disable=2192
	local -A _=(
		[-group]=
		[-mode]=
		[-owner]=

		[.help]='[-(group|mode|owner)=VALUE] URL [FILE]'
		[.argc]=1
	)

	flag.parse

	local dst=$1

	file.chogm_ "$dst"
}

# file.sh - Protected functions

file.ln() {
	local src=${1?${FUNCNAME[0]}: missing argument}; shift
	local dst=${1?${FUNCNAME[0]}: missing argument}; shift

	src=$(realpath -m --relative-base "${dst%/*}" "$src")
	must.success ln -sf "$src" "$dst"
}

file.enter() {
	local dir=${1:-}

	[[ -n $dir ]] || return 0

	if [[ -d $dir ]]; then
		must.success cd "$dir"
	else
		dir=${dir%/*}
		[[ -d $dir ]] || die "No path found to enter: $dir"
		must.success cd "$dir"
	fi
}

file.download() {
	local    url=${1?${FUNCNAME[0]}: missing argument};                shift
	local -n file_download_dst_=${1?${FUNCNAME[0]}: missing argument}; shift

	local tempfile

	temp.file tempfile
	must.success http.get "$url" >"$tempfile"

	# shellcheck disable=2034
	file_download_dst_=$tempfile
}

file.do_() {
	local op=${1?${FUNCNAME[0]}: missing argument};  shift
	local src=${1?${FUNCNAME[0]}: missing argument}; shift
	local dst=${1?${FUNCNAME[0]}: missing argument}; shift

	[[ -e $src ]] || die "Source not found: $src"

	file.dst_ dst

	local dstdir
	if string.has_suffix_deleted dst /; then
		dstdir=$dst
	else
		dstdir=$dst
		path.dir dstdir
	fi

	[[ $dstdir = . ]] || must.success mkdir -p "$dstdir"

	case $op in
	copy)
		must.success cp -a "$src" "$dst"
		;;
	move)
		must.success mv -f "$src" "$dst"
		;;
	link)
		file.ln "$src" "$dst"
		;;
	*)
		bug "Unrecognized operation: $op"
		;;
	esac

	file._chogm_ "$dst"
}

file.dst_() {
	local -n file_dst_=${1?${FUNCNAME[0]}: missing argument}; shift

	[[ -z ${_[-prefix]:-} ]] || file_dst_=${_[-prefix]}/$file_dst_
}

file.install_() {
	local url=${1?${FUNCNAME[0]}: missing argument}; shift
	local dst=${1?${FUNCNAME[0]}: missing argument}; shift

	local tempfile=

	if url.is "$url" local; then
		src=$url
	else
		temp.file tempfile
		http.get "$url" >"$tempfile"
		src=$tempfile
	fi

	file.do_ copy "$src" "$dst"

	temp.clean tempfile
}

# file.sh - Private functions

file._do_args_() {
	local op=${1?${FUNCNAME[0]}: missing argument}; shift

	# shellcheck disable=2192
	local -A _=(
		[-group]=
		[-mode]=
		[-owner]=
		[-prefix]=

		[.help]='[-(GROUP|MODE|OWNER|PREFIX)=VALUE] SRC [DST]'
		[.argc]=1
	)

	flag.parse

	local src=$1 dst=$2

	file.do_ "$op" "$src" "$dst"
}

file._chogm_() {
	local dst=${1?${FUNCNAME[0]}: missing argument}; shift

	[[ -z ${_[-mode]:-}  ]] || must.success chmod "${_[-mode]}"  "$dst"
	[[ -z ${_[-owner]:-} ]] || must.success chown "${_[-owner]}" "$dst"
	[[ -z ${_[-group]:-} ]] || must.success chgrp "${_[-group]}" "$dst"
}

# bin.sh - Executable files

# bin.install: Install program to path
bin.install() {
	# shellcheck disable=2192
	local -A _=(
		[-prefix]="$_USR"/bin
		[-name]=

		[.help]='URL|FILE'
		[.argc]=1
	)

	flag.parse

	bin.install_ "$@"
}

# bin.use: Use program
bin.use() {
	# shellcheck disable=2192
	local -A _=(
		[-prefix]="$_RUN"/bin
		[-name]=

		[.help]='URL|FILE'
		[.argc]=1
	)

	flag.parse

	bin.install_ "$@"
}

# bin.sh - Protected functions

bin.install_() {
	local url=$1

	# shellcheck disable=1007
	local bin= tempfile= tempdir=

	if url.is "$url" local; then
		bin=$url
	else
		file.download tempfile
		bin=$tempfile
	fi

	if is.file compressed "$bin"; then
		zip.unpack "$bin" tempdir
		bin=$tempdir
	fi

	local -a bins
	bin._inspect "$bin" bins

	if [[ ${#bins[@]} -eq 1 ]]; then
		local src=${bins[0]} dst=${_[-name]:-}

		file.install -prefix="${_[-prefix]}" -mode=755 "$src" "$dst"
	elif [[ ${#bins[@]} -gt 1 ]]; then
		[[ -n ${_[-name]:-} ]] || die "Ambiguous usage of name argument: ${_[-name]}"

		local src
		for src in "${bins[@]}"; do
			file.install -prefix="${_[-prefix]}" -mode=755 "$src"
		done
	else
		die "No program found: $url"
	fi

	temp.clean tempfile tempdir
}

# bin.sh - Private functions

bin._inspect() {
	local    bin=${1?${FUNCNAME[0]}: missing argument};          shift
	local -n bin_inspect_=${1?${FUNCNAME[0]}: missing argument}; shift

	if [[ -d $bin ]]; then
		local file
		for file in "$bin"/*; do
			is.file program "$file" || continue
			bin_inspect_+=("$file")
		done
	elif is.file program "$bin"; then
		bin_inspect_+=("$file")
	fi
}

# git.sh - Git functions

git.update() {
	local -A _=(
		[-expiry]=3

		[.help]='[-expiry=MINUTES]'
		[.argc]=0
	)

	flag.parse

	if expired "${_[-expiry]}" .git/FETCH_HEAD; then
		git.must.clean
		git pull --quiet origin
	fi
}

# git.sh - Protected functions

git.is.git() {
	local path=${1:-.}

	[[ -d $path/.git ]] && git rev-parse --resolve-git-dir "$path/.git" &>/dev/null
}

git.is.clean() {
	git rev-parse --verify HEAD >/dev/null &&
	git update-index -q --ignore-submodules --refresh &&
	git diff-files --quiet --ignore-submodules &&
	git diff-index --cached --quiet --ignore-submodules HEAD --
}

git.must.sane() {
	git rev-parse --is-inside-work-tree &>/dev/null || die "Must be inside a git work tree: $PWD"
	git rev-parse --verify HEAD >/dev/null          || die "Unverified git HEAD: $PWD"
}

git.must.clean() {
	git.is.clean || die "Must be a clean git work tree: $PWD"
}

git.topdir() {
	local dir

	dir=$(git rev-parse --git-dir) && dir=$(cd "$dir" && pwd)/ && echo "${dir%%/.git/*}"
}

git.top() {
	git.must.sane

	must.success cd "$(git.topdir)"
}

git.default_branch() {
	git.must.sane

	git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@'
}

git.switch() {
	local branch=${1:-}

	[[ -n $branch ]] || branch=$(git.default_branch)

	git checkout --quiet "$branch"
}

git.dst_() {
	file.dst_ "$@"
}

git.is.exist_() {
	local dst=${1?${FUNCNAME[0]}: missing argument}; shift

	git.dst_ dst

	[[ -d $dst ]]
}

git.enter_() {
	local dst=${1?${FUNCNAME[0]}: missing argument}; shift

	git.dst_ dst

	[[ -d $dst ]] || die "Destination not found: $dst"

	must.success pushd "$dst" >/dev/null

	git.is.git . || die "Not a git repository: $PWD"

	file.enter "${_[.dir]:-}"
}

git.clone_() {
	local url=${1?${FUNCNAME[0]}: missing argument}; shift
	local dst=${1?${FUNCNAME[0]}: missing argument}; shift

	! git.is.exist_ "$dst" || die "Destination already exist: $dst"

	local -a opt

	[[ -z ${_[-shallow]:-} ]] || opt+=(--depth 1)
	[[ -z ${_[.branch]:-}   ]] || opt+=(--branch "${_[.branch]}")

	_func_() {
		git clone "${opt[@]}" "$url" .
		file.do_ copy . "$dst"
	}

	temp.inside _func_

	unset -f _func_
}

git.update_() {
	local dst=${1?${FUNCNAME[0]}: missing argument}; shift

	git.enter_ "$dst"

	git.switch "${_[.branch]:-}"

	local -i expiry=${_[-expiry]:-3}
	if expired "$expiry" .git/FETCH_HEAD; then
		git.must.clean

		say 'Updating repository...'
		git pull --quiet origin
	fi

	must.success popd >/dev/null
}

# src.sh - Source management

# src.install: Install to a known location
src.install() {
	# shellcheck disable=2192
	local -A _=(
		[-expiry]=
		[-prefix]="$_USR"/src

		[.help]='[-(expiry=MINUTES|prefix=DIR)] URL'
		[.argc]=1
	)

	flag.parse

	src.install_ "$@"
}

# src.use: Install src into the runtime tree
src.use() {
	# shellcheck disable=2192
	local -A _=(
		[-expiry]=
		[-prefix]="$_RUN"/src
		[-shallow]=false

		[.help]='[-(expiry=MINUTES|prefix=DIR|shallow=BOOL)] URL'
		[.argc]=1
	)

	flag.parse

	src.install_ "$@"
}

# enter: Get src from URL and enter to the directory
src.enter() {
	# shellcheck disable=2192
	local -A _=(
		[-expiry]=
		[-prefix]="$_RUN"/src
		[-shallow]=false

		[.help]='[-(expiry=MINUTES|prefix=DIR|shallow=BOOL)] URL'
		[.argc]=1
	)

	flag.parse

	src.install_ "$@" >/dev/null

	echo "$PWD"
}

# run: Run src from URL
src.run() {
	# shellcheck disable=2192
	local -A _=(
		[-expiry]=-1
		[-prefix]="$_RUN"/src
		[-pwd]=
		[-shallow]=false
		[-test]=false

		[.help]='[-(expiry=MINUTES|prefix=DIR|pwd=DIR|shallow=BOOL|test=BOOL)] url'
		[.argc]=1
	)

	flag.parse

	src.install_ "$@"

	src.run_ "${_[.dir]}"
	flag.false test || src.test_ "${_[.dir]}"
}

# src.sh - Protected functions

src.interprete() {
	local file=${1?${FUNCNAME[0]}: missing argument}; shift

	local ext=$file
	path.ext ext

	if [[ -z $ext ]]; then
		# shellcheck disable=2209
		ext=sh
		file=$file.$ext
	fi

	[[ -f $file ]] || die "Not file found to interprete: $file"

	local interpreter
	case $ext in
	sh)  interpreter=bash   ;;
	rb)  interpreter=ruby   ;;
	py)  interpreter=python ;;
	pl)  interpreter=perl   ;;
	js)  interpreter=node   ;;
	php) interpreter=php    ;;
	*)   die "Unsupported interpreter for extension: $ext" ;;
	esac

	env "$@" "$interpreter" "$file"
}

src.managed_() {
	local path=${1?${FUNCNAME[0]}: missing argument}; shift

	git.is.git "$path" && git -C "$path" config underscore.name &>/dev/null
}

src.install_() {
	local url=${1?${FUNCNAME[0]}: missing argument}; shift

	url.parse_ "$url" || die "Error parsing URL: ${_[.error]}: $url"

	src._plan_ || die "Error planning URL: ${_[.error]}: $url"

	local src=${_[1]} dst=${_[2]:-}

	if src.exist_ "$dst"; then
		src.update_ "$dst"
	else
		src.get_ "$src" "$dst"
	fi

	src.enter_ "$dst"
}

src.run_() {
	local file=${1?${FUNCNAME[0]}: missing argument}; shift

	path.base file

	hey "$file"
	src.exe_ "$file"
}

src.test_() {
	local file=${1?${FUNCNAME[0]}: missing argument}; shift

	local test_file=$file
	path.suffixize test_file '_test'

	src.run_ "$test_file"
}

src.exe_() {
	local file=${1?${FUNCNAME[0]}: missing argument}; shift

	local -a env; src.env_ env

	if [[ -x $file ]]; then
		env "${env[@]}" "$file"
	else
		src.interprete "$file" "${env[@]}"
	fi
}

src.env_() {
	# shellcheck disable=2034
	local -n src_env_=${1?${FUNCNAME[0]}: missing argument}; shift

	flag.env_ src_env_
}

src.dst_() {
	git.dst_ "$@"
}

src.exist_() {
	git.is.exist_ "$@"
}

src.get_() {
	git.clone_ "$@"
}

src.update_() {
	git.update_ "$@"
}

src.enter_() {
	git.enter_ "$@"
}

# src.sh - Private functions

src._plan_() {
	local owner repo auth path

	if [[ ! ${_[.host]} =~ ^(github.com|gitlab.com|bitbucket.com)$ ]]; then
		_[.error]='unsupported provider'
		return 1
	fi

	path=${_[.path]:-}

	if [[ ! $path =~ [^/]+/[^/]+ ]]; then
		_[.error]='incomplete url'
		return 1
	fi

	if [[ $path =~ @.*$ ]]; then
		_[.branch]=${path#*@}; path=${path%@*}
		_[.path]=$path
	fi

	owner=${path%%/*}; path=${path#*/}

	_[.dir]=
	if [[ $path = */* ]]; then
		_[.dir]=${path#*/}; path=${path%%/*}
	fi

	repo=${path%.git}

	_[.name]=${_[.host]}/$owner/$repo

	if [[ ${_[.proto]} == https ]] && [[ -n ${HTTPS_TOKEN:-} ]]; then
		auth="${HTTPS_TOKEN}:x-oauth-basic"
	else
		auth=${_[.userinfo]}
	fi

	if [[ -n ${auth:-} ]]; then
		_[1]=${_[.proto]}://$auth@${_[.name]}.git
	else
		_[1]=${_[.proto]}://${_[.name]}.git
	fi

	_[2]=${_[.name]}
}


# deb.sh - Debian package management

export DEBIAN_FRONTEND=noninteractive APT_KEY_DONT_WARN_ON_DANGEROUS_USAGE=DontWarn

# deb.install: Install Debian packages
deb.install() {
	# shellcheck disable=2192
	local -A _=(
		[-missings]=false
		[-shiny]=false

		[.help]='PACKAGE...'
	)

	flag.parse

	[[ $# -gt 0 ]] || return 0

	local -a opts=(
		--yes
		--no-install-recommends
	)

	local -a packages urls non_urls

	local arg
	for arg; do
		if is.url "$arg"; then
			urls+=("$arg")
		else
			non_urls+=("$arg")
		fi
	done

	if flag.true missings; then
		deb._missings packages "${non_urls[@]}"
	else
		packages=("${non_urls[@]}")
	fi

	if flag.true shiny; then
		local target

		if is.debian stable; then
			target=$(what.debian codename)-backports
		elif is.debian unstable; then
			target=experimental
		fi

		if [[ -n ${target:-} ]]; then
			deb.using "$target"

			opts+=(
				--target-release
				"$target"
			)
		fi
	fi

	deb.update

	[[ "${#packages[@]}" -eq 0 ]] || apt-get install "${opts[@]}" "${packages[@]}"
	[[ "${#urls[@]}" -eq 0     ]] || deb._install_from_urls "${urls[@]}"
}

# deb.uninstall: Uninstall Debian packages
deb.uninstall() {
	# shellcheck disable=2192
	local -A _=(
		[.help]='PACKAGE...'
	)

	flag.parse

	local -a packages

	deb._missings packages "$@"
	[[ ${#packages[@]} -gt 0 ]] || return 0

	apt-get purge -y "${packages[@]}"

	must.proceed apt-get autoremove -y && must.proceed apt-get autoclean -y
}

# deb.missings: Print missing packages among given packages
deb.missings() {
	# shellcheck disable=2192
	local -A _=(
		[.help]='PACKAGE...'
	)

	flag.parse

	local -a missings
	deb._missings missings "$@"

	for package in "${missings[@]}"; do
		echo "$package"
	done
}

# deb.update: Update Debian package index
# shellcheck disable=2120
deb.update() {
	# shellcheck disable=2192
	local -A _=(
		[.help]=
		[.argc]=0
	)

	flag.parse

	expired 60 /var/cache/apt/pkgcache.bin || apt-get update -y
}

# deb.repository: Add Debian repository
deb.repository() {
	# shellcheck disable=2192
	local -A _=(
		[.help]='NAME [URL]'
		[.argc]=1-
	)

	flag.parse

	local name=$1 url=${2:-}

	must.piped

	if [[ -n ${url:-} ]]; then
		deb._apt_key_add "$url" || return 0
	fi

	cat >/etc/apt/sources.list.d/"$name".list
	apt-get update -y
}

# deb.using: Use given official Debian distributions
deb.using() {
	# shellcheck disable=2192
	local -A _=(
		[.help]='DIST...'
		[.argc]=1-
	)

	flag.parse

	local dist
	for dist; do
		case $dist in
		stable|testing|unstable|sid|experimental)
			;;
		*)
			deb._dist_valid "$dist" || die "Invalid distribution: $dist"
			;;
		esac

		deb._dist_added "$dist" || deb.repository "$dist" <<-EOF
			deb http://ftp.debian.org/debian $dist main contrib non-free
		EOF
	done
}

# deb.sh - Private functions

deb._dist_valid() {
	local dist=${1?${FUNCNAME[0]}: missing argument}; shift

	http.is OK http://ftp.debian.org/debian/dists/"$dist"/
}

deb._dist_added() {
	local dist=${1?${FUNCNAME[0]}: missing argument}; shift

	grep -qE "^deb.*\bdebian.org\b.*\b$dist\b" /etc/apt/*.list /etc/apt/sources.list.d/*.list
}

deb._apt_key_add() {
	local url=${1?${FUNCNAME[0]}: missing argument}; shift

	local tempfile
	temp.file tempfile

	http.get "$url" >"$tempfile" || die "Couldn't get key file: $url"

	local -a questioned_fingerprints installed_fingerprints

	mapfile -t questioned_fingerprints < <(
		gpg -nq --import --import-options import-show --with-colons "$tempfile" | awk -F: '$1 == "fpr" { print $10 }' 2>/dev/null
	)

	# shellcheck disable=2034
	mapfile -t installed_fingerprints < <(
		apt-key adv --list-public-keys --with-fingerprint --with-colon | awk -F: '$1 == "fpr" { print $10 }' 2>/dev/null
	)

	local fingerprint
	for fingerprint in "${questioned_fingerprints[@]}"; do
		included "$fingerprint" "${installed_fingerprints[@]}" || return 1
	done

	apt-key add "$tempfile"

	rm -f -- "$tempfile"
}

deb._missings() {
	local -a deb_missings_=${1?${FUNCNAME[0]}: missing argument}; shift

	local package
	for package in "${[@]}"; do
		# shellcheck disable=2016
		if [ -z "$(dpkg-query -W -f='${Installed-Size}' "$package" 2>/dev/null ||:)" ]; then
			deb_missings_+=("$package")
		fi
	done
}

deb._install_from_urls() {
	local url

	for url; do
		local deb

		file.download "$url" deb

		dpkg-deb --info "$deb" &>/dev/null || die "Not a valid Debian package: $url"
		dpkg -i -- "$deb" 2>/dev/null || true
		apt-get -y install --no-install-recommends --fix-broken

		rm -f -- "$deb"
	done
}

# text.sh - Text blob manipulations

# text.fix: Append stdin content to the target file
text.fix() {
	local -A _=(
		[.help]='FILE'
		[.argc]=1
	)

	flag.parse

	local file=$1; must.f "$file"

	text._unfix "$file"

	{
		echo '# BEGIN FIX'
		cat
		echo '# END FIX'
	} >>"$file"
}

# text.unfix: Remove appended content
text.unfix() {
	local -A _=(
		[.help]='FILE'
		[.argc]=1
	)

	flag.parse

	local file=$1; must.f "$file"

	text._unfix "$file"
}

# text.sh - Private functions

text._unfix() {
	local file=${1?${FUNCNAME[0]}: missing argument}; shift

	grep -qE '(BEGIN|END) FIX' "$file" || return 0
	must.w "$file"
	sed -i '/BEGIN FIX/,/END FIX/d' "$file"
}

# filetype.sh - Filetype detection

# filetype.mime: What mime type
filetype.mime() {
	local -A _=(
		[-zip]=false

		[.help]='FILE'
		[.argc]=1
	)

	flag.parse

	local file=$1; must.f "$file"

	if flag.true zip; then
		file --mime-type --brief --uncompress-noreport "$file"
	else
		file --mime-type --brief "$file"
	fi
}


# filetype.is: Detect file type
filetype.is() {
	local -A _=(
		[-zip]=false

		[.help]='FILE'
		[.argc]=1
	)

	flag.parse

	local file=$1; must.f "$file"

	filetype.is_ "$@"
}

# filetype.sh - Protected functions

filetype.is_() {
	local file=${1?${FUNCNAME[0]}: missing argument}; shift
	local type=${1?${FUNCNAME[0]}: missing argument}; shift

	local func=filetype.is._"${type}"_

	must.callable "$func" "Unable to know type: $type"

	"$func" "$file" "$@"
}

# filetype.sh - Private functions

filetype.is._mime_() {
	local file=${1?${FUNCNAME[0]}: missing argument};     shift
	local expected=${1?${FUNCNAME[0]}: missing argument}; shift

	local mime
	if flag.true zip; then
		mime=$(file --mime-type --brief --uncompress-noreport "$file")
	else
		mime=$(file --mime-type --brief "$file")
	fi

	_[.file.mime]=$mime

	[[ $mime = "$expected" ]]
}

filetype.is._program_() {
	local file=${1?${FUNCNAME[0]}: missing argument}; shift

	local mime encoding

	IFS='; ' read -r mime encoding < <(file --mime --brief "$file")

	if [[ $encoding =~ binary$ ]]; then
		if [[ $mime  =~ -executable$ ]]; then
			_[.file.program]=binary
			return 0
		fi
	else
		if head -n 1 "$file" | grep -q '^#!'; then
			_[.file.program]=script
			return 1
		fi
	fi

	return 1
}

filetype.is._compressed_() {
	local file=${1?${FUNCNAME[0]}: missing argument}; shift

	local mime; mime=$(file --mime-type --brief "$file")

	case $mime in
	application/gzip|application/zip|application/x-xz|application/x-bzip2|application/x-zstd)
		local zip=$mime; zip=${zip##*/}; zip=${zip##*-}

		if [[ $(file --mime-type --brief --uncompress-noreport "$file") = application/x-tar ]]; then
			_[.file.zip]=tar.$zip
		else
			_[.file.zip]=$zip
		fi

		return 0 ;;
	*)
		return 1 ;;
	esac
}

# unzip: Unpack compressed file
zip.unpack() {
	local -A _=(
		[-force]=false
		[-clean]=false

		[.help]='[-(force|clean)=BOOL] FILE'
		[.argc]=1-
	)

	flag.parse

	local in=$1 out=${2:-};	must.f "$in"

	filetype.is_ "$in" compressed || die "Not a compressed file of known type: $in"

	local func=zip._unpack_.${_[.file.zip]:-}

	must.callable "$func" "Unsupported compressed file: $in"

	"$func" "$in" "$out"

	if flag.true clean; then
		rm -f -- "$in"
	fi
}

zip._unpack_.tar.gz() {
	local in=${1?${FUNCNAME[0]}: missing argument}; out=${2:-}

	zip._prep_untar_

	tar --strip-components=1 -zxvf "$in" -C "$out"
}

zip._unpack_.tar.bz2() {
	local in=${1?${FUNCNAME[0]}: missing argument}; out=${2:-}

	zip._prep_untar_ bzip2

	tar --strip-components=1 -jxvf "$in" -C "$out"
}

zip._unpack_.tar.xz() {
	local in=${1?${FUNCNAME[0]}: missing argument}; out=${2:-}

	zip._prep_untar_ xz

	tar --strip-components=1 -Jxvf "$in" -C "$out"
}

zip._unpack_.tar.zst() {
	local in=${1?${FUNCNAME[0]}: missing argument}; out=${2:-}

	zip._prep_untar_ zstd

	tar --strip-components=1 --zstd -xvf "$in" -C "$out"
}

zip._unpack_.zip() {
	local in=${1?${FUNCNAME[0]}: missing argument}; out=${2:-}

	zip._prep_unzip_ unzip

	unzip -q -d "$out" "$in"
}

zip._unpack_.gz() {
	local in=${1?${FUNCNAME[0]}: missing argument}; out=${2:-}

	zip._prep_unzip_ zcat

	local tempfile
	temp.file tempfile

	zcat "$in" >"$tempfile" && mv "$tempfile" "$out"
}

zip._unpack_.bz2() {
	local in=${1?${FUNCNAME[0]}: missing argument}; out=${2:-}

	zip._prep_unzip_ bzcat

	local tempfile
	temp.file tempfile

	bzcat "$in" >"$tempfile" && mv "$tempfile" "$out"
}

zip._unpack_.xz() {
	local in=${1?${FUNCNAME[0]}: missing argument}; out=${2:-}

	zip._prep_unzip_ unxz

	local tempfile
	temp.file tempfile

	unxz "$in" >"$tempfile" && mv "$tempfile" "$out"
}

zip._unpack_.zst() {
	local in=${1?${FUNCNAME[0]}: missing argument}; out=${2:-}

	zip._prep_unzip_ zstdcat

	local tempfile
	temp.file tempfile

	zstdcat -f "$in" >"$tempfile" && mv "$tempfile" "$out"
}

zip._prep_unzip_() {
	local in=${1?${FUNCNAME[0]}: missing argument}; out=${2:-}

	local prog
	for prog; do
		must.available "$prog"
	done

	[[ -n $out ]] || out=${in%.*}

	if [[ -e $out ]]; then
		if flag.true force; then
			must.success rm -rf -- "$out"
		else
			die "File already exist: $out"
		fi
	fi
}

zip._prep_untar_() {
	local in=${1?${FUNCNAME[0]}: missing argument}; out=${2:-}

	local prog
	for prog; do
		must.available "$prog"
	done

	[[ -n $out ]] || out=${in%.tar.*}

	if [[ -e $out ]]; then
		if flag.true force; then
			must.success rm -rf -- "$out"
		else
			die "Directory already exist: $out"
		fi
		must.success mkdir -p "$out"
	else
		must.success mkdir -p "$out"
	fi
}

declare -Ag _help=(
	['say']='Print messages on standard error'
	['die']='Print error messages and exit failure'
	['cry']='Print warning messages on standard error'
	['bug']='Report bug and exit failure'
	['hey']='Print messages taking attention'
	['self version']='Print self version'
	['self name']='Print self name'
	['self path']='Print self path'
	['self install']='Install self'
	['temp inside']='Execute command in temp dir'
	['os virtual']='Virtualization type'
	['os dist']='Distribution name'
	['os codename']='Distribution codename'
	['os is']='Detect OS feature'
	['url is']='Assert URL feature'
	['http get']='Get URL'
	['http is']='Assert URL response'
	['file install']='Install file from URL'
	['bin install']='Install program to path'
	['bin use']='Use program'
	['src install']='Install to a known location'
	['src use']='Install src into the runtime tree'
	['enter']='Get src from URL and enter to the directory'
	['run']='Run src from URL'
	['deb install']='Install Debian packages'
	['deb uninstall']='Uninstall Debian packages'
	['deb missings']='Print missing packages among given packages'
	['deb update']='Update Debian package index'
	['deb repository']='Add Debian repository'
	['deb using']='Use given official Debian distributions'
	['text fix']='Append stdin content to the target file'
	['text unfix']='Remove appended content'
	['filetype mime']='What mime type'
	['filetype is']='Detect file type'
	['unzip']='Unpack compressed file'
)

declare -Ag _command=(
	['say']='ui.say'
	['die']='ui.die'
	['cry']='ui.cry'
	['bug']='ui.bug'
	['hey']='ui.hey'
	['self version']='self.version'
	['self name']='self.name'
	['self path']='self.path'
	['self install']='self.install'
	['temp inside']='temp.inside'
	['os virtual']='os.virtual'
	['os dist']='os.dist'
	['os codename']='os.codename'
	['os is']='os.is'
	['url is']='url.is'
	['http get']='http.get'
	['http is']='http.is'
	['file install']='file.install'
	['bin install']='bin.install'
	['bin use']='bin.use'
	['src install']='src.install'
	['src use']='src.use'
	['enter']='src.enter'
	['run']='src.run'
	['deb install']='deb.install'
	['deb uninstall']='deb.uninstall'
	['deb missings']='deb.missings'
	['deb update']='deb.update'
	['deb repository']='deb.repository'
	['deb using']='deb.using'
	['text fix']='text.fix'
	['text unfix']='text.unfix'
	['filetype mime']='filetype.mime'
	['filetype is']='filetype.is'
	['unzip']='zip.unpack'
)

.init() {
	trap.setup
}

.usage() {
	local cmd

	# shellcheck disable=2128
	say "$PROGNAME COMMAND... [-FLAG=VALUE...] [ARGS]"
	say "Commands:"

	# shellcheck disable=2154
	for cmd in "${!_help[@]}"; do
		printf "\\t%-24s  %s\n" "$cmd" "${_help[$cmd]}"
	done | sort >&2
}

.execute() {
	.init

	if [[ $# -eq 0 ]]; then
		.usage
		die 'Command required'
	fi

	local help=

	if [[ $1 = help ]]; then
		help=true

		shift

		if [[ $# -eq 0 ]]; then
			.usage
			die 'Help topic required'
		fi
	fi

	local -a args=("$@")

	local fun
	local try cmd

	while [[ $# -gt 0 ]]; do
		try+=("$1")
		shift

		if [[ -n ${_command[${try[*]}]:-} ]]; then
			cmd=${try[*]}; fun=${_command[$cmd]}
			break
		fi
	done

	if [[ -z ${fun:-} ]]; then
		die "No command found: ${args[*]}"
	fi

	PROGNAME+=("$cmd"); readonly PROGNAME

	if [[ -n ${help:-} ]]; then
		say "${_help[$cmd]}" ""

		"$fun" -help
	else
		"$fun" "$@"
	fi
}

.source() {
	echo "UNDERSCORE=$(self.path)"
	echo
	cat <<'EOF'
.() {
	# prelude.sh - Standard prelude

	[ -n "${BASH_VERSION:-}"        ] || { echo >&2 'Bash required.';                         exit 1; }
	[[ ${BASH_VERSINFO[0]:-} -ge 4 ]] || { echo >&2 'Bash version 4 or higher required.';     exit 1; }
	[[ -x /usr/bin/apt-get         ]] || { echo >&2 'Only Debian and derivatives supported.'; exit 1; }

	set -Eeuo pipefail; shopt -s nullglob; [[ -z ${TRACE:-} ]] || set -x; unset CDPATH; IFS=$' \t\n'

	export LC_ALL=C.UTF-8 LANG=C.UTF-8

	declare -grx UNDERSCORE=$UNDERSCORE

	case ${1:-} in
	-root)
		[[ ${EUID:-} -eq 0 ]] || { echo >&2 'Root privileges required.'; exit 1; }
		shift
		;;
	esac

	_.die() {
		"$UNDERSCORE" die "$@"; exit $?
	}

	_.cry() {
		"$UNDERSCORE" cry "$@"; exit $?
	}

	_.bye() {
		"$UNDERSCORE" bye "$@"; exit $?
	}

	_.bug() {
		"$UNDERSCORE" bug "$@"; exit $?
	}

	_.enter() {
		local dir

		if dir=$("$UNDERSCORE" enter "$@") && [[ -n $dir ]]; then
			pushd "$dir" &>/dev/null || exit
		fi
	}

	_.leave() {
		popd &>/dev/null || exit
	}

	unset -f "${FUNCNAME[0]}"
}

_() {
	local cmd=$1

	case $cmd in
	die|cry|bye|bug|enter|leave) shift; _."$cmd" "$@" ;;
	*)                       "$UNDERSCORE" "$@"   ;;
	esac
}

. "$@"
EOF
}

.sourced() {
	if [[ $# -gt 0 ]]; then
		[[ $1 = . ]] && return 0 # source explicitly specified
	else
		[[ -t 1   ]] || return 0 # backticked or piped without args
	fi

	return 1
}

.main() {
	if .sourced "$@"; then
		.source "$@"
	else
		.execute "$@"
	fi
}

[[ "${BASH_SOURCE[0]}" != "$0" ]] || .main "$@"
